{"version":3,"file":"hls.worker.js.map","sources":["src/events.ts","src/errors.ts","src/crypt/aes-crypto.ts","src/crypt/fast-aes-key.ts","src/utils/typed-array.ts","src/crypt/aes-decryptor.ts","src/utils/logger.ts","src/polyfills/number.ts","node_modules/url-toolkit/src/url-toolkit.js","src/loader/fragment.ts","src/demux/id3.ts","src/utils/hex.ts","src/utils/mp4-tools.ts","src/crypt/decrypter.ts","src/types/demuxer.ts","src/demux/dummy-demuxed-track.ts","src/demux/audio/base-audio-demuxer.ts","src/demux/audio/adts.ts","src/demux/audio/mpegaudio.ts","src/demux/audio/aacdemuxer.ts","src/demux/mp4demuxer.ts","src/demux/audio/dolby.ts","src/demux/audio/ac3-demuxer.ts","src/demux/video/base-video-parser.ts","src/demux/video/exp-golomb.ts","src/demux/video/avc-video-parser.ts","src/demux/video/hevc-video-parser.ts","src/demux/sample-aes.ts","src/demux/tsdemuxer.ts","src/demux/audio/mp3demuxer.ts","src/remux/aac-helper.ts","src/remux/mp4-generator.ts","src/types/loader.ts","src/utils/timescale-conversion.ts","src/remux/mp4-remuxer.ts","src/utils/codecs.ts","src/utils/mediasource-helper.ts","src/remux/passthrough-remuxer.ts","src/demux/transmuxer.ts","node_modules/eventemitter3/index.js","src/demux/transmuxer-worker.ts"],"sourcesContent":["import {\r\n  ManifestLoadedData,\r\n  ManifestLoadingData,\r\n  MediaAttachedData,\r\n  MediaAttachingData,\r\n  LevelLoadingData,\r\n  LevelLoadedData,\r\n  ManifestParsedData,\r\n  LevelUpdatedData,\r\n  LevelsUpdatedData,\r\n  FragParsingUserdataData,\r\n  FragDecryptedData,\r\n  FragLoadedData,\r\n  InitPTSFoundData,\r\n  CuesParsedData,\r\n  SubtitleFragProcessedData,\r\n  NonNativeTextTracksData,\r\n  FragLoadingData,\r\n  AudioTrackLoadedData,\r\n  SubtitleTrackLoadedData,\r\n  ErrorData,\r\n  AudioTrackSwitchingData,\r\n  AudioTrackSwitchedData,\r\n  KeyLoadedData,\r\n  KeyLoadingData,\r\n  SubtitleTrackSwitchData,\r\n  SubtitleTracksUpdatedData,\r\n  LevelSwitchedData,\r\n  FragChangedData,\r\n  BufferAppendingData,\r\n  BufferCodecsData,\r\n  FragParsingMetadataData,\r\n  FragParsingInitSegmentData,\r\n  FragBufferedData,\r\n  BufferFlushingData,\r\n  BufferEOSData,\r\n  LevelSwitchingData,\r\n  MaxAutoLevelUpdatedData,\r\n  FPSDropLevelCappingData,\r\n  FPSDropData,\r\n  BufferCreatedData,\r\n  BufferAppendedData,\r\n  LevelPTSUpdatedData,\r\n  FragParsedData,\r\n  AudioTracksUpdatedData,\r\n  FragLoadEmergencyAbortedData,\r\n  BackBufferData,\r\n  LiveBackBufferData,\r\n  TrackLoadingData,\r\n  BufferFlushedData,\r\n  SteeringManifestLoadedData,\r\n} from './types/events';\r\n\r\nexport enum Events {\r\n  // Fired before MediaSource is attaching to media element\r\n  MEDIA_ATTACHING = 'hlsMediaAttaching',\r\n  // Fired when MediaSource has been successfully attached to media element\r\n  MEDIA_ATTACHED = 'hlsMediaAttached',\r\n  // Fired before detaching MediaSource from media element\r\n  MEDIA_DETACHING = 'hlsMediaDetaching',\r\n  // Fired when MediaSource has been detached from media element\r\n  MEDIA_DETACHED = 'hlsMediaDetached',\r\n  // Fired when the buffer is going to be reset\r\n  BUFFER_RESET = 'hlsBufferReset',\r\n  // Fired when we know about the codecs that we need buffers for to push into - data: {tracks : { container, codec, levelCodec, initSegment, metadata }}\r\n  BUFFER_CODECS = 'hlsBufferCodecs',\r\n  // fired when sourcebuffers have been created - data: { tracks : tracks }\r\n  BUFFER_CREATED = 'hlsBufferCreated',\r\n  // fired when we append a segment to the buffer - data: { segment: segment object }\r\n  BUFFER_APPENDING = 'hlsBufferAppending',\r\n  // fired when we are done with appending a media segment to the buffer - data : { parent : segment parent that triggered BUFFER_APPENDING, pending : nb of segments waiting for appending for this segment parent}\r\n  BUFFER_APPENDED = 'hlsBufferAppended',\r\n  // fired when the stream is finished and we want to notify the media buffer that there will be no more data - data: { }\r\n  BUFFER_EOS = 'hlsBufferEos',\r\n  // fired when the media buffer should be flushed - data { startOffset, endOffset }\r\n  BUFFER_FLUSHING = 'hlsBufferFlushing',\r\n  // fired when the media buffer has been flushed - data: { }\r\n  BUFFER_FLUSHED = 'hlsBufferFlushed',\r\n  // fired to signal that a manifest loading starts - data: { url : manifestURL}\r\n  MANIFEST_LOADING = 'hlsManifestLoading',\r\n  // fired after manifest has been loaded - data: { levels : [available quality levels], audioTracks : [ available audio tracks ], url : manifestURL, stats : LoaderStats }\r\n  MANIFEST_LOADED = 'hlsManifestLoaded',\r\n  // fired after manifest has been parsed - data: { levels : [available quality levels], firstLevel : index of first quality level appearing in Manifest}\r\n  MANIFEST_PARSED = 'hlsManifestParsed',\r\n  // fired when a level switch is requested - data: { level : id of new level }\r\n  LEVEL_SWITCHING = 'hlsLevelSwitching',\r\n  // fired when a level switch is effective - data: { level : id of new level }\r\n  LEVEL_SWITCHED = 'hlsLevelSwitched',\r\n  // fired when a level playlist loading starts - data: { url : level URL, level : id of level being loaded}\r\n  LEVEL_LOADING = 'hlsLevelLoading',\r\n  // fired when a level playlist loading finishes - data: { details : levelDetails object, level : id of loaded level, stats : LoaderStats }\r\n  LEVEL_LOADED = 'hlsLevelLoaded',\r\n  // fired when a level's details have been updated based on previous details, after it has been loaded - data: { details : levelDetails object, level : id of updated level }\r\n  LEVEL_UPDATED = 'hlsLevelUpdated',\r\n  // fired when a level's PTS information has been updated after parsing a fragment - data: { details : levelDetails object, level : id of updated level, drift: PTS drift observed when parsing last fragment }\r\n  LEVEL_PTS_UPDATED = 'hlsLevelPtsUpdated',\r\n  // fired to notify that levels have changed after removing a level - data: { levels : [available quality levels] }\r\n  LEVELS_UPDATED = 'hlsLevelsUpdated',\r\n  // fired to notify that audio track lists has been updated - data: { audioTracks : audioTracks }\r\n  AUDIO_TRACKS_UPDATED = 'hlsAudioTracksUpdated',\r\n  // fired when an audio track switching is requested - data: { id : audio track id }\r\n  AUDIO_TRACK_SWITCHING = 'hlsAudioTrackSwitching',\r\n  // fired when an audio track switch actually occurs - data: { id : audio track id }\r\n  AUDIO_TRACK_SWITCHED = 'hlsAudioTrackSwitched',\r\n  // fired when an audio track loading starts - data: { url : audio track URL, id : audio track id }\r\n  AUDIO_TRACK_LOADING = 'hlsAudioTrackLoading',\r\n  // fired when an audio track loading finishes - data: { details : levelDetails object, id : audio track id, stats : LoaderStats }\r\n  AUDIO_TRACK_LOADED = 'hlsAudioTrackLoaded',\r\n  // fired to notify that subtitle track lists has been updated - data: { subtitleTracks : subtitleTracks }\r\n  SUBTITLE_TRACKS_UPDATED = 'hlsSubtitleTracksUpdated',\r\n  // fired to notify that subtitle tracks were cleared as a result of stopping the media\r\n  SUBTITLE_TRACKS_CLEARED = 'hlsSubtitleTracksCleared',\r\n  // fired when an subtitle track switch occurs - data: { id : subtitle track id }\r\n  SUBTITLE_TRACK_SWITCH = 'hlsSubtitleTrackSwitch',\r\n  // fired when a subtitle track loading starts - data: { url : subtitle track URL, id : subtitle track id }\r\n  SUBTITLE_TRACK_LOADING = 'hlsSubtitleTrackLoading',\r\n  // fired when a subtitle track loading finishes - data: { details : levelDetails object, id : subtitle track id, stats : LoaderStats }\r\n  SUBTITLE_TRACK_LOADED = 'hlsSubtitleTrackLoaded',\r\n  // fired when a subtitle fragment has been processed - data: { success : boolean, frag : the processed frag }\r\n  SUBTITLE_FRAG_PROCESSED = 'hlsSubtitleFragProcessed',\r\n  // fired when a set of VTTCues to be managed externally has been parsed - data: { type: string, track: string, cues: [ VTTCue ] }\r\n  CUES_PARSED = 'hlsCuesParsed',\r\n  // fired when a text track to be managed externally is found - data: { tracks: [ { label: string, kind: string, default: boolean } ] }\r\n  NON_NATIVE_TEXT_TRACKS_FOUND = 'hlsNonNativeTextTracksFound',\r\n  // fired when the first timestamp is found - data: { id : demuxer id, initPTS: initPTS, timescale: timescale, frag : fragment object }\r\n  INIT_PTS_FOUND = 'hlsInitPtsFound',\r\n  // fired when a fragment loading starts - data: { frag : fragment object }\r\n  FRAG_LOADING = 'hlsFragLoading',\r\n  // fired when a fragment loading is progressing - data: { frag : fragment object, { trequest, tfirst, loaded } }\r\n  // FRAG_LOAD_PROGRESS = 'hlsFragLoadProgress',\r\n  // Identifier for fragment load aborting for emergency switch down - data: { frag : fragment object }\r\n  FRAG_LOAD_EMERGENCY_ABORTED = 'hlsFragLoadEmergencyAborted',\r\n  // fired when a fragment loading is completed - data: { frag : fragment object, payload : fragment payload, stats : LoaderStats }\r\n  FRAG_LOADED = 'hlsFragLoaded',\r\n  // fired when a fragment has finished decrypting - data: { id : demuxer id, frag: fragment object, payload : fragment payload, stats : { tstart, tdecrypt } }\r\n  FRAG_DECRYPTED = 'hlsFragDecrypted',\r\n  // fired when Init Segment has been extracted from fragment - data: { id : demuxer id, frag: fragment object, moov : moov MP4 box, codecs : codecs found while parsing fragment }\r\n  FRAG_PARSING_INIT_SEGMENT = 'hlsFragParsingInitSegment',\r\n  // fired when parsing sei text is completed - data: { id : demuxer id, frag: fragment object, samples : [ sei samples pes ] }\r\n  FRAG_PARSING_USERDATA = 'hlsFragParsingUserdata',\r\n  // fired when parsing id3 is completed - data: { id : demuxer id, frag: fragment object, samples : [ id3 samples pes ] }\r\n  FRAG_PARSING_METADATA = 'hlsFragParsingMetadata',\r\n  // fired when data have been extracted from fragment - data: { id : demuxer id, frag: fragment object, data1 : moof MP4 box or TS fragments, data2 : mdat MP4 box or null}\r\n  // FRAG_PARSING_DATA = 'hlsFragParsingData',\r\n  // fired when fragment parsing is completed - data: { id : demuxer id, frag: fragment object }\r\n  FRAG_PARSED = 'hlsFragParsed',\r\n  // fired when fragment remuxed MP4 boxes have all been appended into SourceBuffer - data: { id : demuxer id, frag : fragment object, stats : LoaderStats }\r\n  FRAG_BUFFERED = 'hlsFragBuffered',\r\n  // fired when fragment matching with current media position is changing - data : { id : demuxer id, frag : fragment object }\r\n  FRAG_CHANGED = 'hlsFragChanged',\r\n  // Identifier for a FPS drop event - data: { currentDropped, currentDecoded, totalDroppedFrames }\r\n  FPS_DROP = 'hlsFpsDrop',\r\n  // triggered when FPS drop triggers auto level capping - data: { level, droppedLevel }\r\n  FPS_DROP_LEVEL_CAPPING = 'hlsFpsDropLevelCapping',\r\n  // triggered when maxAutoLevel changes - data { autoLevelCapping, levels, maxAutoLevel, minAutoLevel, maxHdcpLevel }\r\n  MAX_AUTO_LEVEL_UPDATED = 'hlsMaxAutoLevelUpdated',\r\n  // Identifier for an error event - data: { type : error type, details : error details, fatal : if true, hls.js cannot/will not try to recover, if false, hls.js will try to recover,other error specific data }\r\n  ERROR = 'hlsError',\r\n  // fired when hls.js instance starts destroying. Different from MEDIA_DETACHED as one could want to detach and reattach a media to the instance of hls.js to handle mid-rolls for example - data: { }\r\n  DESTROYING = 'hlsDestroying',\r\n  // fired when a decrypt key loading starts - data: { frag : fragment object }\r\n  KEY_LOADING = 'hlsKeyLoading',\r\n  // fired when a decrypt key loading is completed - data: { frag : fragment object, keyInfo : KeyLoaderInfo }\r\n  KEY_LOADED = 'hlsKeyLoaded',\r\n  // deprecated; please use BACK_BUFFER_REACHED - data : { bufferEnd: number }\r\n  LIVE_BACK_BUFFER_REACHED = 'hlsLiveBackBufferReached',\r\n  // fired when the back buffer is reached as defined by the backBufferLength config option - data : { bufferEnd: number }\r\n  BACK_BUFFER_REACHED = 'hlsBackBufferReached',\r\n  // fired after steering manifest has been loaded - data: { steeringManifest: SteeringManifest object, url: steering manifest URL }\r\n  STEERING_MANIFEST_LOADED = 'hlsSteeringManifestLoaded',\r\n}\r\n\r\n/**\r\n * Defines each Event type and payload by Event name. Used in {@link hls.js#HlsEventEmitter} to strongly type the event listener API.\r\n */\r\nexport interface HlsListeners {\r\n  [Events.MEDIA_ATTACHING]: (\r\n    event: Events.MEDIA_ATTACHING,\r\n    data: MediaAttachingData,\r\n  ) => void;\r\n  [Events.MEDIA_ATTACHED]: (\r\n    event: Events.MEDIA_ATTACHED,\r\n    data: MediaAttachedData,\r\n  ) => void;\r\n  [Events.MEDIA_DETACHING]: (event: Events.MEDIA_DETACHING) => void;\r\n  [Events.MEDIA_DETACHED]: (event: Events.MEDIA_DETACHED) => void;\r\n  [Events.BUFFER_RESET]: (event: Events.BUFFER_RESET) => void;\r\n  [Events.BUFFER_CODECS]: (\r\n    event: Events.BUFFER_CODECS,\r\n    data: BufferCodecsData,\r\n  ) => void;\r\n  [Events.BUFFER_CREATED]: (\r\n    event: Events.BUFFER_CREATED,\r\n    data: BufferCreatedData,\r\n  ) => void;\r\n  [Events.BUFFER_APPENDING]: (\r\n    event: Events.BUFFER_APPENDING,\r\n    data: BufferAppendingData,\r\n  ) => void;\r\n  [Events.BUFFER_APPENDED]: (\r\n    event: Events.BUFFER_APPENDED,\r\n    data: BufferAppendedData,\r\n  ) => void;\r\n  [Events.BUFFER_EOS]: (event: Events.BUFFER_EOS, data: BufferEOSData) => void;\r\n  [Events.BUFFER_FLUSHING]: (\r\n    event: Events.BUFFER_FLUSHING,\r\n    data: BufferFlushingData,\r\n  ) => void;\r\n  [Events.BUFFER_FLUSHED]: (\r\n    event: Events.BUFFER_FLUSHED,\r\n    data: BufferFlushedData,\r\n  ) => void;\r\n  [Events.MANIFEST_LOADING]: (\r\n    event: Events.MANIFEST_LOADING,\r\n    data: ManifestLoadingData,\r\n  ) => void;\r\n  [Events.MANIFEST_LOADED]: (\r\n    event: Events.MANIFEST_LOADED,\r\n    data: ManifestLoadedData,\r\n  ) => void;\r\n  [Events.MANIFEST_PARSED]: (\r\n    event: Events.MANIFEST_PARSED,\r\n    data: ManifestParsedData,\r\n  ) => void;\r\n  [Events.LEVEL_SWITCHING]: (\r\n    event: Events.LEVEL_SWITCHING,\r\n    data: LevelSwitchingData,\r\n  ) => void;\r\n  [Events.LEVEL_SWITCHED]: (\r\n    event: Events.LEVEL_SWITCHED,\r\n    data: LevelSwitchedData,\r\n  ) => void;\r\n  [Events.LEVEL_LOADING]: (\r\n    event: Events.LEVEL_LOADING,\r\n    data: LevelLoadingData,\r\n  ) => void;\r\n  [Events.LEVEL_LOADED]: (\r\n    event: Events.LEVEL_LOADED,\r\n    data: LevelLoadedData,\r\n  ) => void;\r\n  [Events.LEVEL_UPDATED]: (\r\n    event: Events.LEVEL_UPDATED,\r\n    data: LevelUpdatedData,\r\n  ) => void;\r\n  [Events.LEVEL_PTS_UPDATED]: (\r\n    event: Events.LEVEL_PTS_UPDATED,\r\n    data: LevelPTSUpdatedData,\r\n  ) => void;\r\n  [Events.LEVELS_UPDATED]: (\r\n    event: Events.LEVELS_UPDATED,\r\n    data: LevelsUpdatedData,\r\n  ) => void;\r\n  [Events.AUDIO_TRACKS_UPDATED]: (\r\n    event: Events.AUDIO_TRACKS_UPDATED,\r\n    data: AudioTracksUpdatedData,\r\n  ) => void;\r\n  [Events.AUDIO_TRACK_SWITCHING]: (\r\n    event: Events.AUDIO_TRACK_SWITCHING,\r\n    data: AudioTrackSwitchingData,\r\n  ) => void;\r\n  [Events.AUDIO_TRACK_SWITCHED]: (\r\n    event: Events.AUDIO_TRACK_SWITCHED,\r\n    data: AudioTrackSwitchedData,\r\n  ) => void;\r\n  [Events.AUDIO_TRACK_LOADING]: (\r\n    event: Events.AUDIO_TRACK_LOADING,\r\n    data: TrackLoadingData,\r\n  ) => void;\r\n  [Events.AUDIO_TRACK_LOADED]: (\r\n    event: Events.AUDIO_TRACK_LOADED,\r\n    data: AudioTrackLoadedData,\r\n  ) => void;\r\n  [Events.SUBTITLE_TRACKS_UPDATED]: (\r\n    event: Events.SUBTITLE_TRACKS_UPDATED,\r\n    data: SubtitleTracksUpdatedData,\r\n  ) => void;\r\n  [Events.SUBTITLE_TRACKS_CLEARED]: (\r\n    event: Events.SUBTITLE_TRACKS_CLEARED,\r\n  ) => void;\r\n  [Events.SUBTITLE_TRACK_SWITCH]: (\r\n    event: Events.SUBTITLE_TRACK_SWITCH,\r\n    data: SubtitleTrackSwitchData,\r\n  ) => void;\r\n  [Events.SUBTITLE_TRACK_LOADING]: (\r\n    event: Events.SUBTITLE_TRACK_LOADING,\r\n    data: TrackLoadingData,\r\n  ) => void;\r\n  [Events.SUBTITLE_TRACK_LOADED]: (\r\n    event: Events.SUBTITLE_TRACK_LOADED,\r\n    data: SubtitleTrackLoadedData,\r\n  ) => void;\r\n  [Events.SUBTITLE_FRAG_PROCESSED]: (\r\n    event: Events.SUBTITLE_FRAG_PROCESSED,\r\n    data: SubtitleFragProcessedData,\r\n  ) => void;\r\n  [Events.CUES_PARSED]: (\r\n    event: Events.CUES_PARSED,\r\n    data: CuesParsedData,\r\n  ) => void;\r\n  [Events.NON_NATIVE_TEXT_TRACKS_FOUND]: (\r\n    event: Events.NON_NATIVE_TEXT_TRACKS_FOUND,\r\n    data: NonNativeTextTracksData,\r\n  ) => void;\r\n  [Events.INIT_PTS_FOUND]: (\r\n    event: Events.INIT_PTS_FOUND,\r\n    data: InitPTSFoundData,\r\n  ) => void;\r\n  [Events.FRAG_LOADING]: (\r\n    event: Events.FRAG_LOADING,\r\n    data: FragLoadingData,\r\n  ) => void;\r\n  // [Events.FRAG_LOAD_PROGRESS]: TodoEventType\r\n  [Events.FRAG_LOAD_EMERGENCY_ABORTED]: (\r\n    event: Events.FRAG_LOAD_EMERGENCY_ABORTED,\r\n    data: FragLoadEmergencyAbortedData,\r\n  ) => void;\r\n  [Events.FRAG_LOADED]: (\r\n    event: Events.FRAG_LOADED,\r\n    data: FragLoadedData,\r\n  ) => void;\r\n  [Events.FRAG_DECRYPTED]: (\r\n    event: Events.FRAG_DECRYPTED,\r\n    data: FragDecryptedData,\r\n  ) => void;\r\n  [Events.FRAG_PARSING_INIT_SEGMENT]: (\r\n    event: Events.FRAG_PARSING_INIT_SEGMENT,\r\n    data: FragParsingInitSegmentData,\r\n  ) => void;\r\n  [Events.FRAG_PARSING_USERDATA]: (\r\n    event: Events.FRAG_PARSING_USERDATA,\r\n    data: FragParsingUserdataData,\r\n  ) => void;\r\n  [Events.FRAG_PARSING_METADATA]: (\r\n    event: Events.FRAG_PARSING_METADATA,\r\n    data: FragParsingMetadataData,\r\n  ) => void;\r\n  // [Events.FRAG_PARSING_DATA]: TodoEventType\r\n  [Events.FRAG_PARSED]: (\r\n    event: Events.FRAG_PARSED,\r\n    data: FragParsedData,\r\n  ) => void;\r\n  [Events.FRAG_BUFFERED]: (\r\n    event: Events.FRAG_BUFFERED,\r\n    data: FragBufferedData,\r\n  ) => void;\r\n  [Events.FRAG_CHANGED]: (\r\n    event: Events.FRAG_CHANGED,\r\n    data: FragChangedData,\r\n  ) => void;\r\n  [Events.FPS_DROP]: (event: Events.FPS_DROP, data: FPSDropData) => void;\r\n  [Events.FPS_DROP_LEVEL_CAPPING]: (\r\n    event: Events.FPS_DROP_LEVEL_CAPPING,\r\n    data: FPSDropLevelCappingData,\r\n  ) => void;\r\n  [Events.MAX_AUTO_LEVEL_UPDATED]: (\r\n    event: Events.MAX_AUTO_LEVEL_UPDATED,\r\n    data: MaxAutoLevelUpdatedData,\r\n  ) => void;\r\n  [Events.ERROR]: (event: Events.ERROR, data: ErrorData) => void;\r\n  [Events.DESTROYING]: (event: Events.DESTROYING) => void;\r\n  [Events.KEY_LOADING]: (\r\n    event: Events.KEY_LOADING,\r\n    data: KeyLoadingData,\r\n  ) => void;\r\n  [Events.KEY_LOADED]: (event: Events.KEY_LOADED, data: KeyLoadedData) => void;\r\n  [Events.LIVE_BACK_BUFFER_REACHED]: (\r\n    event: Events.LIVE_BACK_BUFFER_REACHED,\r\n    data: LiveBackBufferData,\r\n  ) => void;\r\n  [Events.BACK_BUFFER_REACHED]: (\r\n    event: Events.BACK_BUFFER_REACHED,\r\n    data: BackBufferData,\r\n  ) => void;\r\n  [Events.STEERING_MANIFEST_LOADED]: (\r\n    event: Events.STEERING_MANIFEST_LOADED,\r\n    data: SteeringManifestLoadedData,\r\n  ) => void;\r\n}\r\nexport interface HlsEventEmitter {\r\n  on<E extends keyof HlsListeners, Context = undefined>(\r\n    event: E,\r\n    listener: HlsListeners[E],\r\n    context?: Context,\r\n  ): void;\r\n  once<E extends keyof HlsListeners, Context = undefined>(\r\n    event: E,\r\n    listener: HlsListeners[E],\r\n    context?: Context,\r\n  ): void;\r\n\r\n  removeAllListeners<E extends keyof HlsListeners>(event?: E): void;\r\n  off<E extends keyof HlsListeners, Context = undefined>(\r\n    event: E,\r\n    listener?: HlsListeners[E],\r\n    context?: Context,\r\n    once?: boolean,\r\n  ): void;\r\n\r\n  listeners<E extends keyof HlsListeners>(event: E): HlsListeners[E][];\r\n  emit<E extends keyof HlsListeners>(\r\n    event: E,\r\n    name: E,\r\n    eventObject: Parameters<HlsListeners[E]>[1],\r\n  ): boolean;\r\n  listenerCount<E extends keyof HlsListeners>(event: E): number;\r\n}\r\n","export enum ErrorTypes {\r\n  // Identifier for a network error (loading error / timeout ...)\r\n  NETWORK_ERROR = 'networkError',\r\n  // Identifier for a media Error (video/parsing/mediasource error)\r\n  MEDIA_ERROR = 'mediaError',\r\n  // EME (encrypted media extensions) errors\r\n  KEY_SYSTEM_ERROR = 'keySystemError',\r\n  // Identifier for a mux Error (demuxing/remuxing)\r\n  MUX_ERROR = 'muxError',\r\n  // Identifier for all other errors\r\n  OTHER_ERROR = 'otherError',\r\n}\r\n\r\nexport enum ErrorDetails {\r\n  KEY_SYSTEM_NO_KEYS = 'keySystemNoKeys',\r\n  KEY_SYSTEM_NO_ACCESS = 'keySystemNoAccess',\r\n  KEY_SYSTEM_NO_SESSION = 'keySystemNoSession',\r\n  KEY_SYSTEM_NO_CONFIGURED_LICENSE = 'keySystemNoConfiguredLicense',\r\n  KEY_SYSTEM_LICENSE_REQUEST_FAILED = 'keySystemLicenseRequestFailed',\r\n  KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED = 'keySystemServerCertificateRequestFailed',\r\n  KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED = 'keySystemServerCertificateUpdateFailed',\r\n  KEY_SYSTEM_SESSION_UPDATE_FAILED = 'keySystemSessionUpdateFailed',\r\n  KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED = 'keySystemStatusOutputRestricted',\r\n  KEY_SYSTEM_STATUS_INTERNAL_ERROR = 'keySystemStatusInternalError',\r\n  // Identifier for a manifest load error - data: { url : faulty URL, response : { code: error code, text: error text }}\r\n  MANIFEST_LOAD_ERROR = 'manifestLoadError',\r\n  // Identifier for a manifest load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}\r\n  MANIFEST_LOAD_TIMEOUT = 'manifestLoadTimeOut',\r\n  // Identifier for a manifest parsing error - data: { url : faulty URL, reason : error reason}\r\n  MANIFEST_PARSING_ERROR = 'manifestParsingError',\r\n  // Identifier for a manifest with only incompatible codecs error - data: { url : faulty URL, reason : error reason}\r\n  MANIFEST_INCOMPATIBLE_CODECS_ERROR = 'manifestIncompatibleCodecsError',\r\n  // Identifier for a level which contains no fragments - data: { url: faulty URL, reason: \"no fragments found in level\", level: index of the bad level }\r\n  LEVEL_EMPTY_ERROR = 'levelEmptyError',\r\n  // Identifier for a level load error - data: { url : faulty URL, response : { code: error code, text: error text }}\r\n  LEVEL_LOAD_ERROR = 'levelLoadError',\r\n  // Identifier for a level load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}\r\n  LEVEL_LOAD_TIMEOUT = 'levelLoadTimeOut',\r\n  // Identifier for a level parse error - data: { url : faulty URL, error: Error, reason: error message }\r\n  LEVEL_PARSING_ERROR = 'levelParsingError',\r\n  // Identifier for a level switch error - data: { level : faulty level Id, event : error description}\r\n  LEVEL_SWITCH_ERROR = 'levelSwitchError',\r\n  // Identifier for an audio track load error - data: { url : faulty URL, response : { code: error code, text: error text }}\r\n  AUDIO_TRACK_LOAD_ERROR = 'audioTrackLoadError',\r\n  // Identifier for an audio track load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}\r\n  AUDIO_TRACK_LOAD_TIMEOUT = 'audioTrackLoadTimeOut',\r\n  // Identifier for a subtitle track load error - data: { url : faulty URL, response : { code: error code, text: error text }}\r\n  SUBTITLE_LOAD_ERROR = 'subtitleTrackLoadError',\r\n  // Identifier for a subtitle track load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}\r\n  SUBTITLE_TRACK_LOAD_TIMEOUT = 'subtitleTrackLoadTimeOut',\r\n  // Identifier for fragment load error - data: { frag : fragment object, response : { code: error code, text: error text }}\r\n  FRAG_LOAD_ERROR = 'fragLoadError',\r\n  // Identifier for fragment load timeout error - data: { frag : fragment object}\r\n  FRAG_LOAD_TIMEOUT = 'fragLoadTimeOut',\r\n  // Identifier for a fragment decryption error event - data: {id : demuxer Id,frag: fragment object, reason : parsing error description }\r\n  FRAG_DECRYPT_ERROR = 'fragDecryptError',\r\n  // Identifier for a fragment parsing error event - data: { id : demuxer Id, reason : parsing error description }\r\n  // will be renamed DEMUX_PARSING_ERROR and switched to MUX_ERROR in the next major release\r\n  FRAG_PARSING_ERROR = 'fragParsingError',\r\n  // Identifier for a fragment or part load skipped because of a GAP tag or attribute\r\n  FRAG_GAP = 'fragGap',\r\n  // Identifier for a remux alloc error event - data: { id : demuxer Id, frag : fragment object, bytes : nb of bytes on which allocation failed , reason : error text }\r\n  REMUX_ALLOC_ERROR = 'remuxAllocError',\r\n  // Identifier for decrypt key load error - data: { frag : fragment object, response : { code: error code, text: error text }}\r\n  KEY_LOAD_ERROR = 'keyLoadError',\r\n  // Identifier for decrypt key load timeout error - data: { frag : fragment object}\r\n  KEY_LOAD_TIMEOUT = 'keyLoadTimeOut',\r\n  // Triggered when an exception occurs while adding a sourceBuffer to MediaSource - data : { error : exception , mimeType : mimeType }\r\n  BUFFER_ADD_CODEC_ERROR = 'bufferAddCodecError',\r\n  // Triggered when source buffer(s) could not be created using level (manifest CODECS attribute), parsed media, or best guess codec(s) - data: { reason : error reason }\r\n  BUFFER_INCOMPATIBLE_CODECS_ERROR = 'bufferIncompatibleCodecsError',\r\n  // Identifier for a buffer append error - data: append error description\r\n  BUFFER_APPEND_ERROR = 'bufferAppendError',\r\n  // Identifier for a buffer appending error event - data: appending error description\r\n  BUFFER_APPENDING_ERROR = 'bufferAppendingError',\r\n  // Identifier for a buffer stalled error event\r\n  BUFFER_STALLED_ERROR = 'bufferStalledError',\r\n  // Identifier for a buffer full event\r\n  BUFFER_FULL_ERROR = 'bufferFullError',\r\n  // Identifier for a buffer seek over hole event\r\n  BUFFER_SEEK_OVER_HOLE = 'bufferSeekOverHole',\r\n  // Identifier for a buffer nudge on stall (playback is stuck although currentTime is in a buffered area)\r\n  BUFFER_NUDGE_ON_STALL = 'bufferNudgeOnStall',\r\n  // Identifier for an internal exception happening inside hls.js while handling an event\r\n  INTERNAL_EXCEPTION = 'internalException',\r\n  // Identifier for an internal call to abort a loader\r\n  INTERNAL_ABORTED = 'aborted',\r\n  // Uncategorized error\r\n  UNKNOWN = 'unknown',\r\n}\r\n","export default class AESCrypto {\r\n  private subtle: SubtleCrypto;\r\n  private aesIV: Uint8Array;\r\n\r\n  constructor(subtle: SubtleCrypto, iv: Uint8Array) {\r\n    this.subtle = subtle;\r\n    this.aesIV = iv;\r\n  }\r\n\r\n  decrypt(data: ArrayBuffer, key: CryptoKey) {\r\n    return this.subtle.decrypt({ name: 'AES-CBC', iv: this.aesIV }, key, data);\r\n  }\r\n}\r\n","export default class FastAESKey {\r\n  private subtle: any;\r\n  private key: ArrayBuffer;\r\n\r\n  constructor(subtle, key) {\r\n    this.subtle = subtle;\r\n    this.key = key;\r\n  }\r\n\r\n  expandKey() {\r\n    return this.subtle.importKey('raw', this.key, { name: 'AES-CBC' }, false, [\r\n      'encrypt',\r\n      'decrypt',\r\n    ]);\r\n  }\r\n}\r\n","export function sliceUint8(\r\n  array: Uint8Array,\r\n  start?: number,\r\n  end?: number,\r\n): Uint8Array {\r\n  // @ts-expect-error This polyfills IE11 usage of Uint8Array slice.\r\n  // It always exists in the TypeScript definition so fails, but it fails at runtime on IE11.\r\n  return Uint8Array.prototype.slice\r\n    ? array.slice(start, end)\r\n    : new Uint8Array(Array.prototype.slice.call(array, start, end));\r\n}\r\n","import { sliceUint8 } from '../utils/typed-array';\r\n\r\n// PKCS7\r\nexport function removePadding(array: Uint8Array): Uint8Array {\r\n  const outputBytes = array.byteLength;\r\n  const paddingBytes =\r\n    outputBytes && new DataView(array.buffer).getUint8(outputBytes - 1);\r\n  if (paddingBytes) {\r\n    return sliceUint8(array, 0, outputBytes - paddingBytes);\r\n  }\r\n  return array;\r\n}\r\n\r\nexport default class AESDecryptor {\r\n  private rcon: Array<number> = [\r\n    0x0, 0x1, 0x2, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36,\r\n  ];\r\n  private subMix: Array<Uint32Array> = [\r\n    new Uint32Array(256),\r\n    new Uint32Array(256),\r\n    new Uint32Array(256),\r\n    new Uint32Array(256),\r\n  ];\r\n  private invSubMix: Array<Uint32Array> = [\r\n    new Uint32Array(256),\r\n    new Uint32Array(256),\r\n    new Uint32Array(256),\r\n    new Uint32Array(256),\r\n  ];\r\n  private sBox: Uint32Array = new Uint32Array(256);\r\n  private invSBox: Uint32Array = new Uint32Array(256);\r\n  private key: Uint32Array = new Uint32Array(0);\r\n\r\n  private ksRows: number = 0;\r\n  private keySize: number = 0;\r\n  private keySchedule!: Uint32Array;\r\n  private invKeySchedule!: Uint32Array;\r\n\r\n  constructor() {\r\n    this.initTable();\r\n  }\r\n\r\n  // Using view.getUint32() also swaps the byte order.\r\n  uint8ArrayToUint32Array_(arrayBuffer) {\r\n    const view = new DataView(arrayBuffer);\r\n    const newArray = new Uint32Array(4);\r\n    for (let i = 0; i < 4; i++) {\r\n      newArray[i] = view.getUint32(i * 4);\r\n    }\r\n\r\n    return newArray;\r\n  }\r\n\r\n  initTable() {\r\n    const sBox = this.sBox;\r\n    const invSBox = this.invSBox;\r\n    const subMix = this.subMix;\r\n    const subMix0 = subMix[0];\r\n    const subMix1 = subMix[1];\r\n    const subMix2 = subMix[2];\r\n    const subMix3 = subMix[3];\r\n    const invSubMix = this.invSubMix;\r\n    const invSubMix0 = invSubMix[0];\r\n    const invSubMix1 = invSubMix[1];\r\n    const invSubMix2 = invSubMix[2];\r\n    const invSubMix3 = invSubMix[3];\r\n\r\n    const d = new Uint32Array(256);\r\n    let x = 0;\r\n    let xi = 0;\r\n    let i = 0;\r\n    for (i = 0; i < 256; i++) {\r\n      if (i < 128) {\r\n        d[i] = i << 1;\r\n      } else {\r\n        d[i] = (i << 1) ^ 0x11b;\r\n      }\r\n    }\r\n\r\n    for (i = 0; i < 256; i++) {\r\n      let sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4);\r\n      sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63;\r\n      sBox[x] = sx;\r\n      invSBox[sx] = x;\r\n\r\n      // Compute multiplication\r\n      const x2 = d[x];\r\n      const x4 = d[x2];\r\n      const x8 = d[x4];\r\n\r\n      // Compute sub/invSub bytes, mix columns tables\r\n      let t = (d[sx] * 0x101) ^ (sx * 0x1010100);\r\n      subMix0[x] = (t << 24) | (t >>> 8);\r\n      subMix1[x] = (t << 16) | (t >>> 16);\r\n      subMix2[x] = (t << 8) | (t >>> 24);\r\n      subMix3[x] = t;\r\n\r\n      // Compute inv sub bytes, inv mix columns tables\r\n      t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100);\r\n      invSubMix0[sx] = (t << 24) | (t >>> 8);\r\n      invSubMix1[sx] = (t << 16) | (t >>> 16);\r\n      invSubMix2[sx] = (t << 8) | (t >>> 24);\r\n      invSubMix3[sx] = t;\r\n\r\n      // Compute next counter\r\n      if (!x) {\r\n        x = xi = 1;\r\n      } else {\r\n        x = x2 ^ d[d[d[x8 ^ x2]]];\r\n        xi ^= d[d[xi]];\r\n      }\r\n    }\r\n  }\r\n\r\n  expandKey(keyBuffer: ArrayBuffer) {\r\n    // convert keyBuffer to Uint32Array\r\n    const key = this.uint8ArrayToUint32Array_(keyBuffer);\r\n    let sameKey = true;\r\n    let offset = 0;\r\n\r\n    while (offset < key.length && sameKey) {\r\n      sameKey = key[offset] === this.key[offset];\r\n      offset++;\r\n    }\r\n\r\n    if (sameKey) {\r\n      return;\r\n    }\r\n\r\n    this.key = key;\r\n    const keySize = (this.keySize = key.length);\r\n\r\n    if (keySize !== 4 && keySize !== 6 && keySize !== 8) {\r\n      throw new Error('Invalid aes key size=' + keySize);\r\n    }\r\n\r\n    const ksRows = (this.ksRows = (keySize + 6 + 1) * 4);\r\n    let ksRow;\r\n    let invKsRow;\r\n\r\n    const keySchedule = (this.keySchedule = new Uint32Array(ksRows));\r\n    const invKeySchedule = (this.invKeySchedule = new Uint32Array(ksRows));\r\n    const sbox = this.sBox;\r\n    const rcon = this.rcon;\r\n\r\n    const invSubMix = this.invSubMix;\r\n    const invSubMix0 = invSubMix[0];\r\n    const invSubMix1 = invSubMix[1];\r\n    const invSubMix2 = invSubMix[2];\r\n    const invSubMix3 = invSubMix[3];\r\n\r\n    let prev;\r\n    let t;\r\n\r\n    for (ksRow = 0; ksRow < ksRows; ksRow++) {\r\n      if (ksRow < keySize) {\r\n        prev = keySchedule[ksRow] = key[ksRow];\r\n        continue;\r\n      }\r\n      t = prev;\r\n\r\n      if (ksRow % keySize === 0) {\r\n        // Rot word\r\n        t = (t << 8) | (t >>> 24);\r\n\r\n        // Sub word\r\n        t =\r\n          (sbox[t >>> 24] << 24) |\r\n          (sbox[(t >>> 16) & 0xff] << 16) |\r\n          (sbox[(t >>> 8) & 0xff] << 8) |\r\n          sbox[t & 0xff];\r\n\r\n        // Mix Rcon\r\n        t ^= rcon[(ksRow / keySize) | 0] << 24;\r\n      } else if (keySize > 6 && ksRow % keySize === 4) {\r\n        // Sub word\r\n        t =\r\n          (sbox[t >>> 24] << 24) |\r\n          (sbox[(t >>> 16) & 0xff] << 16) |\r\n          (sbox[(t >>> 8) & 0xff] << 8) |\r\n          sbox[t & 0xff];\r\n      }\r\n\r\n      keySchedule[ksRow] = prev = (keySchedule[ksRow - keySize] ^ t) >>> 0;\r\n    }\r\n\r\n    for (invKsRow = 0; invKsRow < ksRows; invKsRow++) {\r\n      ksRow = ksRows - invKsRow;\r\n      if (invKsRow & 3) {\r\n        t = keySchedule[ksRow];\r\n      } else {\r\n        t = keySchedule[ksRow - 4];\r\n      }\r\n\r\n      if (invKsRow < 4 || ksRow <= 4) {\r\n        invKeySchedule[invKsRow] = t;\r\n      } else {\r\n        invKeySchedule[invKsRow] =\r\n          invSubMix0[sbox[t >>> 24]] ^\r\n          invSubMix1[sbox[(t >>> 16) & 0xff]] ^\r\n          invSubMix2[sbox[(t >>> 8) & 0xff]] ^\r\n          invSubMix3[sbox[t & 0xff]];\r\n      }\r\n\r\n      invKeySchedule[invKsRow] = invKeySchedule[invKsRow] >>> 0;\r\n    }\r\n  }\r\n\r\n  // Adding this as a method greatly improves performance.\r\n  networkToHostOrderSwap(word) {\r\n    return (\r\n      (word << 24) |\r\n      ((word & 0xff00) << 8) |\r\n      ((word & 0xff0000) >> 8) |\r\n      (word >>> 24)\r\n    );\r\n  }\r\n\r\n  decrypt(inputArrayBuffer: ArrayBuffer, offset: number, aesIV: ArrayBuffer) {\r\n    const nRounds = this.keySize + 6;\r\n    const invKeySchedule = this.invKeySchedule;\r\n    const invSBOX = this.invSBox;\r\n\r\n    const invSubMix = this.invSubMix;\r\n    const invSubMix0 = invSubMix[0];\r\n    const invSubMix1 = invSubMix[1];\r\n    const invSubMix2 = invSubMix[2];\r\n    const invSubMix3 = invSubMix[3];\r\n\r\n    const initVector = this.uint8ArrayToUint32Array_(aesIV);\r\n    let initVector0 = initVector[0];\r\n    let initVector1 = initVector[1];\r\n    let initVector2 = initVector[2];\r\n    let initVector3 = initVector[3];\r\n\r\n    const inputInt32 = new Int32Array(inputArrayBuffer);\r\n    const outputInt32 = new Int32Array(inputInt32.length);\r\n\r\n    let t0, t1, t2, t3;\r\n    let s0, s1, s2, s3;\r\n    let inputWords0, inputWords1, inputWords2, inputWords3;\r\n\r\n    let ksRow, i;\r\n    const swapWord = this.networkToHostOrderSwap;\r\n\r\n    while (offset < inputInt32.length) {\r\n      inputWords0 = swapWord(inputInt32[offset]);\r\n      inputWords1 = swapWord(inputInt32[offset + 1]);\r\n      inputWords2 = swapWord(inputInt32[offset + 2]);\r\n      inputWords3 = swapWord(inputInt32[offset + 3]);\r\n\r\n      s0 = inputWords0 ^ invKeySchedule[0];\r\n      s1 = inputWords3 ^ invKeySchedule[1];\r\n      s2 = inputWords2 ^ invKeySchedule[2];\r\n      s3 = inputWords1 ^ invKeySchedule[3];\r\n\r\n      ksRow = 4;\r\n\r\n      // Iterate through the rounds of decryption\r\n      for (i = 1; i < nRounds; i++) {\r\n        t0 =\r\n          invSubMix0[s0 >>> 24] ^\r\n          invSubMix1[(s1 >> 16) & 0xff] ^\r\n          invSubMix2[(s2 >> 8) & 0xff] ^\r\n          invSubMix3[s3 & 0xff] ^\r\n          invKeySchedule[ksRow];\r\n        t1 =\r\n          invSubMix0[s1 >>> 24] ^\r\n          invSubMix1[(s2 >> 16) & 0xff] ^\r\n          invSubMix2[(s3 >> 8) & 0xff] ^\r\n          invSubMix3[s0 & 0xff] ^\r\n          invKeySchedule[ksRow + 1];\r\n        t2 =\r\n          invSubMix0[s2 >>> 24] ^\r\n          invSubMix1[(s3 >> 16) & 0xff] ^\r\n          invSubMix2[(s0 >> 8) & 0xff] ^\r\n          invSubMix3[s1 & 0xff] ^\r\n          invKeySchedule[ksRow + 2];\r\n        t3 =\r\n          invSubMix0[s3 >>> 24] ^\r\n          invSubMix1[(s0 >> 16) & 0xff] ^\r\n          invSubMix2[(s1 >> 8) & 0xff] ^\r\n          invSubMix3[s2 & 0xff] ^\r\n          invKeySchedule[ksRow + 3];\r\n        // Update state\r\n        s0 = t0;\r\n        s1 = t1;\r\n        s2 = t2;\r\n        s3 = t3;\r\n\r\n        ksRow = ksRow + 4;\r\n      }\r\n\r\n      // Shift rows, sub bytes, add round key\r\n      t0 =\r\n        (invSBOX[s0 >>> 24] << 24) ^\r\n        (invSBOX[(s1 >> 16) & 0xff] << 16) ^\r\n        (invSBOX[(s2 >> 8) & 0xff] << 8) ^\r\n        invSBOX[s3 & 0xff] ^\r\n        invKeySchedule[ksRow];\r\n      t1 =\r\n        (invSBOX[s1 >>> 24] << 24) ^\r\n        (invSBOX[(s2 >> 16) & 0xff] << 16) ^\r\n        (invSBOX[(s3 >> 8) & 0xff] << 8) ^\r\n        invSBOX[s0 & 0xff] ^\r\n        invKeySchedule[ksRow + 1];\r\n      t2 =\r\n        (invSBOX[s2 >>> 24] << 24) ^\r\n        (invSBOX[(s3 >> 16) & 0xff] << 16) ^\r\n        (invSBOX[(s0 >> 8) & 0xff] << 8) ^\r\n        invSBOX[s1 & 0xff] ^\r\n        invKeySchedule[ksRow + 2];\r\n      t3 =\r\n        (invSBOX[s3 >>> 24] << 24) ^\r\n        (invSBOX[(s0 >> 16) & 0xff] << 16) ^\r\n        (invSBOX[(s1 >> 8) & 0xff] << 8) ^\r\n        invSBOX[s2 & 0xff] ^\r\n        invKeySchedule[ksRow + 3];\r\n\r\n      // Write\r\n      outputInt32[offset] = swapWord(t0 ^ initVector0);\r\n      outputInt32[offset + 1] = swapWord(t3 ^ initVector1);\r\n      outputInt32[offset + 2] = swapWord(t2 ^ initVector2);\r\n      outputInt32[offset + 3] = swapWord(t1 ^ initVector3);\r\n\r\n      // reset initVector to last 4 unsigned int\r\n      initVector0 = inputWords0;\r\n      initVector1 = inputWords1;\r\n      initVector2 = inputWords2;\r\n      initVector3 = inputWords3;\r\n\r\n      offset = offset + 4;\r\n    }\r\n\r\n    return outputInt32.buffer;\r\n  }\r\n}\r\n","export interface ILogFunction {\r\n  (message?: any, ...optionalParams: any[]): void;\r\n}\r\n\r\nexport interface ILogger {\r\n  trace: ILogFunction;\r\n  debug: ILogFunction;\r\n  log: ILogFunction;\r\n  warn: ILogFunction;\r\n  info: ILogFunction;\r\n  error: ILogFunction;\r\n}\r\n\r\nconst noop: ILogFunction = function () {};\r\n\r\nconst fakeLogger: ILogger = {\r\n  trace: noop,\r\n  debug: noop,\r\n  log: noop,\r\n  warn: noop,\r\n  info: noop,\r\n  error: noop,\r\n};\r\n\r\nlet exportedLogger: ILogger = fakeLogger;\r\n\r\n// let lastCallTime;\r\n// function formatMsgWithTimeInfo(type, msg) {\r\n//   const now = Date.now();\r\n//   const diff = lastCallTime ? '+' + (now - lastCallTime) : '0';\r\n//   lastCallTime = now;\r\n//   msg = (new Date(now)).toISOString() + ' | [' +  type + '] > ' + msg + ' ( ' + diff + ' ms )';\r\n//   return msg;\r\n// }\r\n\r\nfunction consolePrintFn(type: string): ILogFunction {\r\n  const func: ILogFunction = self.console[type];\r\n  if (func) {\r\n    return func.bind(self.console, `[${type}] >`);\r\n  }\r\n  return noop;\r\n}\r\n\r\nfunction exportLoggerFunctions(\r\n  debugConfig: boolean | ILogger,\r\n  ...functions: string[]\r\n): void {\r\n  functions.forEach(function (type) {\r\n    exportedLogger[type] = debugConfig[type]\r\n      ? debugConfig[type].bind(debugConfig)\r\n      : consolePrintFn(type);\r\n  });\r\n}\r\n\r\nexport function enableLogs(debugConfig: boolean | ILogger, id: string): void {\r\n  // check that console is available\r\n  if (\r\n    (self.console && debugConfig === true) ||\r\n    typeof debugConfig === 'object'\r\n  ) {\r\n    exportLoggerFunctions(\r\n      debugConfig,\r\n      // Remove out from list here to hard-disable a log-level\r\n      // 'trace',\r\n      'debug',\r\n      'log',\r\n      'info',\r\n      'warn',\r\n      'error',\r\n    );\r\n    // Some browsers don't allow to use bind on console object anyway\r\n    // fallback to default if needed\r\n    try {\r\n      exportedLogger.log(\r\n        `Debug logs enabled for \"${id}\" in hls.js version ${__VERSION__}`,\r\n      );\r\n    } catch (e) {\r\n      exportedLogger = fakeLogger;\r\n    }\r\n  } else {\r\n    exportedLogger = fakeLogger;\r\n  }\r\n}\r\n\r\nexport const logger: ILogger = exportedLogger;\r\n","export const isFiniteNumber =\r\n  Number.isFinite ||\r\n  function (value) {\r\n    return typeof value === 'number' && isFinite(value);\r\n  };\r\n\r\nexport const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;\r\n","// see https://tools.ietf.org/html/rfc1808\n\n(function (root) {\n  var URL_REGEX =\n    /^(?=((?:[a-zA-Z0-9+\\-.]+:)?))\\1(?=((?:\\/\\/[^\\/?#]*)?))\\2(?=((?:(?:[^?#\\/]*\\/)*[^;?#\\/]*)?))\\3((?:;[^?#]*)?)(\\?[^#]*)?(#[^]*)?$/;\n  var FIRST_SEGMENT_REGEX = /^(?=([^\\/?#]*))\\1([^]*)$/;\n  var SLASH_DOT_REGEX = /(?:\\/|^)\\.(?=\\/)/g;\n  var SLASH_DOT_DOT_REGEX = /(?:\\/|^)\\.\\.\\/(?!\\.\\.\\/)[^\\/]*(?=\\/)/g;\n\n  var URLToolkit = {\n    // If opts.alwaysNormalize is true then the path will always be normalized even when it starts with / or //\n    // E.g\n    // With opts.alwaysNormalize = false (default, spec compliant)\n    // http://a.com/b/cd + /e/f/../g => http://a.com/e/f/../g\n    // With opts.alwaysNormalize = true (not spec compliant)\n    // http://a.com/b/cd + /e/f/../g => http://a.com/e/g\n    buildAbsoluteURL: function (baseURL, relativeURL, opts) {\n      opts = opts || {};\n      // remove any remaining space and CRLF\n      baseURL = baseURL.trim();\n      relativeURL = relativeURL.trim();\n      if (!relativeURL) {\n        // 2a) If the embedded URL is entirely empty, it inherits the\n        // entire base URL (i.e., is set equal to the base URL)\n        // and we are done.\n        if (!opts.alwaysNormalize) {\n          return baseURL;\n        }\n        var basePartsForNormalise = URLToolkit.parseURL(baseURL);\n        if (!basePartsForNormalise) {\n          throw new Error('Error trying to parse base URL.');\n        }\n        basePartsForNormalise.path = URLToolkit.normalizePath(\n          basePartsForNormalise.path\n        );\n        return URLToolkit.buildURLFromParts(basePartsForNormalise);\n      }\n      var relativeParts = URLToolkit.parseURL(relativeURL);\n      if (!relativeParts) {\n        throw new Error('Error trying to parse relative URL.');\n      }\n      if (relativeParts.scheme) {\n        // 2b) If the embedded URL starts with a scheme name, it is\n        // interpreted as an absolute URL and we are done.\n        if (!opts.alwaysNormalize) {\n          return relativeURL;\n        }\n        relativeParts.path = URLToolkit.normalizePath(relativeParts.path);\n        return URLToolkit.buildURLFromParts(relativeParts);\n      }\n      var baseParts = URLToolkit.parseURL(baseURL);\n      if (!baseParts) {\n        throw new Error('Error trying to parse base URL.');\n      }\n      if (!baseParts.netLoc && baseParts.path && baseParts.path[0] !== '/') {\n        // If netLoc missing and path doesn't start with '/', assume everthing before the first '/' is the netLoc\n        // This causes 'example.com/a' to be handled as '//example.com/a' instead of '/example.com/a'\n        var pathParts = FIRST_SEGMENT_REGEX.exec(baseParts.path);\n        baseParts.netLoc = pathParts[1];\n        baseParts.path = pathParts[2];\n      }\n      if (baseParts.netLoc && !baseParts.path) {\n        baseParts.path = '/';\n      }\n      var builtParts = {\n        // 2c) Otherwise, the embedded URL inherits the scheme of\n        // the base URL.\n        scheme: baseParts.scheme,\n        netLoc: relativeParts.netLoc,\n        path: null,\n        params: relativeParts.params,\n        query: relativeParts.query,\n        fragment: relativeParts.fragment,\n      };\n      if (!relativeParts.netLoc) {\n        // 3) If the embedded URL's <net_loc> is non-empty, we skip to\n        // Step 7.  Otherwise, the embedded URL inherits the <net_loc>\n        // (if any) of the base URL.\n        builtParts.netLoc = baseParts.netLoc;\n        // 4) If the embedded URL path is preceded by a slash \"/\", the\n        // path is not relative and we skip to Step 7.\n        if (relativeParts.path[0] !== '/') {\n          if (!relativeParts.path) {\n            // 5) If the embedded URL path is empty (and not preceded by a\n            // slash), then the embedded URL inherits the base URL path\n            builtParts.path = baseParts.path;\n            // 5a) if the embedded URL's <params> is non-empty, we skip to\n            // step 7; otherwise, it inherits the <params> of the base\n            // URL (if any) and\n            if (!relativeParts.params) {\n              builtParts.params = baseParts.params;\n              // 5b) if the embedded URL's <query> is non-empty, we skip to\n              // step 7; otherwise, it inherits the <query> of the base\n              // URL (if any) and we skip to step 7.\n              if (!relativeParts.query) {\n                builtParts.query = baseParts.query;\n              }\n            }\n          } else {\n            // 6) The last segment of the base URL's path (anything\n            // following the rightmost slash \"/\", or the entire path if no\n            // slash is present) is removed and the embedded URL's path is\n            // appended in its place.\n            var baseURLPath = baseParts.path;\n            var newPath =\n              baseURLPath.substring(0, baseURLPath.lastIndexOf('/') + 1) +\n              relativeParts.path;\n            builtParts.path = URLToolkit.normalizePath(newPath);\n          }\n        }\n      }\n      if (builtParts.path === null) {\n        builtParts.path = opts.alwaysNormalize\n          ? URLToolkit.normalizePath(relativeParts.path)\n          : relativeParts.path;\n      }\n      return URLToolkit.buildURLFromParts(builtParts);\n    },\n    parseURL: function (url) {\n      var parts = URL_REGEX.exec(url);\n      if (!parts) {\n        return null;\n      }\n      return {\n        scheme: parts[1] || '',\n        netLoc: parts[2] || '',\n        path: parts[3] || '',\n        params: parts[4] || '',\n        query: parts[5] || '',\n        fragment: parts[6] || '',\n      };\n    },\n    normalizePath: function (path) {\n      // The following operations are\n      // then applied, in order, to the new path:\n      // 6a) All occurrences of \"./\", where \".\" is a complete path\n      // segment, are removed.\n      // 6b) If the path ends with \".\" as a complete path segment,\n      // that \".\" is removed.\n      path = path.split('').reverse().join('').replace(SLASH_DOT_REGEX, '');\n      // 6c) All occurrences of \"<segment>/../\", where <segment> is a\n      // complete path segment not equal to \"..\", are removed.\n      // Removal of these path segments is performed iteratively,\n      // removing the leftmost matching pattern on each iteration,\n      // until no matching pattern remains.\n      // 6d) If the path ends with \"<segment>/..\", where <segment> is a\n      // complete path segment not equal to \"..\", that\n      // \"<segment>/..\" is removed.\n      while (\n        path.length !== (path = path.replace(SLASH_DOT_DOT_REGEX, '')).length\n      ) {}\n      return path.split('').reverse().join('');\n    },\n    buildURLFromParts: function (parts) {\n      return (\n        parts.scheme +\n        parts.netLoc +\n        parts.path +\n        parts.params +\n        parts.query +\n        parts.fragment\n      );\n    },\n  };\n\n  if (typeof exports === 'object' && typeof module === 'object')\n    module.exports = URLToolkit;\n  else if (typeof define === 'function' && define.amd)\n    define([], function () {\n      return URLToolkit;\n    });\n  else if (typeof exports === 'object') exports['URLToolkit'] = URLToolkit;\n  else root['URLToolkit'] = URLToolkit;\n})(this);\n","import { buildAbsoluteURL } from 'url-toolkit';\r\nimport { LevelKey } from './level-key';\r\nimport { LoadStats } from './load-stats';\r\nimport { AttrList } from '../utils/attr-list';\r\nimport type {\r\n  FragmentLoaderContext,\r\n  KeyLoaderContext,\r\n  Loader,\r\n  PlaylistLevelType,\r\n} from '../types/loader';\r\nimport type { KeySystemFormats } from '../utils/mediakeys-helper';\r\n\r\nexport const enum ElementaryStreamTypes {\r\n  AUDIO = 'audio',\r\n  VIDEO = 'video',\r\n  AUDIOVIDEO = 'audiovideo',\r\n}\r\n\r\nexport interface ElementaryStreamInfo {\r\n  startPTS: number;\r\n  endPTS: number;\r\n  startDTS: number;\r\n  endDTS: number;\r\n  partial?: boolean;\r\n}\r\n\r\nexport type ElementaryStreams = Record<\r\n  ElementaryStreamTypes,\r\n  ElementaryStreamInfo | null\r\n>;\r\n\r\nexport class BaseSegment {\r\n  private _byteRange: number[] | null = null;\r\n  private _url: string | null = null;\r\n\r\n  // baseurl is the URL to the playlist\r\n  public readonly baseurl: string;\r\n  // relurl is the portion of the URL that comes from inside the playlist.\r\n  public relurl?: string;\r\n  // Holds the types of data this fragment supports\r\n  public elementaryStreams: ElementaryStreams = {\r\n    [ElementaryStreamTypes.AUDIO]: null,\r\n    [ElementaryStreamTypes.VIDEO]: null,\r\n    [ElementaryStreamTypes.AUDIOVIDEO]: null,\r\n  };\r\n\r\n  constructor(baseurl: string) {\r\n    this.baseurl = baseurl;\r\n  }\r\n\r\n  // setByteRange converts a EXT-X-BYTERANGE attribute into a two element array\r\n  setByteRange(value: string, previous?: BaseSegment) {\r\n    const params = value.split('@', 2);\r\n    const byteRange: number[] = [];\r\n    if (params.length === 1) {\r\n      byteRange[0] = previous ? previous.byteRangeEndOffset : 0;\r\n    } else {\r\n      byteRange[0] = parseInt(params[1]);\r\n    }\r\n    byteRange[1] = parseInt(params[0]) + byteRange[0];\r\n    this._byteRange = byteRange;\r\n  }\r\n\r\n  get byteRange(): number[] {\r\n    if (!this._byteRange) {\r\n      return [];\r\n    }\r\n\r\n    return this._byteRange;\r\n  }\r\n\r\n  get byteRangeStartOffset(): number {\r\n    return this.byteRange[0];\r\n  }\r\n\r\n  get byteRangeEndOffset(): number {\r\n    return this.byteRange[1];\r\n  }\r\n\r\n  get url(): string {\r\n    if (!this._url && this.baseurl && this.relurl) {\r\n      this._url = buildAbsoluteURL(this.baseurl, this.relurl, {\r\n        alwaysNormalize: true,\r\n      });\r\n    }\r\n    return this._url || '';\r\n  }\r\n\r\n  set url(value: string) {\r\n    this._url = value;\r\n  }\r\n}\r\n\r\n/**\r\n * Object representing parsed data from an HLS Segment. Found in {@link hls.js#LevelDetails.fragments}.\r\n */\r\nexport class Fragment extends BaseSegment {\r\n  private _decryptdata: LevelKey | null = null;\r\n\r\n  public rawProgramDateTime: string | null = null;\r\n  public programDateTime: number | null = null;\r\n  public tagList: Array<string[]> = [];\r\n\r\n  // EXTINF has to be present for a m3u8 to be considered valid\r\n  public duration: number = 0;\r\n  // sn notates the sequence number for a segment, and if set to a string can be 'initSegment'\r\n  public sn: number | 'initSegment' = 0;\r\n  // levelkeys are the EXT-X-KEY tags that apply to this segment for decryption\r\n  // core difference from the private field _decryptdata is the lack of the initialized IV\r\n  // _decryptdata will set the IV for this segment based on the segment number in the fragment\r\n  public levelkeys?: { [key: string]: LevelKey };\r\n  // A string representing the fragment type\r\n  public readonly type: PlaylistLevelType;\r\n  // A reference to the loader. Set while the fragment is loading, and removed afterwards. Used to abort fragment loading\r\n  public loader: Loader<FragmentLoaderContext> | null = null;\r\n  // A reference to the key loader. Set while the key is loading, and removed afterwards. Used to abort key loading\r\n  public keyLoader: Loader<KeyLoaderContext> | null = null;\r\n  // The level/track index to which the fragment belongs\r\n  public level: number = -1;\r\n  // The continuity counter of the fragment\r\n  public cc: number = 0;\r\n  // The starting Presentation Time Stamp (PTS) of the fragment. Set after transmux complete.\r\n  public startPTS?: number;\r\n  // The ending Presentation Time Stamp (PTS) of the fragment. Set after transmux complete.\r\n  public endPTS?: number;\r\n  // The starting Decode Time Stamp (DTS) of the fragment. Set after transmux complete.\r\n  public startDTS!: number;\r\n  // The ending Decode Time Stamp (DTS) of the fragment. Set after transmux complete.\r\n  public endDTS!: number;\r\n  // The start time of the fragment, as listed in the manifest. Updated after transmux complete.\r\n  public start: number = 0;\r\n  // Set by `updateFragPTSDTS` in level-helper\r\n  public deltaPTS?: number;\r\n  // The maximum starting Presentation Time Stamp (audio/video PTS) of the fragment. Set after transmux complete.\r\n  public maxStartPTS?: number;\r\n  // The minimum ending Presentation Time Stamp (audio/video PTS) of the fragment. Set after transmux complete.\r\n  public minEndPTS?: number;\r\n  // Load/parse timing information\r\n  public stats: LoadStats = new LoadStats();\r\n  public urlId: number = 0;\r\n  public data?: Uint8Array;\r\n  // A flag indicating whether the segment was downloaded in order to test bitrate, and was not buffered\r\n  public bitrateTest: boolean = false;\r\n  // #EXTINF  segment title\r\n  public title: string | null = null;\r\n  // The Media Initialization Section for this segment\r\n  public initSegment: Fragment | null = null;\r\n  // Fragment is the last fragment in the media playlist\r\n  public endList?: boolean;\r\n  // Fragment is marked by an EXT-X-GAP tag indicating that it does not contain media data and should not be loaded\r\n  public gap?: boolean;\r\n\r\n  constructor(type: PlaylistLevelType, baseurl: string) {\r\n    super(baseurl);\r\n    this.type = type;\r\n  }\r\n\r\n  get decryptdata(): LevelKey | null {\r\n    const { levelkeys } = this;\r\n    if (!levelkeys && !this._decryptdata) {\r\n      return null;\r\n    }\r\n\r\n    if (!this._decryptdata && this.levelkeys && !this.levelkeys.NONE) {\r\n      const key = this.levelkeys.identity;\r\n      if (key) {\r\n        this._decryptdata = key.getDecryptData(this.sn);\r\n      } else {\r\n        const keyFormats = Object.keys(this.levelkeys);\r\n        if (keyFormats.length === 1) {\r\n          return (this._decryptdata = this.levelkeys[\r\n            keyFormats[0]\r\n          ].getDecryptData(this.sn));\r\n        } else {\r\n          // Multiple keys. key-loader to call Fragment.setKeyFormat based on selected key-system.\r\n        }\r\n      }\r\n    }\r\n\r\n    return this._decryptdata;\r\n  }\r\n\r\n  get end(): number {\r\n    return this.start + this.duration;\r\n  }\r\n\r\n  get endProgramDateTime() {\r\n    if (this.programDateTime === null) {\r\n      return null;\r\n    }\r\n\r\n    if (!Number.isFinite(this.programDateTime)) {\r\n      return null;\r\n    }\r\n\r\n    const duration = !Number.isFinite(this.duration) ? 0 : this.duration;\r\n\r\n    return this.programDateTime + duration * 1000;\r\n  }\r\n\r\n  get encrypted() {\r\n    // At the m3u8-parser level we need to add support for manifest signalled keyformats\r\n    // when we want the fragment to start reporting that it is encrypted.\r\n    // Currently, keyFormat will only be set for identity keys\r\n    if (this._decryptdata?.encrypted) {\r\n      return true;\r\n    } else if (this.levelkeys) {\r\n      const keyFormats = Object.keys(this.levelkeys);\r\n      const len = keyFormats.length;\r\n      if (len > 1 || (len === 1 && this.levelkeys[keyFormats[0]].encrypted)) {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  setKeyFormat(keyFormat: KeySystemFormats) {\r\n    if (this.levelkeys) {\r\n      const key = this.levelkeys[keyFormat];\r\n      if (key && !this._decryptdata) {\r\n        this._decryptdata = key.getDecryptData(this.sn);\r\n      }\r\n    }\r\n  }\r\n\r\n  abortRequests(): void {\r\n    this.loader?.abort();\r\n    this.keyLoader?.abort();\r\n  }\r\n\r\n  setElementaryStreamInfo(\r\n    type: ElementaryStreamTypes,\r\n    startPTS: number,\r\n    endPTS: number,\r\n    startDTS: number,\r\n    endDTS: number,\r\n    partial: boolean = false,\r\n  ) {\r\n    const { elementaryStreams } = this;\r\n    const info = elementaryStreams[type];\r\n    if (!info) {\r\n      elementaryStreams[type] = {\r\n        startPTS,\r\n        endPTS,\r\n        startDTS,\r\n        endDTS,\r\n        partial,\r\n      };\r\n      return;\r\n    }\r\n\r\n    info.startPTS = Math.min(info.startPTS, startPTS);\r\n    info.endPTS = Math.max(info.endPTS, endPTS);\r\n    info.startDTS = Math.min(info.startDTS, startDTS);\r\n    info.endDTS = Math.max(info.endDTS, endDTS);\r\n  }\r\n\r\n  clearElementaryStreamInfo() {\r\n    const { elementaryStreams } = this;\r\n    elementaryStreams[ElementaryStreamTypes.AUDIO] = null;\r\n    elementaryStreams[ElementaryStreamTypes.VIDEO] = null;\r\n    elementaryStreams[ElementaryStreamTypes.AUDIOVIDEO] = null;\r\n  }\r\n}\r\n\r\n/**\r\n * Object representing parsed data from an HLS Partial Segment. Found in {@link hls.js#LevelDetails.partList}.\r\n */\r\nexport class Part extends BaseSegment {\r\n  public readonly fragOffset: number = 0;\r\n  public readonly duration: number = 0;\r\n  public readonly gap: boolean = false;\r\n  public readonly independent: boolean = false;\r\n  public readonly relurl: string;\r\n  public readonly fragment: Fragment;\r\n  public readonly index: number;\r\n  public stats: LoadStats = new LoadStats();\r\n\r\n  constructor(\r\n    partAttrs: AttrList,\r\n    frag: Fragment,\r\n    baseurl: string,\r\n    index: number,\r\n    previous?: Part,\r\n  ) {\r\n    super(baseurl);\r\n    this.duration = partAttrs.decimalFloatingPoint('DURATION');\r\n    this.gap = partAttrs.bool('GAP');\r\n    this.independent = partAttrs.bool('INDEPENDENT');\r\n    this.relurl = partAttrs.enumeratedString('URI') as string;\r\n    this.fragment = frag;\r\n    this.index = index;\r\n    const byteRange = partAttrs.enumeratedString('BYTERANGE');\r\n    if (byteRange) {\r\n      this.setByteRange(byteRange, previous);\r\n    }\r\n    if (previous) {\r\n      this.fragOffset = previous.fragOffset + previous.duration;\r\n    }\r\n  }\r\n\r\n  get start(): number {\r\n    return this.fragment.start + this.fragOffset;\r\n  }\r\n\r\n  get end(): number {\r\n    return this.start + this.duration;\r\n  }\r\n\r\n  get loaded(): boolean {\r\n    const { elementaryStreams } = this;\r\n    return !!(\r\n      elementaryStreams.audio ||\r\n      elementaryStreams.video ||\r\n      elementaryStreams.audiovideo\r\n    );\r\n  }\r\n}\r\n","type RawFrame = { type: string; size: number; data: Uint8Array };\r\n\r\n// breaking up those two types in order to clarify what is happening in the decoding path.\r\ntype DecodedFrame<T> = { key: string; data: T; info?: any };\r\nexport type Frame = DecodedFrame<ArrayBuffer | string>;\r\n\r\n/**\r\n * Returns true if an ID3 header can be found at offset in data\r\n * @param data - The data to search\r\n * @param offset - The offset at which to start searching\r\n */\r\nexport const isHeader = (data: Uint8Array, offset: number): boolean => {\r\n  /*\r\n   * http://id3.org/id3v2.3.0\r\n   * [0]     = 'I'\r\n   * [1]     = 'D'\r\n   * [2]     = '3'\r\n   * [3,4]   = {Version}\r\n   * [5]     = {Flags}\r\n   * [6-9]   = {ID3 Size}\r\n   *\r\n   * An ID3v2 tag can be detected with the following pattern:\r\n   *  $49 44 33 yy yy xx zz zz zz zz\r\n   * Where yy is less than $FF, xx is the 'flags' byte and zz is less than $80\r\n   */\r\n  if (offset + 10 <= data.length) {\r\n    // look for 'ID3' identifier\r\n    if (\r\n      data[offset] === 0x49 &&\r\n      data[offset + 1] === 0x44 &&\r\n      data[offset + 2] === 0x33\r\n    ) {\r\n      // check version is within range\r\n      if (data[offset + 3] < 0xff && data[offset + 4] < 0xff) {\r\n        // check size is within range\r\n        if (\r\n          data[offset + 6] < 0x80 &&\r\n          data[offset + 7] < 0x80 &&\r\n          data[offset + 8] < 0x80 &&\r\n          data[offset + 9] < 0x80\r\n        ) {\r\n          return true;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return false;\r\n};\r\n\r\n/**\r\n * Returns true if an ID3 footer can be found at offset in data\r\n * @param data - The data to search\r\n * @param offset - The offset at which to start searching\r\n */\r\nexport const isFooter = (data: Uint8Array, offset: number): boolean => {\r\n  /*\r\n   * The footer is a copy of the header, but with a different identifier\r\n   */\r\n  if (offset + 10 <= data.length) {\r\n    // look for '3DI' identifier\r\n    if (\r\n      data[offset] === 0x33 &&\r\n      data[offset + 1] === 0x44 &&\r\n      data[offset + 2] === 0x49\r\n    ) {\r\n      // check version is within range\r\n      if (data[offset + 3] < 0xff && data[offset + 4] < 0xff) {\r\n        // check size is within range\r\n        if (\r\n          data[offset + 6] < 0x80 &&\r\n          data[offset + 7] < 0x80 &&\r\n          data[offset + 8] < 0x80 &&\r\n          data[offset + 9] < 0x80\r\n        ) {\r\n          return true;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return false;\r\n};\r\n\r\n/**\r\n * Returns any adjacent ID3 tags found in data starting at offset, as one block of data\r\n * @param data - The data to search in\r\n * @param offset - The offset at which to start searching\r\n * @returns the block of data containing any ID3 tags found\r\n * or *undefined* if no header is found at the starting offset\r\n */\r\nexport const getID3Data = (\r\n  data: Uint8Array,\r\n  offset: number,\r\n): Uint8Array | undefined => {\r\n  const front = offset;\r\n  let length = 0;\r\n\r\n  while (isHeader(data, offset)) {\r\n    // ID3 header is 10 bytes\r\n    length += 10;\r\n\r\n    const size = readSize(data, offset + 6);\r\n    length += size;\r\n\r\n    if (isFooter(data, offset + 10)) {\r\n      // ID3 footer is 10 bytes\r\n      length += 10;\r\n    }\r\n\r\n    offset += length;\r\n  }\r\n\r\n  if (length > 0) {\r\n    return data.subarray(front, front + length);\r\n  }\r\n\r\n  return undefined;\r\n};\r\n\r\nconst readSize = (data: Uint8Array, offset: number): number => {\r\n  let size = 0;\r\n  size = (data[offset] & 0x7f) << 21;\r\n  size |= (data[offset + 1] & 0x7f) << 14;\r\n  size |= (data[offset + 2] & 0x7f) << 7;\r\n  size |= data[offset + 3] & 0x7f;\r\n  return size;\r\n};\r\n\r\nexport const canParse = (data: Uint8Array, offset: number): boolean => {\r\n  return (\r\n    isHeader(data, offset) &&\r\n    readSize(data, offset + 6) + 10 <= data.length - offset\r\n  );\r\n};\r\n\r\n/**\r\n * Searches for the Elementary Stream timestamp found in the ID3 data chunk\r\n * @param data - Block of data containing one or more ID3 tags\r\n */\r\nexport const getTimeStamp = (data: Uint8Array): number | undefined => {\r\n  const frames: Frame[] = getID3Frames(data);\r\n\r\n  for (let i = 0; i < frames.length; i++) {\r\n    const frame = frames[i];\r\n\r\n    if (isTimeStampFrame(frame)) {\r\n      return readTimeStamp(frame as DecodedFrame<ArrayBuffer>);\r\n    }\r\n  }\r\n\r\n  return undefined;\r\n};\r\n\r\n/**\r\n * Returns true if the ID3 frame is an Elementary Stream timestamp frame\r\n */\r\nexport const isTimeStampFrame = (frame: Frame): boolean => {\r\n  return (\r\n    frame &&\r\n    frame.key === 'PRIV' &&\r\n    frame.info === 'com.apple.streaming.transportStreamTimestamp'\r\n  );\r\n};\r\n\r\nconst getFrameData = (data: Uint8Array): RawFrame => {\r\n  /*\r\n  Frame ID       $xx xx xx xx (four characters)\r\n  Size           $xx xx xx xx\r\n  Flags          $xx xx\r\n  */\r\n  const type: string = String.fromCharCode(data[0], data[1], data[2], data[3]);\r\n  const size: number = readSize(data, 4);\r\n\r\n  // skip frame id, size, and flags\r\n  const offset = 10;\r\n\r\n  return { type, size, data: data.subarray(offset, offset + size) };\r\n};\r\n\r\n/**\r\n * Returns an array of ID3 frames found in all the ID3 tags in the id3Data\r\n * @param id3Data - The ID3 data containing one or more ID3 tags\r\n */\r\nexport const getID3Frames = (id3Data: Uint8Array): Frame[] => {\r\n  let offset = 0;\r\n  const frames: Frame[] = [];\r\n\r\n  while (isHeader(id3Data, offset)) {\r\n    const size = readSize(id3Data, offset + 6);\r\n    // skip past ID3 header\r\n    offset += 10;\r\n    const end = offset + size;\r\n    // loop through frames in the ID3 tag\r\n    while (offset + 8 < end) {\r\n      const frameData: RawFrame = getFrameData(id3Data.subarray(offset));\r\n      const frame: Frame | undefined = decodeFrame(frameData);\r\n      if (frame) {\r\n        frames.push(frame);\r\n      }\r\n\r\n      // skip frame header and frame data\r\n      offset += frameData.size + 10;\r\n    }\r\n\r\n    if (isFooter(id3Data, offset)) {\r\n      offset += 10;\r\n    }\r\n  }\r\n\r\n  return frames;\r\n};\r\n\r\nexport const decodeFrame = (frame: RawFrame): Frame | undefined => {\r\n  if (frame.type === 'PRIV') {\r\n    return decodePrivFrame(frame);\r\n  } else if (frame.type[0] === 'W') {\r\n    return decodeURLFrame(frame);\r\n  }\r\n\r\n  return decodeTextFrame(frame);\r\n};\r\n\r\nconst decodePrivFrame = (\r\n  frame: RawFrame,\r\n): DecodedFrame<ArrayBuffer> | undefined => {\r\n  /*\r\n  Format: <text string>\\0<binary data>\r\n  */\r\n  if (frame.size < 2) {\r\n    return undefined;\r\n  }\r\n\r\n  const owner = utf8ArrayToStr(frame.data, true);\r\n  const privateData = new Uint8Array(frame.data.subarray(owner.length + 1));\r\n\r\n  return { key: frame.type, info: owner, data: privateData.buffer };\r\n};\r\n\r\nconst decodeTextFrame = (frame: RawFrame): DecodedFrame<string> | undefined => {\r\n  if (frame.size < 2) {\r\n    return undefined;\r\n  }\r\n\r\n  if (frame.type === 'TXXX') {\r\n    /*\r\n    Format:\r\n    [0]   = {Text Encoding}\r\n    [1-?] = {Description}\\0{Value}\r\n    */\r\n    let index = 1;\r\n    const description = utf8ArrayToStr(frame.data.subarray(index), true);\r\n\r\n    index += description.length + 1;\r\n    const value = utf8ArrayToStr(frame.data.subarray(index));\r\n\r\n    return { key: frame.type, info: description, data: value };\r\n  }\r\n  /*\r\n  Format:\r\n  [0]   = {Text Encoding}\r\n  [1-?] = {Value}\r\n  */\r\n  const text = utf8ArrayToStr(frame.data.subarray(1));\r\n  return { key: frame.type, data: text };\r\n};\r\n\r\nconst decodeURLFrame = (frame: RawFrame): DecodedFrame<string> | undefined => {\r\n  if (frame.type === 'WXXX') {\r\n    /*\r\n    Format:\r\n    [0]   = {Text Encoding}\r\n    [1-?] = {Description}\\0{URL}\r\n    */\r\n    if (frame.size < 2) {\r\n      return undefined;\r\n    }\r\n\r\n    let index = 1;\r\n    const description: string = utf8ArrayToStr(\r\n      frame.data.subarray(index),\r\n      true,\r\n    );\r\n\r\n    index += description.length + 1;\r\n    const value: string = utf8ArrayToStr(frame.data.subarray(index));\r\n\r\n    return { key: frame.type, info: description, data: value };\r\n  }\r\n  /*\r\n  Format:\r\n  [0-?] = {URL}\r\n  */\r\n  const url: string = utf8ArrayToStr(frame.data);\r\n  return { key: frame.type, data: url };\r\n};\r\n\r\nconst readTimeStamp = (\r\n  timeStampFrame: DecodedFrame<ArrayBuffer>,\r\n): number | undefined => {\r\n  if (timeStampFrame.data.byteLength === 8) {\r\n    const data = new Uint8Array(timeStampFrame.data);\r\n    // timestamp is 33 bit expressed as a big-endian eight-octet number,\r\n    // with the upper 31 bits set to zero.\r\n    const pts33Bit = data[3] & 0x1;\r\n    let timestamp =\r\n      (data[4] << 23) + (data[5] << 15) + (data[6] << 7) + data[7];\r\n    timestamp /= 45;\r\n\r\n    if (pts33Bit) {\r\n      timestamp += 47721858.84;\r\n    } // 2^32 / 90\r\n\r\n    return Math.round(timestamp);\r\n  }\r\n\r\n  return undefined;\r\n};\r\n\r\n// http://stackoverflow.com/questions/8936984/uint8array-to-string-in-javascript/22373197\r\n// http://www.onicos.com/staff/iz/amuse/javascript/expert/utf.txt\r\n/* utf.js - UTF-8 <=> UTF-16 convertion\r\n *\r\n * Copyright (C) 1999 Masanao Izumo <iz@onicos.co.jp>\r\n * Version: 1.0\r\n * LastModified: Dec 25 1999\r\n * This library is free.  You can redistribute it and/or modify it.\r\n */\r\nexport const utf8ArrayToStr = (\r\n  array: Uint8Array,\r\n  exitOnNull: boolean = false,\r\n): string => {\r\n  const decoder = getTextDecoder();\r\n  if (decoder) {\r\n    const decoded = decoder.decode(array);\r\n\r\n    if (exitOnNull) {\r\n      // grab up to the first null\r\n      const idx = decoded.indexOf('\\0');\r\n      return idx !== -1 ? decoded.substring(0, idx) : decoded;\r\n    }\r\n\r\n    // remove any null characters\r\n    return decoded.replace(/\\0/g, '');\r\n  }\r\n\r\n  const len = array.length;\r\n  let c;\r\n  let char2;\r\n  let char3;\r\n  let out = '';\r\n  let i = 0;\r\n  while (i < len) {\r\n    c = array[i++];\r\n    if (c === 0x00 && exitOnNull) {\r\n      return out;\r\n    } else if (c === 0x00 || c === 0x03) {\r\n      // If the character is 3 (END_OF_TEXT) or 0 (NULL) then skip it\r\n      continue;\r\n    }\r\n    switch (c >> 4) {\r\n      case 0:\r\n      case 1:\r\n      case 2:\r\n      case 3:\r\n      case 4:\r\n      case 5:\r\n      case 6:\r\n      case 7:\r\n        // 0xxxxxxx\r\n        out += String.fromCharCode(c);\r\n        break;\r\n      case 12:\r\n      case 13:\r\n        // 110x xxxx   10xx xxxx\r\n        char2 = array[i++];\r\n        out += String.fromCharCode(((c & 0x1f) << 6) | (char2 & 0x3f));\r\n        break;\r\n      case 14:\r\n        // 1110 xxxx  10xx xxxx  10xx xxxx\r\n        char2 = array[i++];\r\n        char3 = array[i++];\r\n        out += String.fromCharCode(\r\n          ((c & 0x0f) << 12) | ((char2 & 0x3f) << 6) | ((char3 & 0x3f) << 0),\r\n        );\r\n        break;\r\n      default:\r\n    }\r\n  }\r\n  return out;\r\n};\r\n\r\nexport const testables = {\r\n  decodeTextFrame: decodeTextFrame,\r\n};\r\n\r\nlet decoder: TextDecoder;\r\n\r\nfunction getTextDecoder() {\r\n  if (!decoder && typeof self.TextDecoder !== 'undefined') {\r\n    decoder = new self.TextDecoder('utf-8');\r\n  }\r\n\r\n  return decoder;\r\n}\r\n","/**\r\n *  hex dump helper class\r\n */\r\n\r\nconst Hex = {\r\n  hexDump: function (array: Uint8Array) {\r\n    let str = '';\r\n    for (let i = 0; i < array.length; i++) {\r\n      let h = array[i].toString(16);\r\n      if (h.length < 2) {\r\n        h = '0' + h;\r\n      }\r\n\r\n      str += h;\r\n    }\r\n    return str;\r\n  },\r\n};\r\n\r\nexport default Hex;\r\n","import { ElementaryStreamTypes } from '../loader/fragment';\r\nimport { sliceUint8 } from './typed-array';\r\nimport { utf8ArrayToStr } from '../demux/id3';\r\nimport { logger } from '../utils/logger';\r\nimport Hex from './hex';\r\nimport type { PassthroughTrack, UserdataSample } from '../types/demuxer';\r\nimport type { DecryptData } from '../loader/level-key';\r\n\r\nconst UINT32_MAX = Math.pow(2, 32) - 1;\r\nconst push = [].push;\r\n\r\n// We are using fixed track IDs for driving the MP4 remuxer\r\n// instead of following the TS PIDs.\r\n// There is no reason not to do this and some browsers/SourceBuffer-demuxers\r\n// may not like if there are TrackID \"switches\"\r\n// See https://github.com/video-dev/hls.js/issues/1331\r\n// Here we are mapping our internal track types to constant MP4 track IDs\r\n// With MSE currently one can only have one track of each, and we are muxing\r\n// whatever video/audio rendition in them.\r\nexport const RemuxerTrackIdConfig = {\r\n  video: 1,\r\n  audio: 2,\r\n  id3: 3,\r\n  text: 4,\r\n};\r\n\r\nexport function bin2str(data: Uint8Array): string {\r\n  return String.fromCharCode.apply(null, data);\r\n}\r\n\r\nexport function readUint16(buffer: Uint8Array, offset: number): number {\r\n  const val = (buffer[offset] << 8) | buffer[offset + 1];\r\n  return val < 0 ? 65536 + val : val;\r\n}\r\n\r\nexport function readUint32(buffer: Uint8Array, offset: number): number {\r\n  const val = readSint32(buffer, offset);\r\n  return val < 0 ? 4294967296 + val : val;\r\n}\r\n\r\nexport function readSint32(buffer: Uint8Array, offset: number): number {\r\n  return (\r\n    (buffer[offset] << 24) |\r\n    (buffer[offset + 1] << 16) |\r\n    (buffer[offset + 2] << 8) |\r\n    buffer[offset + 3]\r\n  );\r\n}\r\n\r\nexport function writeUint32(buffer: Uint8Array, offset: number, value: number) {\r\n  buffer[offset] = value >> 24;\r\n  buffer[offset + 1] = (value >> 16) & 0xff;\r\n  buffer[offset + 2] = (value >> 8) & 0xff;\r\n  buffer[offset + 3] = value & 0xff;\r\n}\r\n\r\n// Find the data for a box specified by its path\r\nexport function findBox(data: Uint8Array, path: string[]): Uint8Array[] {\r\n  const results = [] as Uint8Array[];\r\n  if (!path.length) {\r\n    // short-circuit the search for empty paths\r\n    return results;\r\n  }\r\n  const end = data.byteLength;\r\n\r\n  for (let i = 0; i < end; ) {\r\n    const size = readUint32(data, i);\r\n    const type = bin2str(data.subarray(i + 4, i + 8));\r\n    const endbox = size > 1 ? i + size : end;\r\n    if (type === path[0]) {\r\n      if (path.length === 1) {\r\n        // this is the end of the path and we've found the box we were\r\n        // looking for\r\n        results.push(data.subarray(i + 8, endbox));\r\n      } else {\r\n        // recursively search for the next box along the path\r\n        const subresults = findBox(data.subarray(i + 8, endbox), path.slice(1));\r\n        if (subresults.length) {\r\n          push.apply(results, subresults);\r\n        }\r\n      }\r\n    }\r\n    i = endbox;\r\n  }\r\n\r\n  // we've finished searching all of data\r\n  return results;\r\n}\r\n\r\ntype SidxInfo = {\r\n  earliestPresentationTime: number;\r\n  timescale: number;\r\n  version: number;\r\n  referencesCount: number;\r\n  references: any[];\r\n};\r\n\r\nexport function parseSegmentIndex(sidx: Uint8Array): SidxInfo | null {\r\n  const references: any[] = [];\r\n\r\n  const version = sidx[0];\r\n\r\n  // set initial offset, we skip the reference ID (not needed)\r\n  let index = 8;\r\n\r\n  const timescale = readUint32(sidx, index);\r\n  index += 4;\r\n\r\n  // TODO: parse earliestPresentationTime and firstOffset\r\n  // usually zero in our case\r\n  const earliestPresentationTime = 0;\r\n  const firstOffset = 0;\r\n\r\n  if (version === 0) {\r\n    index += 8;\r\n  } else {\r\n    index += 16;\r\n  }\r\n\r\n  // skip reserved\r\n  index += 2;\r\n\r\n  let startByte = sidx.length + firstOffset;\r\n\r\n  const referencesCount = readUint16(sidx, index);\r\n  index += 2;\r\n\r\n  for (let i = 0; i < referencesCount; i++) {\r\n    let referenceIndex = index;\r\n\r\n    const referenceInfo = readUint32(sidx, referenceIndex);\r\n    referenceIndex += 4;\r\n\r\n    const referenceSize = referenceInfo & 0x7fffffff;\r\n    const referenceType = (referenceInfo & 0x80000000) >>> 31;\r\n\r\n    if (referenceType === 1) {\r\n      logger.warn('SIDX has hierarchical references (not supported)');\r\n      return null;\r\n    }\r\n\r\n    const subsegmentDuration = readUint32(sidx, referenceIndex);\r\n    referenceIndex += 4;\r\n\r\n    references.push({\r\n      referenceSize,\r\n      subsegmentDuration, // unscaled\r\n      info: {\r\n        duration: subsegmentDuration / timescale,\r\n        start: startByte,\r\n        end: startByte + referenceSize - 1,\r\n      },\r\n    });\r\n\r\n    startByte += referenceSize;\r\n\r\n    // Skipping 1 bit for |startsWithSap|, 3 bits for |sapType|, and 28 bits\r\n    // for |sapDelta|.\r\n    referenceIndex += 4;\r\n\r\n    // skip to next ref\r\n    index = referenceIndex;\r\n  }\r\n\r\n  return {\r\n    earliestPresentationTime,\r\n    timescale,\r\n    version,\r\n    referencesCount,\r\n    references,\r\n  };\r\n}\r\n\r\n/**\r\n * Parses an MP4 initialization segment and extracts stream type and\r\n * timescale values for any declared tracks. Timescale values indicate the\r\n * number of clock ticks per second to assume for time-based values\r\n * elsewhere in the MP4.\r\n *\r\n * To determine the start time of an MP4, you need two pieces of\r\n * information: the timescale unit and the earliest base media decode\r\n * time. Multiple timescales can be specified within an MP4 but the\r\n * base media decode time is always expressed in the timescale from\r\n * the media header box for the track:\r\n * ```\r\n * moov > trak > mdia > mdhd.timescale\r\n * moov > trak > mdia > hdlr\r\n * ```\r\n * @param initSegment the bytes of the init segment\r\n * @returns a hash of track type to timescale values or null if\r\n * the init segment is malformed.\r\n */\r\n\r\nexport interface InitDataTrack {\r\n  timescale: number;\r\n  id: number;\r\n  codec: string;\r\n}\r\n\r\ntype HdlrType = ElementaryStreamTypes.AUDIO | ElementaryStreamTypes.VIDEO;\r\n\r\nexport interface InitData extends Array<any> {\r\n  [index: number]:\r\n    | {\r\n        timescale: number;\r\n        type: HdlrType;\r\n        default?: {\r\n          duration: number;\r\n          flags: number;\r\n        };\r\n      }\r\n    | undefined;\r\n  audio?: InitDataTrack;\r\n  video?: InitDataTrack;\r\n  caption?: InitDataTrack;\r\n}\r\n\r\nexport function parseInitSegment(initSegment: Uint8Array): InitData {\r\n  const result: InitData = [];\r\n  const traks = findBox(initSegment, ['moov', 'trak']);\r\n  for (let i = 0; i < traks.length; i++) {\r\n    const trak = traks[i];\r\n    const tkhd = findBox(trak, ['tkhd'])[0];\r\n    if (tkhd) {\r\n      let version = tkhd[0];\r\n      const trackId = readUint32(tkhd, version === 0 ? 12 : 20);\r\n      const mdhd = findBox(trak, ['mdia', 'mdhd'])[0];\r\n      if (mdhd) {\r\n        version = mdhd[0];\r\n        const timescale = readUint32(mdhd, version === 0 ? 12 : 20);\r\n        const hdlr = findBox(trak, ['mdia', 'hdlr'])[0];\r\n        if (hdlr) {\r\n          const hdlrType = bin2str(hdlr.subarray(8, 12));\r\n          const type: HdlrType | undefined = {\r\n            soun: ElementaryStreamTypes.AUDIO as const,\r\n            vide: ElementaryStreamTypes.VIDEO as const,\r\n          }[hdlrType];\r\n          if (type) {\r\n            // Parse codec details\r\n            const stsd = findBox(trak, ['mdia', 'minf', 'stbl', 'stsd'])[0];\r\n            const stsdData = parseStsd(stsd);\r\n            result[trackId] = { timescale, type };\r\n            result[type] = { timescale, id: trackId, ...stsdData };\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  const trex = findBox(initSegment, ['moov', 'mvex', 'trex']);\r\n  trex.forEach((trex) => {\r\n    const trackId = readUint32(trex, 4);\r\n    const track = result[trackId];\r\n    if (track) {\r\n      track.default = {\r\n        duration: readUint32(trex, 12),\r\n        flags: readUint32(trex, 20),\r\n      };\r\n    }\r\n  });\r\n\r\n  return result;\r\n}\r\n\r\nfunction parseStsd(stsd: Uint8Array): { codec: string; encrypted: boolean } {\r\n  const sampleEntries = stsd.subarray(8);\r\n  const sampleEntriesEnd = sampleEntries.subarray(8 + 78);\r\n  const fourCC = bin2str(sampleEntries.subarray(4, 8));\r\n  let codec = fourCC;\r\n  const encrypted = fourCC === 'enca' || fourCC === 'encv';\r\n  if (encrypted) {\r\n    const encBox = findBox(sampleEntries, [fourCC])[0];\r\n    const encBoxChildren = encBox.subarray(fourCC === 'enca' ? 28 : 78);\r\n    const sinfs = findBox(encBoxChildren, ['sinf']);\r\n    sinfs.forEach((sinf) => {\r\n      const schm = findBox(sinf, ['schm'])[0];\r\n      if (schm) {\r\n        const scheme = bin2str(schm.subarray(4, 8));\r\n        if (scheme === 'cbcs' || scheme === 'cenc') {\r\n          const frma = findBox(sinf, ['frma'])[0];\r\n          if (frma) {\r\n            // for encrypted content codec fourCC will be in frma\r\n            codec = bin2str(frma);\r\n          }\r\n        }\r\n      }\r\n    });\r\n  }\r\n  switch (codec) {\r\n    case 'avc1':\r\n    case 'avc2':\r\n    case 'avc3':\r\n    case 'avc4':\r\n      // profile + compatibility + level\r\n      codec += '.' + toHex(stsd[111]) + toHex(stsd[112]) + toHex(stsd[113]);\r\n      break;\r\n    case 'mp4a': {\r\n      const codecBox = findBox(sampleEntries, [fourCC])[0];\r\n      const esdsBox = findBox(codecBox.subarray(28), ['esds'])[0];\r\n      if (esdsBox && esdsBox.length > 12 && esdsBox[11] !== 0) {\r\n        codec += '.' + toHex(esdsBox[11]);\r\n        codec += '.' + ((esdsBox[12] >>> 2) & 0x3f).toString(16).toUpperCase();\r\n      }\r\n      break;\r\n    }\r\n    // break;\r\n    case 'hvc1':\r\n    case 'hev1': {\r\n      const hvcCBox = findBox(sampleEntriesEnd, ['hvcC'])[0];\r\n      const profileByte = hvcCBox[1];\r\n      const profileSpace = ['', 'A', 'B', 'C'][profileByte >> 6];\r\n      const generalProfileIdc = profileByte & 0x1f;\r\n      const profileCompat = readUint32(hvcCBox, 2);\r\n      const tierFlag = (profileByte & 0x20) >> 5 ? 'H' : 'L';\r\n      const levelIDC = hvcCBox[12];\r\n      const constraintIndicator = hvcCBox.subarray(6, 12);\r\n      codec += '.' + profileSpace + generalProfileIdc;\r\n      codec += '.' + profileCompat.toString(16).toUpperCase();\r\n      codec += '.' + tierFlag + levelIDC;\r\n      let constraintString = '';\r\n      for (let i = constraintIndicator.length; i--; ) {\r\n        const byte = constraintIndicator[i];\r\n        if (byte || constraintString) {\r\n          const encodedByte = byte.toString(16).toUpperCase();\r\n          constraintString = '.' + encodedByte + constraintString;\r\n        }\r\n      }\r\n      codec += constraintString;\r\n      break;\r\n    }\r\n    case 'dvh1':\r\n    case 'dvhe': {\r\n      const dvcCBox = findBox(sampleEntriesEnd, ['dvcC'])[0];\r\n      const profile = (dvcCBox[2] >> 1) & 0x7f;\r\n      const level = ((dvcCBox[2] << 5) & 0x20) | ((dvcCBox[3] >> 3) & 0x1f);\r\n      codec += '.' + addLeadingZero(profile) + '.' + addLeadingZero(level);\r\n      break;\r\n    }\r\n    case 'vp09': {\r\n      const vpcCBox = findBox(sampleEntriesEnd, ['vpcC'])[0];\r\n      const profile = vpcCBox[4];\r\n      const level = vpcCBox[5];\r\n      const bitDepth = (vpcCBox[6] >> 4) & 0x0f;\r\n      codec +=\r\n        '.' +\r\n        addLeadingZero(profile) +\r\n        '.' +\r\n        addLeadingZero(level) +\r\n        '.' +\r\n        addLeadingZero(bitDepth);\r\n      break;\r\n    }\r\n    case 'av01': {\r\n      const av1CBox = findBox(sampleEntriesEnd, ['av1C'])[0];\r\n      const profile = av1CBox[1] >>> 5;\r\n      const level = av1CBox[1] & 0x1f;\r\n      const tierFlag = av1CBox[2] >>> 7 ? 'H' : 'M';\r\n      const highBitDepth = (av1CBox[2] & 0x40) >> 6;\r\n      const twelveBit = (av1CBox[2] & 0x20) >> 5;\r\n      const bitDepth =\r\n        profile === 2 && highBitDepth\r\n          ? twelveBit\r\n            ? 12\r\n            : 10\r\n          : highBitDepth\r\n          ? 10\r\n          : 8;\r\n      const monochrome = (av1CBox[2] & 0x10) >> 4;\r\n      const chromaSubsamplingX = (av1CBox[2] & 0x08) >> 3;\r\n      const chromaSubsamplingY = (av1CBox[2] & 0x04) >> 2;\r\n      const chromaSamplePosition = av1CBox[2] & 0x03;\r\n      // TODO: parse color_description_present_flag\r\n      // default it to BT.709/limited range for now\r\n      // more info https://aomediacodec.github.io/av1-isobmff/#av1codecconfigurationbox-syntax\r\n      const colorPrimaries = 1;\r\n      const transferCharacteristics = 1;\r\n      const matrixCoefficients = 1;\r\n      const videoFullRangeFlag = 0;\r\n      codec +=\r\n        '.' +\r\n        profile +\r\n        '.' +\r\n        addLeadingZero(level) +\r\n        tierFlag +\r\n        '.' +\r\n        addLeadingZero(bitDepth) +\r\n        '.' +\r\n        monochrome +\r\n        '.' +\r\n        chromaSubsamplingX +\r\n        chromaSubsamplingY +\r\n        chromaSamplePosition +\r\n        '.' +\r\n        addLeadingZero(colorPrimaries) +\r\n        '.' +\r\n        addLeadingZero(transferCharacteristics) +\r\n        '.' +\r\n        addLeadingZero(matrixCoefficients) +\r\n        '.' +\r\n        videoFullRangeFlag;\r\n      break;\r\n    }\r\n    case 'ac-3':\r\n    case 'ec-3':\r\n    case 'alac':\r\n    case 'fLaC':\r\n    case 'Opus':\r\n    default:\r\n      break;\r\n  }\r\n  return { codec, encrypted };\r\n}\r\n\r\nfunction toHex(x: number): string {\r\n  return ('0' + x.toString(16).toUpperCase()).slice(-2);\r\n}\r\n\r\nfunction addLeadingZero(num: number): string {\r\n  return (num < 10 ? '0' : '') + num;\r\n}\r\n\r\nexport function patchEncyptionData(\r\n  initSegment: Uint8Array | undefined,\r\n  decryptdata: DecryptData | null,\r\n): Uint8Array | undefined {\r\n  if (!initSegment || !decryptdata) {\r\n    return initSegment;\r\n  }\r\n  const keyId = decryptdata.keyId;\r\n  if (keyId && decryptdata.isCommonEncryption) {\r\n    const traks = findBox(initSegment, ['moov', 'trak']);\r\n    traks.forEach((trak) => {\r\n      const stsd = findBox(trak, ['mdia', 'minf', 'stbl', 'stsd'])[0];\r\n\r\n      // skip the sample entry count\r\n      const sampleEntries = stsd.subarray(8);\r\n      let encBoxes = findBox(sampleEntries, ['enca']);\r\n      const isAudio = encBoxes.length > 0;\r\n      if (!isAudio) {\r\n        encBoxes = findBox(sampleEntries, ['encv']);\r\n      }\r\n      encBoxes.forEach((enc) => {\r\n        const encBoxChildren = isAudio ? enc.subarray(28) : enc.subarray(78);\r\n        const sinfBoxes = findBox(encBoxChildren, ['sinf']);\r\n        sinfBoxes.forEach((sinf) => {\r\n          const tenc = parseSinf(sinf);\r\n          if (tenc) {\r\n            // Look for default key id (keyID offset is always 8 within the tenc box):\r\n            const tencKeyId = tenc.subarray(8, 24);\r\n            if (!tencKeyId.some((b) => b !== 0)) {\r\n              logger.log(\r\n                `[eme] Patching keyId in 'enc${\r\n                  isAudio ? 'a' : 'v'\r\n                }>sinf>>tenc' box: ${Hex.hexDump(tencKeyId)} -> ${Hex.hexDump(\r\n                  keyId,\r\n                )}`,\r\n              );\r\n              tenc.set(keyId, 8);\r\n            }\r\n          }\r\n        });\r\n      });\r\n    });\r\n  }\r\n\r\n  return initSegment;\r\n}\r\n\r\nexport function parseSinf(sinf: Uint8Array): Uint8Array | null {\r\n  const schm = findBox(sinf, ['schm'])[0];\r\n  if (schm) {\r\n    const scheme = bin2str(schm.subarray(4, 8));\r\n    if (scheme === 'cbcs' || scheme === 'cenc') {\r\n      return findBox(sinf, ['schi', 'tenc'])[0];\r\n    }\r\n  }\r\n  logger.error(`[eme] missing 'schm' box`);\r\n  return null;\r\n}\r\n\r\n/**\r\n * Determine the base media decode start time, in seconds, for an MP4\r\n * fragment. If multiple fragments are specified, the earliest time is\r\n * returned.\r\n *\r\n * The base media decode time can be parsed from track fragment\r\n * metadata:\r\n * ```\r\n * moof > traf > tfdt.baseMediaDecodeTime\r\n * ```\r\n * It requires the timescale value from the mdhd to interpret.\r\n *\r\n * @param initData - a hash of track type to timescale values\r\n * @param fmp4 - the bytes of the mp4 fragment\r\n * @returns the earliest base media decode start time for the\r\n * fragment, in seconds\r\n */\r\nexport function getStartDTS(\r\n  initData: InitData,\r\n  fmp4: Uint8Array,\r\n): number | null {\r\n  // we need info from two children of each track fragment box\r\n  return findBox(fmp4, ['moof', 'traf']).reduce(\r\n    (result: number | null, traf) => {\r\n      const tfdt = findBox(traf, ['tfdt'])[0];\r\n      const version = tfdt[0];\r\n      const start = findBox(traf, ['tfhd']).reduce(\r\n        (result: number | null, tfhd) => {\r\n          // get the track id from the tfhd\r\n          const id = readUint32(tfhd, 4);\r\n          const track = initData[id];\r\n          if (track) {\r\n            let baseTime = readUint32(tfdt, 4);\r\n            if (version === 1) {\r\n              // If value is too large, assume signed 64-bit. Negative track fragment decode times are invalid, but they exist in the wild.\r\n              // This prevents large values from being used for initPTS, which can cause playlist sync issues.\r\n              // https://github.com/video-dev/hls.js/issues/5303\r\n              if (baseTime === UINT32_MAX) {\r\n                logger.warn(\r\n                  `[mp4-demuxer]: Ignoring assumed invalid signed 64-bit track fragment decode time`,\r\n                );\r\n                return result;\r\n              }\r\n              baseTime *= UINT32_MAX + 1;\r\n              baseTime += readUint32(tfdt, 8);\r\n            }\r\n            // assume a 90kHz clock if no timescale was specified\r\n            const scale = track.timescale || 90e3;\r\n            // convert base time to seconds\r\n            const startTime = baseTime / scale;\r\n            if (\r\n              isFinite(startTime) &&\r\n              (result === null || startTime < result)\r\n            ) {\r\n              return startTime;\r\n            }\r\n          }\r\n          return result;\r\n        },\r\n        null,\r\n      );\r\n      if (\r\n        start !== null &&\r\n        isFinite(start) &&\r\n        (result === null || start < result)\r\n      ) {\r\n        return start;\r\n      }\r\n      return result;\r\n    },\r\n    null,\r\n  );\r\n}\r\n\r\n/*\r\n  For Reference:\r\n  aligned(8) class TrackFragmentHeaderBox\r\n           extends FullBox(tfhd, 0, tf_flags){\r\n     unsigned int(32)  track_ID;\r\n     // all the following are optional fields\r\n     unsigned int(64)  base_data_offset;\r\n     unsigned int(32)  sample_description_index;\r\n     unsigned int(32)  default_sample_duration;\r\n     unsigned int(32)  default_sample_size;\r\n     unsigned int(32)  default_sample_flags\r\n  }\r\n */\r\nexport function getDuration(data: Uint8Array, initData: InitData) {\r\n  let rawDuration = 0;\r\n  let videoDuration = 0;\r\n  let audioDuration = 0;\r\n  const trafs = findBox(data, ['moof', 'traf']);\r\n  for (let i = 0; i < trafs.length; i++) {\r\n    const traf = trafs[i];\r\n    // There is only one tfhd & trun per traf\r\n    // This is true for CMAF style content, and we should perhaps check the ftyp\r\n    // and only look for a single trun then, but for ISOBMFF we should check\r\n    // for multiple track runs.\r\n    const tfhd = findBox(traf, ['tfhd'])[0];\r\n    // get the track id from the tfhd\r\n    const id = readUint32(tfhd, 4);\r\n    const track = initData[id];\r\n    if (!track) {\r\n      continue;\r\n    }\r\n    const trackDefault = track.default;\r\n    const tfhdFlags = readUint32(tfhd, 0) | trackDefault?.flags!;\r\n    let sampleDuration: number | undefined = trackDefault?.duration;\r\n    if (tfhdFlags & 0x000008) {\r\n      // 0x000008 indicates the presence of the default_sample_duration field\r\n      if (tfhdFlags & 0x000002) {\r\n        // 0x000002 indicates the presence of the sample_description_index field, which precedes default_sample_duration\r\n        // If present, the default_sample_duration exists at byte offset 12\r\n        sampleDuration = readUint32(tfhd, 12);\r\n      } else {\r\n        // Otherwise, the duration is at byte offset 8\r\n        sampleDuration = readUint32(tfhd, 8);\r\n      }\r\n    }\r\n    // assume a 90kHz clock if no timescale was specified\r\n    const timescale = track.timescale || 90e3;\r\n    const truns = findBox(traf, ['trun']);\r\n    for (let j = 0; j < truns.length; j++) {\r\n      rawDuration = computeRawDurationFromSamples(truns[j]);\r\n      if (!rawDuration && sampleDuration) {\r\n        const sampleCount = readUint32(truns[j], 4);\r\n        rawDuration = sampleDuration * sampleCount;\r\n      }\r\n      if (track.type === ElementaryStreamTypes.VIDEO) {\r\n        videoDuration += rawDuration / timescale;\r\n      } else if (track.type === ElementaryStreamTypes.AUDIO) {\r\n        audioDuration += rawDuration / timescale;\r\n      }\r\n    }\r\n  }\r\n  if (videoDuration === 0 && audioDuration === 0) {\r\n    // If duration samples are not available in the traf use sidx subsegment_duration\r\n    let sidxDuration = 0;\r\n    const sidxs = findBox(data, ['sidx']);\r\n    for (let i = 0; i < sidxs.length; i++) {\r\n      const sidx = parseSegmentIndex(sidxs[i]);\r\n      if (sidx?.references) {\r\n        sidxDuration += sidx.references.reduce(\r\n          (dur, ref) => dur + ref.info.duration || 0,\r\n          0,\r\n        );\r\n      }\r\n    }\r\n\r\n    return sidxDuration;\r\n  }\r\n  if (videoDuration) {\r\n    return videoDuration;\r\n  }\r\n  return audioDuration;\r\n}\r\n\r\n/*\r\n  For Reference:\r\n  aligned(8) class TrackRunBox\r\n           extends FullBox(trun, version, tr_flags) {\r\n     unsigned int(32)  sample_count;\r\n     // the following are optional fields\r\n     signed int(32) data_offset;\r\n     unsigned int(32)  first_sample_flags;\r\n     // all fields in the following array are optional\r\n     {\r\n        unsigned int(32)  sample_duration;\r\n        unsigned int(32)  sample_size;\r\n        unsigned int(32)  sample_flags\r\n        if (version == 0)\r\n           { unsigned int(32)\r\n        else\r\n           { signed int(32)\r\n     }[ sample_count ]\r\n  }\r\n */\r\nexport function computeRawDurationFromSamples(trun): number {\r\n  const flags = readUint32(trun, 0);\r\n  // Flags are at offset 0, non-optional sample_count is at offset 4. Therefore we start 8 bytes in.\r\n  // Each field is an int32, which is 4 bytes\r\n  let offset = 8;\r\n  // data-offset-present flag\r\n  if (flags & 0x000001) {\r\n    offset += 4;\r\n  }\r\n  // first-sample-flags-present flag\r\n  if (flags & 0x000004) {\r\n    offset += 4;\r\n  }\r\n\r\n  let duration = 0;\r\n  const sampleCount = readUint32(trun, 4);\r\n  for (let i = 0; i < sampleCount; i++) {\r\n    // sample-duration-present flag\r\n    if (flags & 0x000100) {\r\n      const sampleDuration = readUint32(trun, offset);\r\n      duration += sampleDuration;\r\n      offset += 4;\r\n    }\r\n    // sample-size-present flag\r\n    if (flags & 0x000200) {\r\n      offset += 4;\r\n    }\r\n    // sample-flags-present flag\r\n    if (flags & 0x000400) {\r\n      offset += 4;\r\n    }\r\n    // sample-composition-time-offsets-present flag\r\n    if (flags & 0x000800) {\r\n      offset += 4;\r\n    }\r\n  }\r\n  return duration;\r\n}\r\n\r\nexport function offsetStartDTS(\r\n  initData: InitData,\r\n  fmp4: Uint8Array,\r\n  timeOffset: number,\r\n) {\r\n  findBox(fmp4, ['moof', 'traf']).forEach((traf) => {\r\n    findBox(traf, ['tfhd']).forEach((tfhd) => {\r\n      // get the track id from the tfhd\r\n      const id = readUint32(tfhd, 4);\r\n      const track = initData[id];\r\n      if (!track) {\r\n        return;\r\n      }\r\n      // assume a 90kHz clock if no timescale was specified\r\n      const timescale = track.timescale || 90e3;\r\n      // get the base media decode time from the tfdt\r\n      findBox(traf, ['tfdt']).forEach((tfdt) => {\r\n        const version = tfdt[0];\r\n        const offset = timeOffset * timescale;\r\n        if (offset) {\r\n          let baseMediaDecodeTime = readUint32(tfdt, 4);\r\n          if (version === 0) {\r\n            baseMediaDecodeTime -= offset;\r\n            baseMediaDecodeTime = Math.max(baseMediaDecodeTime, 0);\r\n            writeUint32(tfdt, 4, baseMediaDecodeTime);\r\n          } else {\r\n            baseMediaDecodeTime *= Math.pow(2, 32);\r\n            baseMediaDecodeTime += readUint32(tfdt, 8);\r\n            baseMediaDecodeTime -= offset;\r\n            baseMediaDecodeTime = Math.max(baseMediaDecodeTime, 0);\r\n            const upper = Math.floor(baseMediaDecodeTime / (UINT32_MAX + 1));\r\n            const lower = Math.floor(baseMediaDecodeTime % (UINT32_MAX + 1));\r\n            writeUint32(tfdt, 4, upper);\r\n            writeUint32(tfdt, 8, lower);\r\n          }\r\n        }\r\n      });\r\n    });\r\n  });\r\n}\r\n\r\n// TODO: Check if the last moof+mdat pair is part of the valid range\r\nexport function segmentValidRange(data: Uint8Array): SegmentedRange {\r\n  const segmentedRange: SegmentedRange = {\r\n    valid: null,\r\n    remainder: null,\r\n  };\r\n\r\n  const moofs = findBox(data, ['moof']);\r\n  if (!moofs) {\r\n    return segmentedRange;\r\n  } else if (moofs.length < 2) {\r\n    segmentedRange.remainder = data;\r\n    return segmentedRange;\r\n  }\r\n  const last = moofs[moofs.length - 1];\r\n  // Offset by 8 bytes; findBox offsets the start by as much\r\n  segmentedRange.valid = sliceUint8(data, 0, last.byteOffset - 8);\r\n  segmentedRange.remainder = sliceUint8(data, last.byteOffset - 8);\r\n  return segmentedRange;\r\n}\r\n\r\nexport interface SegmentedRange {\r\n  valid: Uint8Array | null;\r\n  remainder: Uint8Array | null;\r\n}\r\n\r\nexport function appendUint8Array(\r\n  data1: Uint8Array,\r\n  data2: Uint8Array,\r\n): Uint8Array {\r\n  const temp = new Uint8Array(data1.length + data2.length);\r\n  temp.set(data1);\r\n  temp.set(data2, data1.length);\r\n\r\n  return temp;\r\n}\r\n\r\nexport interface IEmsgParsingData {\r\n  schemeIdUri: string;\r\n  value: string;\r\n  timeScale: number;\r\n  presentationTimeDelta?: number;\r\n  presentationTime?: number;\r\n  eventDuration: number;\r\n  id: number;\r\n  payload: Uint8Array;\r\n}\r\n\r\nexport function parseSamples(\r\n  timeOffset: number,\r\n  track: PassthroughTrack,\r\n): UserdataSample[] {\r\n  const seiSamples = [] as UserdataSample[];\r\n  const videoData = track.samples;\r\n  const timescale = track.timescale;\r\n  const trackId = track.id;\r\n  let isHEVCFlavor = false;\r\n\r\n  const moofs = findBox(videoData, ['moof']);\r\n  moofs.map((moof) => {\r\n    const moofOffset = moof.byteOffset - 8;\r\n    const trafs = findBox(moof, ['traf']);\r\n    trafs.map((traf) => {\r\n      // get the base media decode time from the tfdt\r\n      const baseTime = findBox(traf, ['tfdt']).map((tfdt) => {\r\n        const version = tfdt[0];\r\n        let result = readUint32(tfdt, 4);\r\n        if (version === 1) {\r\n          result *= Math.pow(2, 32);\r\n          result += readUint32(tfdt, 8);\r\n        }\r\n        return result / timescale;\r\n      })[0];\r\n\r\n      if (baseTime !== undefined) {\r\n        timeOffset = baseTime;\r\n      }\r\n\r\n      return findBox(traf, ['tfhd']).map((tfhd) => {\r\n        const id = readUint32(tfhd, 4);\r\n        const tfhdFlags = readUint32(tfhd, 0) & 0xffffff;\r\n        const baseDataOffsetPresent = (tfhdFlags & 0x000001) !== 0;\r\n        const sampleDescriptionIndexPresent = (tfhdFlags & 0x000002) !== 0;\r\n        const defaultSampleDurationPresent = (tfhdFlags & 0x000008) !== 0;\r\n        let defaultSampleDuration = 0;\r\n        const defaultSampleSizePresent = (tfhdFlags & 0x000010) !== 0;\r\n        let defaultSampleSize = 0;\r\n        const defaultSampleFlagsPresent = (tfhdFlags & 0x000020) !== 0;\r\n        let tfhdOffset = 8;\r\n\r\n        if (id === trackId) {\r\n          if (baseDataOffsetPresent) {\r\n            tfhdOffset += 8;\r\n          }\r\n          if (sampleDescriptionIndexPresent) {\r\n            tfhdOffset += 4;\r\n          }\r\n          if (defaultSampleDurationPresent) {\r\n            defaultSampleDuration = readUint32(tfhd, tfhdOffset);\r\n            tfhdOffset += 4;\r\n          }\r\n          if (defaultSampleSizePresent) {\r\n            defaultSampleSize = readUint32(tfhd, tfhdOffset);\r\n            tfhdOffset += 4;\r\n          }\r\n          if (defaultSampleFlagsPresent) {\r\n            tfhdOffset += 4;\r\n          }\r\n          if (track.type === 'video') {\r\n            isHEVCFlavor = isHEVC(track.codec);\r\n          }\r\n\r\n          findBox(traf, ['trun']).map((trun) => {\r\n            const version = trun[0];\r\n            const flags = readUint32(trun, 0) & 0xffffff;\r\n            const dataOffsetPresent = (flags & 0x000001) !== 0;\r\n            let dataOffset = 0;\r\n            const firstSampleFlagsPresent = (flags & 0x000004) !== 0;\r\n            const sampleDurationPresent = (flags & 0x000100) !== 0;\r\n            let sampleDuration = 0;\r\n            const sampleSizePresent = (flags & 0x000200) !== 0;\r\n            let sampleSize = 0;\r\n            const sampleFlagsPresent = (flags & 0x000400) !== 0;\r\n            const sampleCompositionOffsetsPresent = (flags & 0x000800) !== 0;\r\n            let compositionOffset = 0;\r\n            const sampleCount = readUint32(trun, 4);\r\n            let trunOffset = 8; // past version, flags, and sample count\r\n\r\n            if (dataOffsetPresent) {\r\n              dataOffset = readUint32(trun, trunOffset);\r\n              trunOffset += 4;\r\n            }\r\n            if (firstSampleFlagsPresent) {\r\n              trunOffset += 4;\r\n            }\r\n\r\n            let sampleOffset = dataOffset + moofOffset;\r\n\r\n            for (let ix = 0; ix < sampleCount; ix++) {\r\n              if (sampleDurationPresent) {\r\n                sampleDuration = readUint32(trun, trunOffset);\r\n                trunOffset += 4;\r\n              } else {\r\n                sampleDuration = defaultSampleDuration;\r\n              }\r\n              if (sampleSizePresent) {\r\n                sampleSize = readUint32(trun, trunOffset);\r\n                trunOffset += 4;\r\n              } else {\r\n                sampleSize = defaultSampleSize;\r\n              }\r\n              if (sampleFlagsPresent) {\r\n                trunOffset += 4;\r\n              }\r\n              if (sampleCompositionOffsetsPresent) {\r\n                if (version === 0) {\r\n                  compositionOffset = readUint32(trun, trunOffset);\r\n                } else {\r\n                  compositionOffset = readSint32(trun, trunOffset);\r\n                }\r\n                trunOffset += 4;\r\n              }\r\n              if (track.type === ElementaryStreamTypes.VIDEO) {\r\n                let naluTotalSize = 0;\r\n                while (naluTotalSize < sampleSize) {\r\n                  const naluSize = readUint32(videoData, sampleOffset);\r\n                  sampleOffset += 4;\r\n                  if (isSEIMessage(isHEVCFlavor, videoData[sampleOffset])) {\r\n                    const data = videoData.subarray(\r\n                      sampleOffset,\r\n                      sampleOffset + naluSize,\r\n                    );\r\n                    parseSEIMessageFromNALu(\r\n                      data,\r\n                      isHEVCFlavor ? 2 : 1,\r\n                      timeOffset + compositionOffset / timescale,\r\n                      seiSamples,\r\n                    );\r\n                  }\r\n                  sampleOffset += naluSize;\r\n                  naluTotalSize += naluSize + 4;\r\n                }\r\n              }\r\n\r\n              timeOffset += sampleDuration / timescale;\r\n            }\r\n          });\r\n        }\r\n      });\r\n    });\r\n  });\r\n  return seiSamples;\r\n}\r\n\r\nfunction isHEVC(codec: string) {\r\n  if (!codec) {\r\n    return false;\r\n  }\r\n  const delimit = codec.indexOf('.');\r\n  const baseCodec = delimit < 0 ? codec : codec.substring(0, delimit);\r\n  return (\r\n    baseCodec === 'hvc1' ||\r\n    baseCodec === 'hev1' ||\r\n    // Dolby Vision\r\n    baseCodec === 'dvh1' ||\r\n    baseCodec === 'dvhe'\r\n  );\r\n}\r\n\r\nfunction isSEIMessage(isHEVCFlavor: boolean, naluHeader: number) {\r\n  if (isHEVCFlavor) {\r\n    const naluType = (naluHeader >> 1) & 0x3f;\r\n    return naluType === 39 || naluType === 40;\r\n  } else {\r\n    const naluType = naluHeader & 0x1f;\r\n    return naluType === 6;\r\n  }\r\n}\r\n\r\nexport function parseSEIMessageFromNALu(\r\n  unescapedData: Uint8Array,\r\n  headerSize: number,\r\n  pts: number,\r\n  samples: UserdataSample[],\r\n) {\r\n  const data = discardEPB(unescapedData);\r\n  let seiPtr = 0;\r\n  // skip nal header\r\n  seiPtr += headerSize;\r\n  let payloadType = 0;\r\n  let payloadSize = 0;\r\n  let endOfCaptions = false;\r\n  let b = 0;\r\n\r\n  while (seiPtr < data.length) {\r\n    payloadType = 0;\r\n    do {\r\n      if (seiPtr >= data.length) {\r\n        break;\r\n      }\r\n      b = data[seiPtr++];\r\n      payloadType += b;\r\n    } while (b === 0xff);\r\n\r\n    // Parse payload size.\r\n    payloadSize = 0;\r\n    do {\r\n      if (seiPtr >= data.length) {\r\n        break;\r\n      }\r\n      b = data[seiPtr++];\r\n      payloadSize += b;\r\n    } while (b === 0xff);\r\n\r\n    const leftOver = data.length - seiPtr;\r\n\r\n    if (!endOfCaptions && payloadType === 4 && seiPtr < data.length) {\r\n      endOfCaptions = true;\r\n\r\n      const countryCode = data[seiPtr++];\r\n      if (countryCode === 181) {\r\n        const providerCode = readUint16(data, seiPtr);\r\n        seiPtr += 2;\r\n\r\n        if (providerCode === 49) {\r\n          const userStructure = readUint32(data, seiPtr);\r\n          seiPtr += 4;\r\n\r\n          if (userStructure === 0x47413934) {\r\n            const userDataType = data[seiPtr++];\r\n\r\n            // Raw CEA-608 bytes wrapped in CEA-708 packet\r\n            if (userDataType === 3) {\r\n              const firstByte = data[seiPtr++];\r\n              const totalCCs = 0x1f & firstByte;\r\n              const enabled = 0x40 & firstByte;\r\n              const totalBytes = enabled ? 2 + totalCCs * 3 : 0;\r\n              const byteArray = new Uint8Array(totalBytes);\r\n              if (enabled) {\r\n                byteArray[0] = firstByte;\r\n                for (let i = 1; i < totalBytes; i++) {\r\n                  byteArray[i] = data[seiPtr++];\r\n                }\r\n              }\r\n\r\n              samples.push({\r\n                type: userDataType,\r\n                payloadType,\r\n                pts,\r\n                bytes: byteArray,\r\n              });\r\n            }\r\n          }\r\n        }\r\n      }\r\n    } else if (payloadType === 5 && payloadSize < leftOver) {\r\n      endOfCaptions = true;\r\n\r\n      if (payloadSize > 16) {\r\n        const uuidStrArray: Array<string> = [];\r\n        for (let i = 0; i < 16; i++) {\r\n          const b = data[seiPtr++].toString(16);\r\n          uuidStrArray.push(b.length == 1 ? '0' + b : b);\r\n\r\n          if (i === 3 || i === 5 || i === 7 || i === 9) {\r\n            uuidStrArray.push('-');\r\n          }\r\n        }\r\n        const length = payloadSize - 16;\r\n        const userDataBytes = new Uint8Array(length);\r\n        for (let i = 0; i < length; i++) {\r\n          userDataBytes[i] = data[seiPtr++];\r\n        }\r\n\r\n        samples.push({\r\n          payloadType,\r\n          pts,\r\n          uuid: uuidStrArray.join(''),\r\n          userData: utf8ArrayToStr(userDataBytes),\r\n          userDataBytes,\r\n        });\r\n      }\r\n    } else if (payloadSize < leftOver) {\r\n      seiPtr += payloadSize;\r\n    } else if (payloadSize > leftOver) {\r\n      break;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * remove Emulation Prevention bytes from a RBSP\r\n */\r\nexport function discardEPB(data: Uint8Array): Uint8Array {\r\n  const length = data.byteLength;\r\n  const EPBPositions = [] as Array<number>;\r\n  let i = 1;\r\n\r\n  // Find all `Emulation Prevention Bytes`\r\n  while (i < length - 2) {\r\n    if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 0x03) {\r\n      EPBPositions.push(i + 2);\r\n      i += 2;\r\n    } else {\r\n      i++;\r\n    }\r\n  }\r\n\r\n  // If no Emulation Prevention Bytes were found just return the original\r\n  // array\r\n  if (EPBPositions.length === 0) {\r\n    return data;\r\n  }\r\n\r\n  // Create a new array to hold the NAL unit data\r\n  const newLength = length - EPBPositions.length;\r\n  const newData = new Uint8Array(newLength);\r\n  let sourceIndex = 0;\r\n\r\n  for (i = 0; i < newLength; sourceIndex++, i++) {\r\n    if (sourceIndex === EPBPositions[0]) {\r\n      // Skip this byte\r\n      sourceIndex++;\r\n      // Remove this position index\r\n      EPBPositions.shift();\r\n    }\r\n    newData[i] = data[sourceIndex];\r\n  }\r\n  return newData;\r\n}\r\n\r\nexport function parseEmsg(data: Uint8Array): IEmsgParsingData {\r\n  const version = data[0];\r\n  let schemeIdUri: string = '';\r\n  let value: string = '';\r\n  let timeScale: number = 0;\r\n  let presentationTimeDelta: number = 0;\r\n  let presentationTime: number = 0;\r\n  let eventDuration: number = 0;\r\n  let id: number = 0;\r\n  let offset: number = 0;\r\n\r\n  if (version === 0) {\r\n    while (bin2str(data.subarray(offset, offset + 1)) !== '\\0') {\r\n      schemeIdUri += bin2str(data.subarray(offset, offset + 1));\r\n      offset += 1;\r\n    }\r\n\r\n    schemeIdUri += bin2str(data.subarray(offset, offset + 1));\r\n    offset += 1;\r\n\r\n    while (bin2str(data.subarray(offset, offset + 1)) !== '\\0') {\r\n      value += bin2str(data.subarray(offset, offset + 1));\r\n      offset += 1;\r\n    }\r\n\r\n    value += bin2str(data.subarray(offset, offset + 1));\r\n    offset += 1;\r\n\r\n    timeScale = readUint32(data, 12);\r\n    presentationTimeDelta = readUint32(data, 16);\r\n    eventDuration = readUint32(data, 20);\r\n    id = readUint32(data, 24);\r\n    offset = 28;\r\n  } else if (version === 1) {\r\n    offset += 4;\r\n    timeScale = readUint32(data, offset);\r\n    offset += 4;\r\n    const leftPresentationTime = readUint32(data, offset);\r\n    offset += 4;\r\n    const rightPresentationTime = readUint32(data, offset);\r\n    offset += 4;\r\n    presentationTime = 2 ** 32 * leftPresentationTime + rightPresentationTime;\r\n    if (!Number.isSafeInteger(presentationTime)) {\r\n      presentationTime = Number.MAX_SAFE_INTEGER;\r\n      logger.warn(\r\n        'Presentation time exceeds safe integer limit and wrapped to max safe integer in parsing emsg box',\r\n      );\r\n    }\r\n\r\n    eventDuration = readUint32(data, offset);\r\n    offset += 4;\r\n    id = readUint32(data, offset);\r\n    offset += 4;\r\n\r\n    while (bin2str(data.subarray(offset, offset + 1)) !== '\\0') {\r\n      schemeIdUri += bin2str(data.subarray(offset, offset + 1));\r\n      offset += 1;\r\n    }\r\n\r\n    schemeIdUri += bin2str(data.subarray(offset, offset + 1));\r\n    offset += 1;\r\n\r\n    while (bin2str(data.subarray(offset, offset + 1)) !== '\\0') {\r\n      value += bin2str(data.subarray(offset, offset + 1));\r\n      offset += 1;\r\n    }\r\n\r\n    value += bin2str(data.subarray(offset, offset + 1));\r\n    offset += 1;\r\n  }\r\n  const payload = data.subarray(offset, data.byteLength);\r\n\r\n  return {\r\n    schemeIdUri,\r\n    value,\r\n    timeScale,\r\n    presentationTime,\r\n    presentationTimeDelta,\r\n    eventDuration,\r\n    id,\r\n    payload,\r\n  };\r\n}\r\n\r\nexport function mp4Box(type: ArrayLike<number>, ...payload: Uint8Array[]) {\r\n  const len = payload.length;\r\n  let size = 8;\r\n  let i = len;\r\n  while (i--) {\r\n    size += payload[i].byteLength;\r\n  }\r\n  const result = new Uint8Array(size);\r\n  result[0] = (size >> 24) & 0xff;\r\n  result[1] = (size >> 16) & 0xff;\r\n  result[2] = (size >> 8) & 0xff;\r\n  result[3] = size & 0xff;\r\n  result.set(type, 4);\r\n  for (i = 0, size = 8; i < len; i++) {\r\n    result.set(payload[i], size);\r\n    size += payload[i].byteLength;\r\n  }\r\n  return result;\r\n}\r\n\r\nexport function mp4pssh(\r\n  systemId: Uint8Array,\r\n  keyids: Array<Uint8Array> | null,\r\n  data: Uint8Array,\r\n) {\r\n  if (systemId.byteLength !== 16) {\r\n    throw new RangeError('Invalid system id');\r\n  }\r\n  let version;\r\n  let kids;\r\n  if (keyids) {\r\n    version = 1;\r\n    kids = new Uint8Array(keyids.length * 16);\r\n    for (let ix = 0; ix < keyids.length; ix++) {\r\n      const k = keyids[ix]; // uint8array\r\n      if (k.byteLength !== 16) {\r\n        throw new RangeError('Invalid key');\r\n      }\r\n      kids.set(k, ix * 16);\r\n    }\r\n  } else {\r\n    version = 0;\r\n    kids = new Uint8Array();\r\n  }\r\n  let kidCount;\r\n  if (version > 0) {\r\n    kidCount = new Uint8Array(4);\r\n    if (keyids!.length > 0) {\r\n      new DataView(kidCount.buffer).setUint32(0, keyids!.length, false);\r\n    }\r\n  } else {\r\n    kidCount = new Uint8Array();\r\n  }\r\n  const dataSize = new Uint8Array(4);\r\n  if (data && data.byteLength > 0) {\r\n    new DataView(dataSize.buffer).setUint32(0, data.byteLength, false);\r\n  }\r\n  return mp4Box(\r\n    [112, 115, 115, 104],\r\n    new Uint8Array([\r\n      version,\r\n      0x00,\r\n      0x00,\r\n      0x00, // Flags\r\n    ]),\r\n    systemId, // 16 bytes\r\n    kidCount,\r\n    kids,\r\n    dataSize,\r\n    data || new Uint8Array(),\r\n  );\r\n}\r\n\r\nexport function parsePssh(initData: ArrayBuffer) {\r\n  if (!(initData instanceof ArrayBuffer) || initData.byteLength < 32) {\r\n    return null;\r\n  }\r\n  const result = {\r\n    version: 0,\r\n    systemId: '',\r\n    kids: null as null | Uint8Array[],\r\n    data: null as null | Uint8Array,\r\n  };\r\n  const view = new DataView(initData);\r\n  const boxSize = view.getUint32(0);\r\n  if (initData.byteLength !== boxSize && boxSize > 44) {\r\n    return null;\r\n  }\r\n  const type = view.getUint32(4);\r\n  if (type !== 0x70737368) {\r\n    return null;\r\n  }\r\n  result.version = view.getUint32(8) >>> 24;\r\n  if (result.version > 1) {\r\n    return null;\r\n  }\r\n  result.systemId = Hex.hexDump(new Uint8Array(initData, 12, 16));\r\n  const dataSizeOrKidCount = view.getUint32(28);\r\n  if (result.version === 0) {\r\n    if (boxSize - 32 < dataSizeOrKidCount) {\r\n      return null;\r\n    }\r\n    result.data = new Uint8Array(initData, 32, dataSizeOrKidCount);\r\n  } else if (result.version === 1) {\r\n    result.kids = [];\r\n    for (let i = 0; i < dataSizeOrKidCount; i++) {\r\n      result.kids.push(new Uint8Array(initData, 32 + i * 16, 16));\r\n    }\r\n  }\r\n  return result;\r\n}\r\n","import AESCrypto from './aes-crypto';\r\nimport FastAESKey from './fast-aes-key';\r\nimport AESDecryptor, { removePadding } from './aes-decryptor';\r\nimport { logger } from '../utils/logger';\r\nimport { appendUint8Array } from '../utils/mp4-tools';\r\nimport { sliceUint8 } from '../utils/typed-array';\r\nimport type { HlsConfig } from '../config';\r\n\r\nconst CHUNK_SIZE = 16; // 16 bytes, 128 bits\r\n\r\nexport default class Decrypter {\r\n  private logEnabled: boolean = true;\r\n  private removePKCS7Padding: boolean;\r\n  private subtle: SubtleCrypto | null = null;\r\n  private softwareDecrypter: AESDecryptor | null = null;\r\n  private key: ArrayBuffer | null = null;\r\n  private fastAesKey: FastAESKey | null = null;\r\n  private remainderData: Uint8Array | null = null;\r\n  private currentIV: ArrayBuffer | null = null;\r\n  private currentResult: ArrayBuffer | null = null;\r\n  private useSoftware: boolean;\r\n\r\n  constructor(config: HlsConfig, { removePKCS7Padding = true } = {}) {\r\n    this.useSoftware = config.enableSoftwareAES;\r\n    this.removePKCS7Padding = removePKCS7Padding;\r\n    // built in decryptor expects PKCS7 padding\r\n    if (removePKCS7Padding) {\r\n      try {\r\n        const browserCrypto = self.crypto;\r\n        if (browserCrypto) {\r\n          this.subtle =\r\n            browserCrypto.subtle ||\r\n            ((browserCrypto as any).webkitSubtle as SubtleCrypto);\r\n        }\r\n      } catch (e) {\r\n        /* no-op */\r\n      }\r\n    }\r\n    if (this.subtle === null) {\r\n      this.useSoftware = true;\r\n    }\r\n  }\r\n\r\n  destroy() {\r\n    this.subtle = null;\r\n    this.softwareDecrypter = null;\r\n    this.key = null;\r\n    this.fastAesKey = null;\r\n    this.remainderData = null;\r\n    this.currentIV = null;\r\n    this.currentResult = null;\r\n  }\r\n\r\n  public isSync() {\r\n    return this.useSoftware;\r\n  }\r\n\r\n  public flush(): Uint8Array | null {\r\n    const { currentResult, remainderData } = this;\r\n    if (!currentResult || remainderData) {\r\n      this.reset();\r\n      return null;\r\n    }\r\n    const data = new Uint8Array(currentResult);\r\n    this.reset();\r\n    if (this.removePKCS7Padding) {\r\n      return removePadding(data);\r\n    }\r\n    return data;\r\n  }\r\n\r\n  public reset() {\r\n    this.currentResult = null;\r\n    this.currentIV = null;\r\n    this.remainderData = null;\r\n    if (this.softwareDecrypter) {\r\n      this.softwareDecrypter = null;\r\n    }\r\n  }\r\n\r\n  public decrypt(\r\n    data: Uint8Array | ArrayBuffer,\r\n    key: ArrayBuffer,\r\n    iv: ArrayBuffer,\r\n  ): Promise<ArrayBuffer> {\r\n    if (this.useSoftware) {\r\n      return new Promise((resolve, reject) => {\r\n        this.softwareDecrypt(new Uint8Array(data), key, iv);\r\n        const decryptResult = this.flush();\r\n        if (decryptResult) {\r\n          resolve(decryptResult.buffer);\r\n        } else {\r\n          reject(new Error('[softwareDecrypt] Failed to decrypt data'));\r\n        }\r\n      });\r\n    }\r\n    return this.webCryptoDecrypt(new Uint8Array(data), key, iv);\r\n  }\r\n\r\n  // Software decryption is progressive. Progressive decryption may not return a result on each call. Any cached\r\n  // data is handled in the flush() call\r\n  public softwareDecrypt(\r\n    data: Uint8Array,\r\n    key: ArrayBuffer,\r\n    iv: ArrayBuffer,\r\n  ): ArrayBuffer | null {\r\n    const { currentIV, currentResult, remainderData } = this;\r\n    this.logOnce('JS AES decrypt');\r\n    // The output is staggered during progressive parsing - the current result is cached, and emitted on the next call\r\n    // This is done in order to strip PKCS7 padding, which is found at the end of each segment. We only know we've reached\r\n    // the end on flush(), but by that time we have already received all bytes for the segment.\r\n    // Progressive decryption does not work with WebCrypto\r\n\r\n    if (remainderData) {\r\n      data = appendUint8Array(remainderData, data);\r\n      this.remainderData = null;\r\n    }\r\n\r\n    // Byte length must be a multiple of 16 (AES-128 = 128 bit blocks = 16 bytes)\r\n    const currentChunk = this.getValidChunk(data);\r\n    if (!currentChunk.length) {\r\n      return null;\r\n    }\r\n\r\n    if (currentIV) {\r\n      iv = currentIV;\r\n    }\r\n\r\n    let softwareDecrypter = this.softwareDecrypter;\r\n    if (!softwareDecrypter) {\r\n      softwareDecrypter = this.softwareDecrypter = new AESDecryptor();\r\n    }\r\n    softwareDecrypter.expandKey(key);\r\n\r\n    const result = currentResult;\r\n\r\n    this.currentResult = softwareDecrypter.decrypt(currentChunk.buffer, 0, iv);\r\n    this.currentIV = sliceUint8(currentChunk, -16).buffer;\r\n\r\n    if (!result) {\r\n      return null;\r\n    }\r\n    return result;\r\n  }\r\n\r\n  public webCryptoDecrypt(\r\n    data: Uint8Array,\r\n    key: ArrayBuffer,\r\n    iv: ArrayBuffer,\r\n  ): Promise<ArrayBuffer> {\r\n    const subtle = this.subtle;\r\n    if (this.key !== key || !this.fastAesKey) {\r\n      this.key = key;\r\n      this.fastAesKey = new FastAESKey(subtle, key);\r\n    }\r\n    return this.fastAesKey\r\n      .expandKey()\r\n      .then((aesKey) => {\r\n        // decrypt using web crypto\r\n        if (!subtle) {\r\n          return Promise.reject(new Error('web crypto not initialized'));\r\n        }\r\n        this.logOnce('WebCrypto AES decrypt');\r\n        const crypto = new AESCrypto(subtle, new Uint8Array(iv));\r\n        return crypto.decrypt(data.buffer, aesKey);\r\n      })\r\n      .catch((err) => {\r\n        logger.warn(\r\n          `[decrypter]: WebCrypto Error, disable WebCrypto API, ${err.name}: ${err.message}`,\r\n        );\r\n\r\n        return this.onWebCryptoError(data, key, iv);\r\n      });\r\n  }\r\n\r\n  private onWebCryptoError(data, key, iv): ArrayBuffer | never {\r\n    this.useSoftware = true;\r\n    this.logEnabled = true;\r\n    this.softwareDecrypt(data, key, iv);\r\n    const decryptResult = this.flush();\r\n    if (decryptResult) {\r\n      return decryptResult.buffer;\r\n    }\r\n    throw new Error('WebCrypto and softwareDecrypt: failed to decrypt data');\r\n  }\r\n\r\n  private getValidChunk(data: Uint8Array): Uint8Array {\r\n    let currentChunk = data;\r\n    const splitPoint = data.length - (data.length % CHUNK_SIZE);\r\n    if (splitPoint !== data.length) {\r\n      currentChunk = sliceUint8(data, 0, splitPoint);\r\n      this.remainderData = sliceUint8(data, splitPoint);\r\n    }\r\n    return currentChunk;\r\n  }\r\n\r\n  private logOnce(msg: string) {\r\n    if (!this.logEnabled) {\r\n      return;\r\n    }\r\n    logger.log(`[decrypter]: ${msg}`);\r\n    this.logEnabled = false;\r\n  }\r\n}\r\n","import type { RationalTimestamp } from '../utils/timescale-conversion';\r\n\r\nexport interface Demuxer {\r\n  demux(\r\n    data: Uint8Array,\r\n    timeOffset: number,\r\n    isSampleAes?: boolean,\r\n    flush?: boolean,\r\n  ): DemuxerResult;\r\n  demuxSampleAes(\r\n    data: Uint8Array,\r\n    keyData: KeyData,\r\n    timeOffset: number,\r\n  ): Promise<DemuxerResult>;\r\n  flush(timeOffset?: number): DemuxerResult | Promise<DemuxerResult>;\r\n  destroy(): void;\r\n  resetInitSegment(\r\n    initSegment: Uint8Array | undefined,\r\n    audioCodec: string | undefined,\r\n    videoCodec: string | undefined,\r\n    trackDuration: number,\r\n  );\r\n  resetTimeStamp(defaultInitPTS?: RationalTimestamp | null): void;\r\n  resetContiguity(): void;\r\n}\r\n\r\nexport interface DemuxerResult {\r\n  audioTrack: DemuxedAudioTrack;\r\n  videoTrack: DemuxedVideoTrackBase;\r\n  id3Track: DemuxedMetadataTrack;\r\n  textTrack: DemuxedUserdataTrack;\r\n}\r\n\r\nexport interface DemuxedTrack {\r\n  type: string;\r\n  id: number;\r\n  pid: number;\r\n  inputTimeScale: number;\r\n  sequenceNumber: number;\r\n  samples:\r\n    | AudioSample[]\r\n    | VideoSample[]\r\n    | MetadataSample[]\r\n    | UserdataSample[]\r\n    | Uint8Array;\r\n  timescale?: number;\r\n  container?: string;\r\n  dropped: number;\r\n  duration?: number;\r\n  pesData?: ElementaryStreamData | null;\r\n  codec?: string;\r\n}\r\n\r\nexport interface PassthroughTrack extends DemuxedTrack {\r\n  sampleDuration: number;\r\n  samples: Uint8Array;\r\n  timescale: number;\r\n  duration: number;\r\n  codec: string;\r\n}\r\nexport interface DemuxedAudioTrack extends DemuxedTrack {\r\n  config?: number[] | Uint8Array;\r\n  samplerate?: number;\r\n  segmentCodec?: string;\r\n  channelCount?: number;\r\n  manifestCodec?: string;\r\n  samples: AudioSample[];\r\n}\r\n\r\nexport interface DemuxedVideoTrackBase extends DemuxedTrack {\r\n  width?: number;\r\n  height?: number;\r\n  pixelRatio?: [number, number];\r\n  audFound?: boolean;\r\n  vps?: Uint8Array[];\r\n  pps?: Uint8Array[];\r\n  sps?: Uint8Array[];\r\n  naluState?: number;\r\n  segmentCodec?: string;\r\n  manifestCodec?: string;\r\n  samples: VideoSample[] | Uint8Array;\r\n  params?: object;\r\n}\r\n\r\nexport interface DemuxedVideoTrack extends DemuxedVideoTrackBase {\r\n  samples: VideoSample[];\r\n}\r\n\r\nexport interface DemuxedMetadataTrack extends DemuxedTrack {\r\n  samples: MetadataSample[];\r\n}\r\n\r\nexport interface DemuxedUserdataTrack extends DemuxedTrack {\r\n  samples: UserdataSample[];\r\n}\r\n\r\nexport const enum MetadataSchema {\r\n  audioId3 = 'org.id3',\r\n  dateRange = 'com.apple.quicktime.HLS',\r\n  emsg = 'https://aomedia.org/emsg/ID3',\r\n}\r\nexport interface MetadataSample {\r\n  pts: number;\r\n  dts: number;\r\n  duration: number;\r\n  len?: number;\r\n  data: Uint8Array;\r\n  type: MetadataSchema;\r\n}\r\n\r\nexport interface UserdataSample {\r\n  pts: number;\r\n  bytes?: Uint8Array;\r\n  type?: number;\r\n  payloadType?: number;\r\n  uuid?: string;\r\n  userData?: string;\r\n  userDataBytes?: Uint8Array;\r\n}\r\n\r\nexport interface VideoSample {\r\n  dts: number;\r\n  pts: number;\r\n  key: boolean;\r\n  frame: boolean;\r\n  units: VideoSampleUnit[];\r\n  debug: string;\r\n  length: number;\r\n}\r\n\r\nexport interface VideoSampleUnit {\r\n  data: Uint8Array;\r\n  type: number;\r\n  state?: number;\r\n}\r\n\r\nexport type AudioSample = {\r\n  unit: Uint8Array;\r\n  pts: number;\r\n};\r\n\r\nexport type AudioFrame = {\r\n  sample: AudioSample;\r\n  length: number;\r\n  missing: number;\r\n};\r\n\r\nexport interface ElementaryStreamData {\r\n  data: Uint8Array[];\r\n  size: number;\r\n}\r\n\r\nexport interface KeyData {\r\n  method: string;\r\n  key: Uint8Array;\r\n  iv: Uint8Array;\r\n}\r\n","import type { DemuxedTrack } from '../types/demuxer';\r\n\r\nexport function dummyTrack(type = '', inputTimeScale = 90000): DemuxedTrack {\r\n  return {\r\n    type,\r\n    id: -1,\r\n    pid: -1,\r\n    inputTimeScale,\r\n    sequenceNumber: -1,\r\n    samples: [],\r\n    dropped: 0,\r\n  };\r\n}\r\n","import * as ID3 from '../id3';\r\nimport {\r\n  DemuxerResult,\r\n  Demuxer,\r\n  DemuxedAudioTrack,\r\n  AudioFrame,\r\n  DemuxedMetadataTrack,\r\n  DemuxedVideoTrackBase,\r\n  DemuxedUserdataTrack,\r\n  KeyData,\r\n  MetadataSchema,\r\n} from '../../types/demuxer';\r\nimport { dummyTrack } from '../dummy-demuxed-track';\r\nimport { appendUint8Array } from '../../utils/mp4-tools';\r\nimport { sliceUint8 } from '../../utils/typed-array';\r\nimport { RationalTimestamp } from '../../utils/timescale-conversion';\r\n\r\nclass BaseAudioDemuxer implements Demuxer {\r\n  protected _audioTrack!: DemuxedAudioTrack;\r\n  protected _id3Track!: DemuxedMetadataTrack;\r\n  protected frameIndex: number = 0;\r\n  protected cachedData: Uint8Array | null = null;\r\n  protected basePTS: number | null = null;\r\n  protected initPTS: RationalTimestamp | null = null;\r\n  protected lastPTS: number | null = null;\r\n\r\n  resetInitSegment(\r\n    initSegment: Uint8Array | undefined,\r\n    audioCodec: string | undefined,\r\n    videoCodec: string | undefined,\r\n    trackDuration: number,\r\n  ) {\r\n    this._id3Track = {\r\n      type: 'id3',\r\n      id: 3,\r\n      pid: -1,\r\n      inputTimeScale: 90000,\r\n      sequenceNumber: 0,\r\n      samples: [],\r\n      dropped: 0,\r\n    };\r\n  }\r\n\r\n  resetTimeStamp(deaultTimestamp: RationalTimestamp | null) {\r\n    this.initPTS = deaultTimestamp;\r\n    this.resetContiguity();\r\n  }\r\n\r\n  resetContiguity(): void {\r\n    this.basePTS = null;\r\n    this.lastPTS = null;\r\n    this.frameIndex = 0;\r\n  }\r\n\r\n  canParse(data: Uint8Array, offset: number): boolean {\r\n    return false;\r\n  }\r\n\r\n  appendFrame(\r\n    track: DemuxedAudioTrack,\r\n    data: Uint8Array,\r\n    offset: number,\r\n  ): AudioFrame | void {}\r\n\r\n  // feed incoming data to the front of the parsing pipeline\r\n  demux(data: Uint8Array, timeOffset: number): DemuxerResult {\r\n    if (this.cachedData) {\r\n      data = appendUint8Array(this.cachedData, data);\r\n      this.cachedData = null;\r\n    }\r\n\r\n    let id3Data: Uint8Array | undefined = ID3.getID3Data(data, 0);\r\n    let offset = id3Data ? id3Data.length : 0;\r\n    let lastDataIndex;\r\n    const track = this._audioTrack;\r\n    const id3Track = this._id3Track;\r\n    const timestamp = id3Data ? ID3.getTimeStamp(id3Data) : undefined;\r\n    const length = data.length;\r\n\r\n    if (\r\n      this.basePTS === null ||\r\n      (this.frameIndex === 0 && Number.isFinite(timestamp))\r\n    ) {\r\n      this.basePTS = initPTSFn(timestamp, timeOffset, this.initPTS);\r\n      this.lastPTS = this.basePTS;\r\n    }\r\n\r\n    if (this.lastPTS === null) {\r\n      this.lastPTS = this.basePTS;\r\n    }\r\n\r\n    // more expressive than alternative: id3Data?.length\r\n    if (id3Data && id3Data.length > 0) {\r\n      id3Track.samples.push({\r\n        pts: this.lastPTS,\r\n        dts: this.lastPTS,\r\n        data: id3Data,\r\n        type: MetadataSchema.audioId3,\r\n        duration: Number.POSITIVE_INFINITY,\r\n      });\r\n    }\r\n\r\n    while (offset < length) {\r\n      if (this.canParse(data, offset)) {\r\n        const frame = this.appendFrame(track, data, offset);\r\n        if (frame) {\r\n          this.frameIndex++;\r\n          this.lastPTS = frame.sample.pts;\r\n          offset += frame.length;\r\n          lastDataIndex = offset;\r\n        } else {\r\n          offset = length;\r\n        }\r\n      } else if (ID3.canParse(data, offset)) {\r\n        // after a ID3.canParse, a call to ID3.getID3Data *should* always returns some data\r\n        id3Data = ID3.getID3Data(data, offset)!;\r\n        id3Track.samples.push({\r\n          pts: this.lastPTS,\r\n          dts: this.lastPTS,\r\n          data: id3Data,\r\n          type: MetadataSchema.audioId3,\r\n          duration: Number.POSITIVE_INFINITY,\r\n        });\r\n        offset += id3Data.length;\r\n        lastDataIndex = offset;\r\n      } else {\r\n        offset++;\r\n      }\r\n      if (offset === length && lastDataIndex !== length) {\r\n        const partialData = sliceUint8(data, lastDataIndex);\r\n        if (this.cachedData) {\r\n          this.cachedData = appendUint8Array(this.cachedData, partialData);\r\n        } else {\r\n          this.cachedData = partialData;\r\n        }\r\n      }\r\n    }\r\n\r\n    return {\r\n      audioTrack: track,\r\n      videoTrack: dummyTrack() as DemuxedVideoTrackBase,\r\n      id3Track,\r\n      textTrack: dummyTrack() as DemuxedUserdataTrack,\r\n    };\r\n  }\r\n\r\n  demuxSampleAes(\r\n    data: Uint8Array,\r\n    keyData: KeyData,\r\n    timeOffset: number,\r\n  ): Promise<DemuxerResult> {\r\n    return Promise.reject(\r\n      new Error(\r\n        `[${this}] This demuxer does not support Sample-AES decryption`,\r\n      ),\r\n    );\r\n  }\r\n\r\n  flush(timeOffset: number): DemuxerResult {\r\n    // Parse cache in case of remaining frames.\r\n    const cachedData = this.cachedData;\r\n    if (cachedData) {\r\n      this.cachedData = null;\r\n      this.demux(cachedData, 0);\r\n    }\r\n\r\n    return {\r\n      audioTrack: this._audioTrack,\r\n      videoTrack: dummyTrack() as DemuxedVideoTrackBase,\r\n      id3Track: this._id3Track,\r\n      textTrack: dummyTrack() as DemuxedUserdataTrack,\r\n    };\r\n  }\r\n\r\n  destroy() {}\r\n}\r\n\r\n/**\r\n * Initialize PTS\r\n * <p>\r\n *    use timestamp unless it is undefined, NaN or Infinity\r\n * </p>\r\n */\r\nexport const initPTSFn = (\r\n  timestamp: number | undefined,\r\n  timeOffset: number,\r\n  initPTS: RationalTimestamp | null,\r\n): number => {\r\n  if (Number.isFinite(timestamp as number)) {\r\n    return timestamp! * 90;\r\n  }\r\n  const init90kHz = initPTS\r\n    ? (initPTS.baseTime * 90000) / initPTS.timescale\r\n    : 0;\r\n  return timeOffset * 90000 + init90kHz;\r\n};\r\nexport default BaseAudioDemuxer;\r\n","/**\r\n * ADTS parser helper\r\n * @link https://wiki.multimedia.cx/index.php?title=ADTS\r\n */\r\nimport { logger } from '../../utils/logger';\r\nimport { ErrorTypes, ErrorDetails } from '../../errors';\r\nimport type { HlsEventEmitter } from '../../events';\r\nimport { Events } from '../../events';\r\nimport type {\r\n  DemuxedAudioTrack,\r\n  AudioFrame,\r\n  AudioSample,\r\n} from '../../types/demuxer';\r\n\r\ntype AudioConfig = {\r\n  config: number[];\r\n  samplerate: number;\r\n  channelCount: number;\r\n  codec: string;\r\n  manifestCodec: string;\r\n};\r\n\r\ntype FrameHeader = {\r\n  headerLength: number;\r\n  frameLength: number;\r\n};\r\n\r\nexport function getAudioConfig(\r\n  observer,\r\n  data: Uint8Array,\r\n  offset: number,\r\n  audioCodec: string,\r\n): AudioConfig | void {\r\n  let adtsObjectType: number;\r\n  let adtsExtensionSamplingIndex: number;\r\n  let adtsChannelConfig: number;\r\n  let config: number[];\r\n  const userAgent = navigator.userAgent.toLowerCase();\r\n  const manifestCodec = audioCodec;\r\n  const adtsSamplingRates = [\r\n    96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025,\r\n    8000, 7350,\r\n  ];\r\n  // byte 2\r\n  adtsObjectType = ((data[offset + 2] & 0xc0) >>> 6) + 1;\r\n  const adtsSamplingIndex = (data[offset + 2] & 0x3c) >>> 2;\r\n  if (adtsSamplingIndex > adtsSamplingRates.length - 1) {\r\n    observer.trigger(Events.ERROR, {\r\n      type: ErrorTypes.MEDIA_ERROR,\r\n      details: ErrorDetails.FRAG_PARSING_ERROR,\r\n      fatal: true,\r\n      reason: `invalid ADTS sampling index:${adtsSamplingIndex}`,\r\n    });\r\n    return;\r\n  }\r\n  adtsChannelConfig = (data[offset + 2] & 0x01) << 2;\r\n  // byte 3\r\n  adtsChannelConfig |= (data[offset + 3] & 0xc0) >>> 6;\r\n  logger.log(\r\n    `manifest codec:${audioCodec}, ADTS type:${adtsObjectType}, samplingIndex:${adtsSamplingIndex}`,\r\n  );\r\n  // firefox: freq less than 24kHz = AAC SBR (HE-AAC)\r\n  if (/firefox/i.test(userAgent)) {\r\n    if (adtsSamplingIndex >= 6) {\r\n      adtsObjectType = 5;\r\n      config = new Array(4);\r\n      // HE-AAC uses SBR (Spectral Band Replication) , high frequencies are constructed from low frequencies\r\n      // there is a factor 2 between frame sample rate and output sample rate\r\n      // multiply frequency by 2 (see table below, equivalent to substract 3)\r\n      adtsExtensionSamplingIndex = adtsSamplingIndex - 3;\r\n    } else {\r\n      adtsObjectType = 2;\r\n      config = new Array(2);\r\n      adtsExtensionSamplingIndex = adtsSamplingIndex;\r\n    }\r\n    // Android : always use AAC\r\n  } else if (userAgent.indexOf('android') !== -1) {\r\n    adtsObjectType = 2;\r\n    config = new Array(2);\r\n    adtsExtensionSamplingIndex = adtsSamplingIndex;\r\n  } else {\r\n    /*  for other browsers (Chrome/Vivaldi/Opera ...)\r\n        always force audio type to be HE-AAC SBR, as some browsers do not support audio codec switch properly (like Chrome ...)\r\n    */\r\n    adtsObjectType = 5;\r\n    config = new Array(4);\r\n    // if (manifest codec is HE-AAC or HE-AACv2) OR (manifest codec not specified AND frequency less than 24kHz)\r\n    if (\r\n      (audioCodec &&\r\n        (audioCodec.indexOf('mp4a.40.29') !== -1 ||\r\n          audioCodec.indexOf('mp4a.40.5') !== -1)) ||\r\n      (!audioCodec && adtsSamplingIndex >= 6)\r\n    ) {\r\n      // HE-AAC uses SBR (Spectral Band Replication) , high frequencies are constructed from low frequencies\r\n      // there is a factor 2 between frame sample rate and output sample rate\r\n      // multiply frequency by 2 (see table below, equivalent to substract 3)\r\n      adtsExtensionSamplingIndex = adtsSamplingIndex - 3;\r\n    } else {\r\n      // if (manifest codec is AAC) AND (frequency less than 24kHz AND nb channel is 1) OR (manifest codec not specified and mono audio)\r\n      // Chrome fails to play back with low frequency AAC LC mono when initialized with HE-AAC.  This is not a problem with stereo.\r\n      if (\r\n        (audioCodec &&\r\n          audioCodec.indexOf('mp4a.40.2') !== -1 &&\r\n          ((adtsSamplingIndex >= 6 && adtsChannelConfig === 1) ||\r\n            /vivaldi/i.test(userAgent))) ||\r\n        (!audioCodec && adtsChannelConfig === 1)\r\n      ) {\r\n        adtsObjectType = 2;\r\n        config = new Array(2);\r\n      }\r\n      adtsExtensionSamplingIndex = adtsSamplingIndex;\r\n    }\r\n  }\r\n  /* refer to http://wiki.multimedia.cx/index.php?title=MPEG-4_Audio#Audio_Specific_Config\r\n      ISO 14496-3 (AAC).pdf - Table 1.13  Syntax of AudioSpecificConfig()\r\n    Audio Profile / Audio Object Type\r\n    0: Null\r\n    1: AAC Main\r\n    2: AAC LC (Low Complexity)\r\n    3: AAC SSR (Scalable Sample Rate)\r\n    4: AAC LTP (Long Term Prediction)\r\n    5: SBR (Spectral Band Replication)\r\n    6: AAC Scalable\r\n   sampling freq\r\n    0: 96000 Hz\r\n    1: 88200 Hz\r\n    2: 64000 Hz\r\n    3: 48000 Hz\r\n    4: 44100 Hz\r\n    5: 32000 Hz\r\n    6: 24000 Hz\r\n    7: 22050 Hz\r\n    8: 16000 Hz\r\n    9: 12000 Hz\r\n    10: 11025 Hz\r\n    11: 8000 Hz\r\n    12: 7350 Hz\r\n    13: Reserved\r\n    14: Reserved\r\n    15: frequency is written explictly\r\n    Channel Configurations\r\n    These are the channel configurations:\r\n    0: Defined in AOT Specifc Config\r\n    1: 1 channel: front-center\r\n    2: 2 channels: front-left, front-right\r\n  */\r\n  // audioObjectType = profile => profile, the MPEG-4 Audio Object Type minus 1\r\n  config[0] = adtsObjectType << 3;\r\n  // samplingFrequencyIndex\r\n  config[0] |= (adtsSamplingIndex & 0x0e) >> 1;\r\n  config[1] |= (adtsSamplingIndex & 0x01) << 7;\r\n  // channelConfiguration\r\n  config[1] |= adtsChannelConfig << 3;\r\n  if (adtsObjectType === 5) {\r\n    // adtsExtensionSamplingIndex\r\n    config[1] |= (adtsExtensionSamplingIndex & 0x0e) >> 1;\r\n    config[2] = (adtsExtensionSamplingIndex & 0x01) << 7;\r\n    // adtsObjectType (force to 2, chrome is checking that object type is less than 5 ???\r\n    //    https://chromium.googlesource.com/chromium/src.git/+/master/media/formats/mp4/aac.cc\r\n    config[2] |= 2 << 2;\r\n    config[3] = 0;\r\n  }\r\n  return {\r\n    config,\r\n    samplerate: adtsSamplingRates[adtsSamplingIndex],\r\n    channelCount: adtsChannelConfig,\r\n    codec: 'mp4a.40.' + adtsObjectType,\r\n    manifestCodec,\r\n  };\r\n}\r\n\r\nexport function isHeaderPattern(data: Uint8Array, offset: number): boolean {\r\n  return data[offset] === 0xff && (data[offset + 1] & 0xf6) === 0xf0;\r\n}\r\n\r\nexport function getHeaderLength(data: Uint8Array, offset: number): number {\r\n  return data[offset + 1] & 0x01 ? 7 : 9;\r\n}\r\n\r\nexport function getFullFrameLength(data: Uint8Array, offset: number): number {\r\n  return (\r\n    ((data[offset + 3] & 0x03) << 11) |\r\n    (data[offset + 4] << 3) |\r\n    ((data[offset + 5] & 0xe0) >>> 5)\r\n  );\r\n}\r\n\r\nexport function canGetFrameLength(data: Uint8Array, offset: number): boolean {\r\n  return offset + 5 < data.length;\r\n}\r\n\r\nexport function isHeader(data: Uint8Array, offset: number): boolean {\r\n  // Look for ADTS header | 1111 1111 | 1111 X00X | where X can be either 0 or 1\r\n  // Layer bits (position 14 and 15) in header should be always 0 for ADTS\r\n  // More info https://wiki.multimedia.cx/index.php?title=ADTS\r\n  return offset + 1 < data.length && isHeaderPattern(data, offset);\r\n}\r\n\r\nexport function canParse(data: Uint8Array, offset: number): boolean {\r\n  return (\r\n    canGetFrameLength(data, offset) &&\r\n    isHeaderPattern(data, offset) &&\r\n    getFullFrameLength(data, offset) <= data.length - offset\r\n  );\r\n}\r\n\r\nexport function probe(data: Uint8Array, offset: number): boolean {\r\n  // same as isHeader but we also check that ADTS frame follows last ADTS frame\r\n  // or end of data is reached\r\n  if (isHeader(data, offset)) {\r\n    // ADTS header Length\r\n    const headerLength = getHeaderLength(data, offset);\r\n    if (offset + headerLength >= data.length) {\r\n      return false;\r\n    }\r\n    // ADTS frame Length\r\n    const frameLength = getFullFrameLength(data, offset);\r\n    if (frameLength <= headerLength) {\r\n      return false;\r\n    }\r\n\r\n    const newOffset = offset + frameLength;\r\n    return newOffset === data.length || isHeader(data, newOffset);\r\n  }\r\n  return false;\r\n}\r\n\r\nexport function initTrackConfig(\r\n  track: DemuxedAudioTrack,\r\n  observer: HlsEventEmitter,\r\n  data: Uint8Array,\r\n  offset: number,\r\n  audioCodec: string,\r\n) {\r\n  if (!track.samplerate) {\r\n    const config = getAudioConfig(observer, data, offset, audioCodec);\r\n    if (!config) {\r\n      return;\r\n    }\r\n    track.config = config.config;\r\n    track.samplerate = config.samplerate;\r\n    track.channelCount = config.channelCount;\r\n    track.codec = config.codec;\r\n    track.manifestCodec = config.manifestCodec;\r\n    logger.log(\r\n      `parsed codec:${track.codec}, rate:${config.samplerate}, channels:${config.channelCount}`,\r\n    );\r\n  }\r\n}\r\n\r\nexport function getFrameDuration(samplerate: number): number {\r\n  return (1024 * 90000) / samplerate;\r\n}\r\n\r\nexport function parseFrameHeader(\r\n  data: Uint8Array,\r\n  offset: number,\r\n): FrameHeader | void {\r\n  // The protection skip bit tells us if we have 2 bytes of CRC data at the end of the ADTS header\r\n  const headerLength = getHeaderLength(data, offset);\r\n  if (offset + headerLength <= data.length) {\r\n    // retrieve frame size\r\n    const frameLength = getFullFrameLength(data, offset) - headerLength;\r\n    if (frameLength > 0) {\r\n      // logger.log(`AAC frame, offset/length/total/pts:${offset+headerLength}/${frameLength}/${data.byteLength}`);\r\n      return { headerLength, frameLength };\r\n    }\r\n  }\r\n}\r\n\r\nexport function appendFrame(\r\n  track: DemuxedAudioTrack,\r\n  data: Uint8Array,\r\n  offset: number,\r\n  pts: number,\r\n  frameIndex: number,\r\n): AudioFrame {\r\n  const frameDuration = getFrameDuration(track.samplerate as number);\r\n  const stamp = pts + frameIndex * frameDuration;\r\n  const header = parseFrameHeader(data, offset);\r\n  let unit: Uint8Array;\r\n  if (header) {\r\n    const { frameLength, headerLength } = header;\r\n    const length = headerLength + frameLength;\r\n    const missing = Math.max(0, offset + length - data.length);\r\n    // logger.log(`AAC frame ${frameIndex}, pts:${stamp} length@offset/total: ${frameLength}@${offset+headerLength}/${data.byteLength} missing: ${missing}`);\r\n    if (missing) {\r\n      unit = new Uint8Array(length - headerLength);\r\n      unit.set(data.subarray(offset + headerLength, data.length), 0);\r\n    } else {\r\n      unit = data.subarray(offset + headerLength, offset + length);\r\n    }\r\n\r\n    const sample: AudioSample = {\r\n      unit,\r\n      pts: stamp,\r\n    };\r\n    if (!missing) {\r\n      track.samples.push(sample as AudioSample);\r\n    }\r\n\r\n    return { sample, length, missing };\r\n  }\r\n  // overflow incomplete header\r\n  const length = data.length - offset;\r\n  unit = new Uint8Array(length);\r\n  unit.set(data.subarray(offset, data.length), 0);\r\n  const sample: AudioSample = {\r\n    unit,\r\n    pts: stamp,\r\n  };\r\n  return { sample, length, missing: -1 };\r\n}\r\n","/**\r\n *  MPEG parser helper\r\n */\r\nimport { DemuxedAudioTrack } from '../../types/demuxer';\r\n\r\nlet chromeVersion: number | null = null;\r\n\r\nconst BitratesMap = [\r\n  32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 32, 48, 56,\r\n  64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 32, 40, 48, 56, 64, 80,\r\n  96, 112, 128, 160, 192, 224, 256, 320, 32, 48, 56, 64, 80, 96, 112, 128, 144,\r\n  160, 176, 192, 224, 256, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144,\r\n  160,\r\n];\r\n\r\nconst SamplingRateMap = [\r\n  44100, 48000, 32000, 22050, 24000, 16000, 11025, 12000, 8000,\r\n];\r\n\r\nconst SamplesCoefficients = [\r\n  // MPEG 2.5\r\n  [\r\n    0, // Reserved\r\n    72, // Layer3\r\n    144, // Layer2\r\n    12, // Layer1\r\n  ],\r\n  // Reserved\r\n  [\r\n    0, // Reserved\r\n    0, // Layer3\r\n    0, // Layer2\r\n    0, // Layer1\r\n  ],\r\n  // MPEG 2\r\n  [\r\n    0, // Reserved\r\n    72, // Layer3\r\n    144, // Layer2\r\n    12, // Layer1\r\n  ],\r\n  // MPEG 1\r\n  [\r\n    0, // Reserved\r\n    144, // Layer3\r\n    144, // Layer2\r\n    12, // Layer1\r\n  ],\r\n];\r\n\r\nconst BytesInSlot = [\r\n  0, // Reserved\r\n  1, // Layer3\r\n  1, // Layer2\r\n  4, // Layer1\r\n];\r\n\r\nexport function appendFrame(\r\n  track: DemuxedAudioTrack,\r\n  data: Uint8Array,\r\n  offset: number,\r\n  pts: number,\r\n  frameIndex: number,\r\n) {\r\n  // Using http://www.datavoyage.com/mpgscript/mpeghdr.htm as a reference\r\n  if (offset + 24 > data.length) {\r\n    return;\r\n  }\r\n\r\n  const header = parseHeader(data, offset);\r\n  if (header && offset + header.frameLength <= data.length) {\r\n    const frameDuration = (header.samplesPerFrame * 90000) / header.sampleRate;\r\n    const stamp = pts + frameIndex * frameDuration;\r\n    const sample = {\r\n      unit: data.subarray(offset, offset + header.frameLength),\r\n      pts: stamp,\r\n      dts: stamp,\r\n    };\r\n\r\n    track.config = [];\r\n    track.channelCount = header.channelCount;\r\n    track.samplerate = header.sampleRate;\r\n    track.samples.push(sample);\r\n\r\n    return { sample, length: header.frameLength, missing: 0 };\r\n  }\r\n}\r\n\r\nexport function parseHeader(data: Uint8Array, offset: number) {\r\n  const mpegVersion = (data[offset + 1] >> 3) & 3;\r\n  const mpegLayer = (data[offset + 1] >> 1) & 3;\r\n  const bitRateIndex = (data[offset + 2] >> 4) & 15;\r\n  const sampleRateIndex = (data[offset + 2] >> 2) & 3;\r\n  if (\r\n    mpegVersion !== 1 &&\r\n    bitRateIndex !== 0 &&\r\n    bitRateIndex !== 15 &&\r\n    sampleRateIndex !== 3\r\n  ) {\r\n    const paddingBit = (data[offset + 2] >> 1) & 1;\r\n    const channelMode = data[offset + 3] >> 6;\r\n    const columnInBitrates =\r\n      mpegVersion === 3 ? 3 - mpegLayer : mpegLayer === 3 ? 3 : 4;\r\n    const bitRate =\r\n      BitratesMap[columnInBitrates * 14 + bitRateIndex - 1] * 1000;\r\n    const columnInSampleRates =\r\n      mpegVersion === 3 ? 0 : mpegVersion === 2 ? 1 : 2;\r\n    const sampleRate =\r\n      SamplingRateMap[columnInSampleRates * 3 + sampleRateIndex];\r\n    const channelCount = channelMode === 3 ? 1 : 2; // If bits of channel mode are `11` then it is a single channel (Mono)\r\n    const sampleCoefficient = SamplesCoefficients[mpegVersion][mpegLayer];\r\n    const bytesInSlot = BytesInSlot[mpegLayer];\r\n    const samplesPerFrame = sampleCoefficient * 8 * bytesInSlot;\r\n    const frameLength =\r\n      Math.floor((sampleCoefficient * bitRate) / sampleRate + paddingBit) *\r\n      bytesInSlot;\r\n\r\n    if (chromeVersion === null) {\r\n      const userAgent = navigator.userAgent || '';\r\n      const result = userAgent.match(/Chrome\\/(\\d+)/i);\r\n      chromeVersion = result ? parseInt(result[1]) : 0;\r\n    }\r\n    const needChromeFix = !!chromeVersion && chromeVersion <= 87;\r\n\r\n    if (\r\n      needChromeFix &&\r\n      mpegLayer === 2 &&\r\n      bitRate >= 224000 &&\r\n      channelMode === 0\r\n    ) {\r\n      // Work around bug in Chromium by setting channelMode to dual-channel (01) instead of stereo (00)\r\n      data[offset + 3] = data[offset + 3] | 0x80;\r\n    }\r\n\r\n    return { sampleRate, channelCount, frameLength, samplesPerFrame };\r\n  }\r\n}\r\n\r\nexport function isHeaderPattern(data: Uint8Array, offset: number): boolean {\r\n  return (\r\n    data[offset] === 0xff &&\r\n    (data[offset + 1] & 0xe0) === 0xe0 &&\r\n    (data[offset + 1] & 0x06) !== 0x00\r\n  );\r\n}\r\n\r\nexport function isHeader(data: Uint8Array, offset: number): boolean {\r\n  // Look for MPEG header | 1111 1111 | 111X XYZX | where X can be either 0 or 1 and Y or Z should be 1\r\n  // Layer bits (position 14 and 15) in header should be always different from 0 (Layer I or Layer II or Layer III)\r\n  // More info http://www.mp3-tech.org/programmer/frame_header.html\r\n  return offset + 1 < data.length && isHeaderPattern(data, offset);\r\n}\r\n\r\nexport function canParse(data: Uint8Array, offset: number): boolean {\r\n  const headerSize = 4;\r\n\r\n  return isHeaderPattern(data, offset) && headerSize <= data.length - offset;\r\n}\r\n\r\nexport function probe(data: Uint8Array, offset: number): boolean {\r\n  // same as isHeader but we also check that MPEG frame follows last MPEG frame\r\n  // or end of data is reached\r\n  if (offset + 1 < data.length && isHeaderPattern(data, offset)) {\r\n    // MPEG header Length\r\n    const headerLength = 4;\r\n    // MPEG frame Length\r\n    const header = parseHeader(data, offset);\r\n    let frameLength = headerLength;\r\n    if (header?.frameLength) {\r\n      frameLength = header.frameLength;\r\n    }\r\n\r\n    const newOffset = offset + frameLength;\r\n    return newOffset === data.length || isHeader(data, newOffset);\r\n  }\r\n  return false;\r\n}\r\n","/**\r\n * AAC demuxer\r\n */\r\nimport BaseAudioDemuxer from './base-audio-demuxer';\r\nimport * as ADTS from './adts';\r\nimport * as MpegAudio from './mpegaudio';\r\nimport { logger } from '../../utils/logger';\r\nimport * as ID3 from '../id3';\r\nimport type { HlsEventEmitter } from '../../events';\r\nimport type { HlsConfig } from '../../config';\r\n\r\nclass AACDemuxer extends BaseAudioDemuxer {\r\n  private readonly observer: HlsEventEmitter;\r\n  private readonly config: HlsConfig;\r\n\r\n  constructor(observer, config) {\r\n    super();\r\n    this.observer = observer;\r\n    this.config = config;\r\n  }\r\n\r\n  resetInitSegment(\r\n    initSegment: Uint8Array | undefined,\r\n    audioCodec: string | undefined,\r\n    videoCodec: string | undefined,\r\n    trackDuration: number,\r\n  ) {\r\n    super.resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration);\r\n    this._audioTrack = {\r\n      container: 'audio/adts',\r\n      type: 'audio',\r\n      id: 2,\r\n      pid: -1,\r\n      sequenceNumber: 0,\r\n      segmentCodec: 'aac',\r\n      samples: [],\r\n      manifestCodec: audioCodec,\r\n      duration: trackDuration,\r\n      inputTimeScale: 90000,\r\n      dropped: 0,\r\n    };\r\n  }\r\n\r\n  // Source for probe info - https://wiki.multimedia.cx/index.php?title=ADTS\r\n  static probe(data: Uint8Array | undefined): boolean {\r\n    if (!data) {\r\n      return false;\r\n    }\r\n\r\n    // Check for the ADTS sync word\r\n    // Look for ADTS header | 1111 1111 | 1111 X00X | where X can be either 0 or 1\r\n    // Layer bits (position 14 and 15) in header should be always 0 for ADTS\r\n    // More info https://wiki.multimedia.cx/index.php?title=ADTS\r\n    const id3Data = ID3.getID3Data(data, 0);\r\n    let offset = id3Data?.length || 0;\r\n\r\n    if (MpegAudio.probe(data, offset)) {\r\n      return false;\r\n    }\r\n\r\n    for (let length = data.length; offset < length; offset++) {\r\n      if (ADTS.probe(data, offset)) {\r\n        logger.log('ADTS sync word found !');\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  canParse(data, offset) {\r\n    return ADTS.canParse(data, offset);\r\n  }\r\n\r\n  appendFrame(track, data, offset) {\r\n    ADTS.initTrackConfig(\r\n      track,\r\n      this.observer,\r\n      data,\r\n      offset,\r\n      track.manifestCodec,\r\n    );\r\n    const frame = ADTS.appendFrame(\r\n      track,\r\n      data,\r\n      offset,\r\n      this.basePTS as number,\r\n      this.frameIndex,\r\n    );\r\n    if (frame && frame.missing === 0) {\r\n      return frame;\r\n    }\r\n  }\r\n}\r\n\r\nexport default AACDemuxer;\r\n","/**\r\n * MP4 demuxer\r\n */\r\nimport {\r\n  Demuxer,\r\n  DemuxerResult,\r\n  PassthroughTrack,\r\n  DemuxedAudioTrack,\r\n  DemuxedUserdataTrack,\r\n  DemuxedMetadataTrack,\r\n  KeyData,\r\n  MetadataSchema,\r\n} from '../types/demuxer';\r\nimport {\r\n  findBox,\r\n  segmentValidRange,\r\n  appendUint8Array,\r\n  parseEmsg,\r\n  parseSamples,\r\n  parseInitSegment,\r\n  RemuxerTrackIdConfig,\r\n} from '../utils/mp4-tools';\r\nimport { dummyTrack } from './dummy-demuxed-track';\r\nimport type { HlsEventEmitter } from '../events';\r\nimport type { HlsConfig } from '../config';\r\n\r\nconst emsgSchemePattern = /\\/emsg[-/]ID3/i;\r\n\r\nclass MP4Demuxer implements Demuxer {\r\n  private remainderData: Uint8Array | null = null;\r\n  private timeOffset: number = 0;\r\n  private config: HlsConfig;\r\n  private videoTrack?: PassthroughTrack;\r\n  private audioTrack?: DemuxedAudioTrack;\r\n  private id3Track?: DemuxedMetadataTrack;\r\n  private txtTrack?: DemuxedUserdataTrack;\r\n\r\n  constructor(observer: HlsEventEmitter, config: HlsConfig) {\r\n    this.config = config;\r\n  }\r\n\r\n  public resetTimeStamp() {}\r\n\r\n  public resetInitSegment(\r\n    initSegment: Uint8Array | undefined,\r\n    audioCodec: string | undefined,\r\n    videoCodec: string | undefined,\r\n    trackDuration: number,\r\n  ) {\r\n    const videoTrack = (this.videoTrack = dummyTrack(\r\n      'video',\r\n      1,\r\n    ) as PassthroughTrack);\r\n    const audioTrack = (this.audioTrack = dummyTrack(\r\n      'audio',\r\n      1,\r\n    ) as DemuxedAudioTrack);\r\n    const captionTrack = (this.txtTrack = dummyTrack(\r\n      'text',\r\n      1,\r\n    ) as DemuxedUserdataTrack);\r\n\r\n    this.id3Track = dummyTrack('id3', 1) as DemuxedMetadataTrack;\r\n    this.timeOffset = 0;\r\n\r\n    if (!initSegment?.byteLength) {\r\n      return;\r\n    }\r\n    const initData = parseInitSegment(initSegment);\r\n\r\n    if (initData.video) {\r\n      const { id, timescale, codec } = initData.video;\r\n      videoTrack.id = id;\r\n      videoTrack.timescale = captionTrack.timescale = timescale;\r\n      videoTrack.codec = codec;\r\n    }\r\n\r\n    if (initData.audio) {\r\n      const { id, timescale, codec } = initData.audio;\r\n      audioTrack.id = id;\r\n      audioTrack.timescale = timescale;\r\n      audioTrack.codec = codec;\r\n    }\r\n\r\n    captionTrack.id = RemuxerTrackIdConfig.text;\r\n    videoTrack.sampleDuration = 0;\r\n    videoTrack.duration = audioTrack.duration = trackDuration;\r\n  }\r\n\r\n  public resetContiguity(): void {\r\n    this.remainderData = null;\r\n  }\r\n\r\n  static probe(data: Uint8Array) {\r\n    // ensure we find a moof box in the first 16 kB\r\n    data = data.length > 16384 ? data.subarray(0, 16384) : data;\r\n    return findBox(data, ['moof']).length > 0;\r\n  }\r\n\r\n  public demux(data: Uint8Array, timeOffset: number): DemuxerResult {\r\n    this.timeOffset = timeOffset;\r\n    // Load all data into the avc track. The CMAF remuxer will look for the data in the samples object; the rest of the fields do not matter\r\n    let videoSamples = data;\r\n    const videoTrack = this.videoTrack as PassthroughTrack;\r\n    const textTrack = this.txtTrack as DemuxedUserdataTrack;\r\n    if (this.config.progressive) {\r\n      // Split the bytestream into two ranges: one encompassing all data up until the start of the last moof, and everything else.\r\n      // This is done to guarantee that we're sending valid data to MSE - when demuxing progressively, we have no guarantee\r\n      // that the fetch loader gives us flush moof+mdat pairs. If we push jagged data to MSE, it will throw an exception.\r\n      if (this.remainderData) {\r\n        videoSamples = appendUint8Array(this.remainderData, data);\r\n      }\r\n      const segmentedData = segmentValidRange(videoSamples);\r\n      this.remainderData = segmentedData.remainder;\r\n      videoTrack.samples = segmentedData.valid || new Uint8Array();\r\n    } else {\r\n      videoTrack.samples = videoSamples;\r\n    }\r\n\r\n    const id3Track = this.extractID3Track(videoTrack, timeOffset);\r\n    textTrack.samples = parseSamples(timeOffset, videoTrack);\r\n\r\n    return {\r\n      videoTrack,\r\n      audioTrack: this.audioTrack as DemuxedAudioTrack,\r\n      id3Track,\r\n      textTrack: this.txtTrack as DemuxedUserdataTrack,\r\n    };\r\n  }\r\n\r\n  public flush() {\r\n    const timeOffset = this.timeOffset;\r\n    const videoTrack = this.videoTrack as PassthroughTrack;\r\n    const textTrack = this.txtTrack as DemuxedUserdataTrack;\r\n    videoTrack.samples = this.remainderData || new Uint8Array();\r\n    this.remainderData = null;\r\n\r\n    const id3Track = this.extractID3Track(videoTrack, this.timeOffset);\r\n    textTrack.samples = parseSamples(timeOffset, videoTrack);\r\n\r\n    return {\r\n      videoTrack,\r\n      audioTrack: dummyTrack() as DemuxedAudioTrack,\r\n      id3Track,\r\n      textTrack: dummyTrack() as DemuxedUserdataTrack,\r\n    };\r\n  }\r\n\r\n  private extractID3Track(\r\n    videoTrack: PassthroughTrack,\r\n    timeOffset: number,\r\n  ): DemuxedMetadataTrack {\r\n    const id3Track = this.id3Track as DemuxedMetadataTrack;\r\n    if (videoTrack.samples.length) {\r\n      const emsgs = findBox(videoTrack.samples, ['emsg']);\r\n      if (emsgs) {\r\n        emsgs.forEach((data: Uint8Array) => {\r\n          const emsgInfo = parseEmsg(data);\r\n          if (emsgSchemePattern.test(emsgInfo.schemeIdUri)) {\r\n            const pts = Number.isFinite(emsgInfo.presentationTime)\r\n              ? emsgInfo.presentationTime! / emsgInfo.timeScale\r\n              : timeOffset +\r\n                emsgInfo.presentationTimeDelta! / emsgInfo.timeScale;\r\n            let duration =\r\n              emsgInfo.eventDuration === 0xffffffff\r\n                ? Number.POSITIVE_INFINITY\r\n                : emsgInfo.eventDuration / emsgInfo.timeScale;\r\n            // Safari takes anything <= 0.001 seconds and maps it to Infinity\r\n            if (duration <= 0.001) {\r\n              duration = Number.POSITIVE_INFINITY;\r\n            }\r\n            const payload = emsgInfo.payload;\r\n            id3Track.samples.push({\r\n              data: payload,\r\n              len: payload.byteLength,\r\n              dts: pts,\r\n              pts: pts,\r\n              type: MetadataSchema.emsg,\r\n              duration: duration,\r\n            });\r\n          }\r\n        });\r\n      }\r\n    }\r\n    return id3Track;\r\n  }\r\n\r\n  demuxSampleAes(\r\n    data: Uint8Array,\r\n    keyData: KeyData,\r\n    timeOffset: number,\r\n  ): Promise<DemuxerResult> {\r\n    return Promise.reject(\r\n      new Error('The MP4 demuxer does not support SAMPLE-AES decryption'),\r\n    );\r\n  }\r\n\r\n  destroy() {}\r\n}\r\n\r\nexport default MP4Demuxer;\r\n","export const getAudioBSID = (data: Uint8Array, offset: number): number => {\r\n  // check the bsid to confirm ac-3 | ec-3\r\n  let bsid = 0;\r\n  let numBits = 5;\r\n  offset += numBits;\r\n  const temp = new Uint32Array(1); // unsigned 32 bit for temporary storage\r\n  const mask = new Uint32Array(1); // unsigned 32 bit mask value\r\n  const byte = new Uint8Array(1); // unsigned 8 bit for temporary storage\r\n  while (numBits > 0) {\r\n    byte[0] = data[offset];\r\n    // read remaining bits, upto 8 bits at a time\r\n    const bits = Math.min(numBits, 8);\r\n    const shift = 8 - bits;\r\n    mask[0] = (0xff000000 >>> (24 + shift)) << shift;\r\n    temp[0] = (byte[0] & mask[0]) >> shift;\r\n    bsid = !bsid ? temp[0] : (bsid << bits) | temp[0];\r\n    offset += 1;\r\n    numBits -= bits;\r\n  }\r\n  return bsid;\r\n};\r\n","import BaseAudioDemuxer from './base-audio-demuxer';\r\nimport { getID3Data, getTimeStamp } from '../id3';\r\nimport { getAudioBSID } from './dolby';\r\nimport type { HlsEventEmitter } from '../../events';\r\nimport type { AudioFrame, DemuxedAudioTrack } from '../../types/demuxer';\r\n\r\nexport class AC3Demuxer extends BaseAudioDemuxer {\r\n  private readonly observer: HlsEventEmitter;\r\n\r\n  constructor(observer) {\r\n    super();\r\n    this.observer = observer;\r\n  }\r\n\r\n  resetInitSegment(\r\n    initSegment: Uint8Array | undefined,\r\n    audioCodec: string | undefined,\r\n    videoCodec: string | undefined,\r\n    trackDuration: number,\r\n  ) {\r\n    super.resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration);\r\n    this._audioTrack = {\r\n      container: 'audio/ac-3',\r\n      type: 'audio',\r\n      id: 2,\r\n      pid: -1,\r\n      sequenceNumber: 0,\r\n      segmentCodec: 'ac3',\r\n      samples: [],\r\n      manifestCodec: audioCodec,\r\n      duration: trackDuration,\r\n      inputTimeScale: 90000,\r\n      dropped: 0,\r\n    };\r\n  }\r\n\r\n  canParse(data: Uint8Array, offset: number): boolean {\r\n    return offset + 64 < data.length;\r\n  }\r\n\r\n  appendFrame(\r\n    track: DemuxedAudioTrack,\r\n    data: Uint8Array,\r\n    offset: number,\r\n  ): AudioFrame | void {\r\n    const frameLength = appendFrame(\r\n      track,\r\n      data,\r\n      offset,\r\n      this.basePTS as number,\r\n      this.frameIndex,\r\n    );\r\n    if (frameLength !== -1) {\r\n      const sample = track.samples[track.samples.length - 1];\r\n      return { sample, length: frameLength, missing: 0 };\r\n    }\r\n  }\r\n\r\n  static probe(data: Uint8Array | undefined): boolean {\r\n    if (!data) {\r\n      return false;\r\n    }\r\n\r\n    const id3Data = getID3Data(data, 0);\r\n    if (!id3Data) {\r\n      return false;\r\n    }\r\n\r\n    // look for the ac-3 sync bytes\r\n    const offset = id3Data.length;\r\n    if (\r\n      data[offset] === 0x0b &&\r\n      data[offset + 1] === 0x77 &&\r\n      getTimeStamp(id3Data) !== undefined &&\r\n      // check the bsid to confirm ac-3\r\n      getAudioBSID(data, offset) < 16\r\n    ) {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n}\r\n\r\nexport function appendFrame(\r\n  track: DemuxedAudioTrack,\r\n  data: Uint8Array,\r\n  start: number,\r\n  pts: number,\r\n  frameIndex: number,\r\n): number {\r\n  if (start + 8 > data.length) {\r\n    return -1; // not enough bytes left\r\n  }\r\n\r\n  if (data[start] !== 0x0b || data[start + 1] !== 0x77) {\r\n    return -1; // invalid magic\r\n  }\r\n\r\n  // get sample rate\r\n  const samplingRateCode = data[start + 4] >> 6;\r\n  if (samplingRateCode >= 3) {\r\n    return -1; // invalid sampling rate\r\n  }\r\n\r\n  const samplingRateMap = [48000, 44100, 32000];\r\n  const sampleRate = samplingRateMap[samplingRateCode];\r\n\r\n  // get frame size\r\n  const frameSizeCode = data[start + 4] & 0x3f;\r\n  const frameSizeMap = [\r\n    64, 69, 96, 64, 70, 96, 80, 87, 120, 80, 88, 120, 96, 104, 144, 96, 105,\r\n    144, 112, 121, 168, 112, 122, 168, 128, 139, 192, 128, 140, 192, 160, 174,\r\n    240, 160, 175, 240, 192, 208, 288, 192, 209, 288, 224, 243, 336, 224, 244,\r\n    336, 256, 278, 384, 256, 279, 384, 320, 348, 480, 320, 349, 480, 384, 417,\r\n    576, 384, 418, 576, 448, 487, 672, 448, 488, 672, 512, 557, 768, 512, 558,\r\n    768, 640, 696, 960, 640, 697, 960, 768, 835, 1152, 768, 836, 1152, 896, 975,\r\n    1344, 896, 976, 1344, 1024, 1114, 1536, 1024, 1115, 1536, 1152, 1253, 1728,\r\n    1152, 1254, 1728, 1280, 1393, 1920, 1280, 1394, 1920,\r\n  ];\r\n\r\n  const frameLength = frameSizeMap[frameSizeCode * 3 + samplingRateCode] * 2;\r\n  if (start + frameLength > data.length) {\r\n    return -1;\r\n  }\r\n\r\n  // get channel count\r\n  const channelMode = data[start + 6] >> 5;\r\n  let skipCount = 0;\r\n  if (channelMode === 2) {\r\n    skipCount += 2;\r\n  } else {\r\n    if (channelMode & 1 && channelMode !== 1) {\r\n      skipCount += 2;\r\n    }\r\n    if (channelMode & 4) {\r\n      skipCount += 2;\r\n    }\r\n  }\r\n\r\n  const lfeon =\r\n    (((data[start + 6] << 8) | data[start + 7]) >> (12 - skipCount)) & 1;\r\n\r\n  const channelsMap = [2, 1, 2, 3, 3, 4, 4, 5];\r\n  const channelCount = channelsMap[channelMode] + lfeon;\r\n\r\n  // build dac3 box\r\n  const bsid = data[start + 5] >> 3;\r\n  const bsmod = data[start + 5] & 7;\r\n\r\n  const config = new Uint8Array([\r\n    (samplingRateCode << 6) | (bsid << 1) | (bsmod >> 2),\r\n    ((bsmod & 3) << 6) |\r\n      (channelMode << 3) |\r\n      (lfeon << 2) |\r\n      (frameSizeCode >> 4),\r\n    (frameSizeCode << 4) & 0xe0,\r\n  ]);\r\n\r\n  const frameDuration = (1536 / sampleRate) * 90000;\r\n  const stamp = pts + frameIndex * frameDuration;\r\n  const unit = data.subarray(start, start + frameLength);\r\n\r\n  track.config = config;\r\n  track.channelCount = channelCount;\r\n  track.samplerate = sampleRate;\r\n  track.samples.push({ unit, pts: stamp });\r\n\r\n  return frameLength;\r\n}\r\n","import type { ParsedVideoSample } from '../tsdemuxer';\r\nimport type {\r\n  DemuxedVideoTrack,\r\n  DemuxedUserdataTrack,\r\n  VideoSample,\r\n  VideoSampleUnit,\r\n} from '../../types/demuxer';\r\nimport type { PES } from '../tsdemuxer';\r\nimport { logger } from '../../utils/logger';\r\nimport { appendUint8Array } from '../../utils/mp4-tools';\r\n\r\nabstract class BaseVideoParser {\r\n  protected VideoSample: ParsedVideoSample | null = null;\r\n\r\n  protected createVideoSample(\r\n    key: boolean,\r\n    pts: number | undefined,\r\n    dts: number | undefined,\r\n    debug: string,\r\n  ): ParsedVideoSample {\r\n    return {\r\n      key,\r\n      frame: false,\r\n      pts,\r\n      dts,\r\n      units: [],\r\n      debug,\r\n      length: 0,\r\n    };\r\n  }\r\n\r\n  protected getLastNalUnit(\r\n    samples: VideoSample[],\r\n  ): VideoSampleUnit | undefined {\r\n    let VideoSample = this.VideoSample;\r\n    let lastUnit: VideoSampleUnit | undefined;\r\n    // try to fallback to previous sample if current one is empty\r\n    if (!VideoSample || VideoSample.units.length === 0) {\r\n      VideoSample = samples[samples.length - 1];\r\n    }\r\n    if (VideoSample?.units) {\r\n      const units = VideoSample.units;\r\n      lastUnit = units[units.length - 1];\r\n    }\r\n    return lastUnit;\r\n  }\r\n\r\n  protected pushAccessUnit(\r\n    VideoSample: ParsedVideoSample,\r\n    videoTrack: DemuxedVideoTrack,\r\n  ) {\r\n    if (VideoSample.units.length && VideoSample.frame) {\r\n      // if sample does not have PTS/DTS, patch with last sample PTS/DTS\r\n      if (VideoSample.pts === undefined) {\r\n        const samples = videoTrack.samples;\r\n        const nbSamples = samples.length;\r\n        if (nbSamples) {\r\n          const lastSample = samples[nbSamples - 1];\r\n          VideoSample.pts = lastSample.pts;\r\n          VideoSample.dts = lastSample.dts;\r\n        } else {\r\n          // dropping samples, no timestamp found\r\n          videoTrack.dropped++;\r\n          return;\r\n        }\r\n      }\r\n      videoTrack.samples.push(VideoSample as VideoSample);\r\n    }\r\n    if (VideoSample.debug.length) {\r\n      logger.log(\r\n        VideoSample.pts + '/' + VideoSample.dts + ':' + VideoSample.debug,\r\n      );\r\n    }\r\n  }\r\n\r\n  abstract parsePES(\r\n    track: DemuxedVideoTrack,\r\n    textTrack: DemuxedUserdataTrack,\r\n    pes: PES,\r\n    last: boolean,\r\n    duration: number,\r\n  );\r\n\r\n  protected abstract getNALuType(data: Uint8Array, offset: number): number;\r\n\r\n  protected parseNALu(\r\n    track: DemuxedVideoTrack,\r\n    array: Uint8Array,\r\n  ): Array<{\r\n    data: Uint8Array;\r\n    type: number;\r\n    state?: number;\r\n  }> {\r\n    const len = array.byteLength;\r\n    let state = track.naluState || 0;\r\n    const lastState = state;\r\n    const units: VideoSampleUnit[] = [];\r\n    let i = 0;\r\n    let value: number;\r\n    let overflow: number;\r\n    let unitType: number;\r\n    let lastUnitStart = -1;\r\n    let lastUnitType: number = 0;\r\n    // logger.log('PES:' + Hex.hexDump(array));\r\n\r\n    if (state === -1) {\r\n      // special use case where we found 3 or 4-byte start codes exactly at the end of previous PES packet\r\n      lastUnitStart = 0;\r\n      // NALu type is value read from offset 0\r\n      lastUnitType = this.getNALuType(array, 0);\r\n      state = 0;\r\n      i = 1;\r\n    }\r\n\r\n    while (i < len) {\r\n      value = array[i++];\r\n      // optimization. state 0 and 1 are the predominant case. let's handle them outside of the switch/case\r\n      if (!state) {\r\n        state = value ? 0 : 1;\r\n        continue;\r\n      }\r\n      if (state === 1) {\r\n        state = value ? 0 : 2;\r\n        continue;\r\n      }\r\n      // here we have state either equal to 2 or 3\r\n      if (!value) {\r\n        state = 3;\r\n      } else if (value === 1) {\r\n        overflow = i - state - 1;\r\n        if (lastUnitStart >= 0) {\r\n          const unit: VideoSampleUnit = {\r\n            data: array.subarray(lastUnitStart, overflow),\r\n            type: lastUnitType,\r\n          };\r\n          // logger.log('pushing NALU, type/size:' + unit.type + '/' + unit.data.byteLength);\r\n          units.push(unit);\r\n        } else {\r\n          // lastUnitStart is undefined => this is the first start code found in this PES packet\r\n          // first check if start code delimiter is overlapping between 2 PES packets,\r\n          // ie it started in last packet (lastState not zero)\r\n          // and ended at the beginning of this PES packet (i <= 4 - lastState)\r\n          const lastUnit = this.getLastNalUnit(track.samples);\r\n          if (lastUnit) {\r\n            if (lastState && i <= 4 - lastState) {\r\n              // start delimiter overlapping between PES packets\r\n              // strip start delimiter bytes from the end of last NAL unit\r\n              // check if lastUnit had a state different from zero\r\n              if (lastUnit.state) {\r\n                // strip last bytes\r\n                lastUnit.data = lastUnit.data.subarray(\r\n                  0,\r\n                  lastUnit.data.byteLength - lastState,\r\n                );\r\n              }\r\n            }\r\n            // If NAL units are not starting right at the beginning of the PES packet, push preceding data into previous NAL unit.\r\n\r\n            if (overflow > 0) {\r\n              // logger.log('first NALU found with overflow:' + overflow);\r\n              lastUnit.data = appendUint8Array(\r\n                lastUnit.data,\r\n                array.subarray(0, overflow),\r\n              );\r\n              lastUnit.state = 0;\r\n            }\r\n          }\r\n        }\r\n        // check if we can read unit type\r\n        if (i < len) {\r\n          unitType = this.getNALuType(array, i);\r\n          // logger.log('find NALU @ offset:' + i + ',type:' + unitType);\r\n          lastUnitStart = i;\r\n          lastUnitType = unitType;\r\n          state = 0;\r\n        } else {\r\n          // not enough byte to read unit type. let's read it on next PES parsing\r\n          state = -1;\r\n        }\r\n      } else {\r\n        state = 0;\r\n      }\r\n    }\r\n    if (lastUnitStart >= 0 && state >= 0) {\r\n      const unit: VideoSampleUnit = {\r\n        data: array.subarray(lastUnitStart, len),\r\n        type: lastUnitType,\r\n        state: state,\r\n      };\r\n      units.push(unit);\r\n      // logger.log('pushing NALU, type/size/state:' + unit.type + '/' + unit.data.byteLength + '/' + state);\r\n    }\r\n    // no NALu found\r\n    if (units.length === 0) {\r\n      // append pes.data to previous NAL unit\r\n      const lastUnit = this.getLastNalUnit(track.samples);\r\n      if (lastUnit) {\r\n        lastUnit.data = appendUint8Array(lastUnit.data, array);\r\n      }\r\n    }\r\n    track.naluState = state;\r\n    return units;\r\n  }\r\n}\r\n\r\nexport default BaseVideoParser;\r\n","/**\r\n * Parser for exponential Golomb codes, a variable-bitwidth number encoding scheme used by h264.\r\n */\r\n\r\nimport { logger } from '../../utils/logger';\r\n\r\nclass ExpGolomb {\r\n  private data: Uint8Array;\r\n  public bytesAvailable: number;\r\n  private word: number;\r\n  private bitsAvailable: number;\r\n\r\n  constructor(data: Uint8Array) {\r\n    this.data = data;\r\n    // the number of bytes left to examine in this.data\r\n    this.bytesAvailable = data.byteLength;\r\n    // the current word being examined\r\n    this.word = 0; // :uint\r\n    // the number of bits left to examine in the current word\r\n    this.bitsAvailable = 0; // :uint\r\n  }\r\n\r\n  // ():void\r\n  loadWord(): void {\r\n    const data = this.data;\r\n    const bytesAvailable = this.bytesAvailable;\r\n    const position = data.byteLength - bytesAvailable;\r\n    const workingBytes = new Uint8Array(4);\r\n    const availableBytes = Math.min(4, bytesAvailable);\r\n    if (availableBytes === 0) {\r\n      throw new Error('no bytes available');\r\n    }\r\n\r\n    workingBytes.set(data.subarray(position, position + availableBytes));\r\n    this.word = new DataView(workingBytes.buffer).getUint32(0);\r\n    // track the amount of this.data that has been processed\r\n    this.bitsAvailable = availableBytes * 8;\r\n    this.bytesAvailable -= availableBytes;\r\n  }\r\n\r\n  // (count:int):void\r\n  skipBits(count: number): void {\r\n    let skipBytes; // :int\r\n    count = Math.min(count, this.bytesAvailable * 8 + this.bitsAvailable);\r\n    if (this.bitsAvailable > count) {\r\n      this.word <<= count;\r\n      this.bitsAvailable -= count;\r\n    } else {\r\n      count -= this.bitsAvailable;\r\n      skipBytes = count >> 3;\r\n      count -= skipBytes << 3;\r\n      this.bytesAvailable -= skipBytes;\r\n      this.loadWord();\r\n      this.word <<= count;\r\n      this.bitsAvailable -= count;\r\n    }\r\n  }\r\n\r\n  // (size:int):uint\r\n  readBits(size: number): number {\r\n    let bits = Math.min(this.bitsAvailable, size); // :uint\r\n    const valu = this.word >>> (32 - bits); // :uint\r\n    if (size > 32) {\r\n      logger.error('Cannot read more than 32 bits at a time');\r\n    }\r\n\r\n    this.bitsAvailable -= bits;\r\n    if (this.bitsAvailable > 0) {\r\n      this.word <<= bits;\r\n    } else if (this.bytesAvailable > 0) {\r\n      this.loadWord();\r\n    } else {\r\n      throw new Error('no bits available');\r\n    }\r\n\r\n    bits = size - bits;\r\n    if (bits > 0 && this.bitsAvailable) {\r\n      return (valu << bits) | this.readBits(bits);\r\n    } else {\r\n      return valu;\r\n    }\r\n  }\r\n\r\n  // ():uint\r\n  skipLZ(): number {\r\n    let leadingZeroCount; // :uint\r\n    for (\r\n      leadingZeroCount = 0;\r\n      leadingZeroCount < this.bitsAvailable;\r\n      ++leadingZeroCount\r\n    ) {\r\n      if ((this.word & (0x80000000 >>> leadingZeroCount)) !== 0) {\r\n        // the first bit of working word is 1\r\n        this.word <<= leadingZeroCount;\r\n        this.bitsAvailable -= leadingZeroCount;\r\n        return leadingZeroCount;\r\n      }\r\n    }\r\n    // we exhausted word and still have not found a 1\r\n    this.loadWord();\r\n    return leadingZeroCount + this.skipLZ();\r\n  }\r\n\r\n  // ():void\r\n  skipUEG(): void {\r\n    this.skipBits(1 + this.skipLZ());\r\n  }\r\n\r\n  // ():void\r\n  skipEG(): void {\r\n    this.skipBits(1 + this.skipLZ());\r\n  }\r\n\r\n  // ():uint\r\n  readUEG(): number {\r\n    const clz = this.skipLZ(); // :uint\r\n    return this.readBits(clz + 1) - 1;\r\n  }\r\n\r\n  // ():int\r\n  readEG(): number {\r\n    const valu = this.readUEG(); // :int\r\n    if (0x01 & valu) {\r\n      // the number is odd if the low order bit is set\r\n      return (1 + valu) >>> 1; // add 1 to make it even, and divide by 2\r\n    } else {\r\n      return -1 * (valu >>> 1); // divide by two then make it negative\r\n    }\r\n  }\r\n\r\n  // Some convenience functions\r\n  // :Boolean\r\n  readBoolean(): boolean {\r\n    return this.readBits(1) === 1;\r\n  }\r\n\r\n  // ():int\r\n  readUByte(): number {\r\n    return this.readBits(8);\r\n  }\r\n\r\n  // ():int\r\n  readUShort(): number {\r\n    return this.readBits(16);\r\n  }\r\n\r\n  // ():int\r\n  readUInt(): number {\r\n    return this.readBits(32);\r\n  }\r\n}\r\n\r\nexport default ExpGolomb;\r\n","import BaseVideoParser from './base-video-parser';\r\nimport type {\r\n  DemuxedVideoTrack,\r\n  DemuxedUserdataTrack,\r\n} from '../../types/demuxer';\r\nimport { parseSEIMessageFromNALu } from '../../utils/mp4-tools';\r\n\r\nimport type { PES } from '../tsdemuxer';\r\n\r\nimport ExpGolomb from './exp-golomb';\r\n\r\nclass AvcVideoParser extends BaseVideoParser {\r\n  public parsePES(\r\n    track: DemuxedVideoTrack,\r\n    textTrack: DemuxedUserdataTrack,\r\n    pes: PES,\r\n    last: boolean,\r\n    duration: number,\r\n  ) {\r\n    const units = this.parseNALu(track, pes.data);\r\n    const debug = false;\r\n    let VideoSample = this.VideoSample;\r\n    let push: boolean;\r\n    let spsfound = false;\r\n    // free pes.data to save up some memory\r\n    (pes as any).data = null;\r\n\r\n    // if new NAL units found and last sample still there, let's push ...\r\n    // this helps parsing streams with missing AUD (only do this if AUD never found)\r\n    if (VideoSample && units.length && !track.audFound) {\r\n      this.pushAccessUnit(VideoSample, track);\r\n      VideoSample = this.VideoSample = this.createVideoSample(\r\n        false,\r\n        pes.pts,\r\n        pes.dts,\r\n        '',\r\n      );\r\n    }\r\n\r\n    units.forEach((unit) => {\r\n      switch (unit.type) {\r\n        // NDR\r\n        case 1: {\r\n          let iskey = false;\r\n          push = true;\r\n          const data = unit.data;\r\n          // only check slice type to detect KF in case SPS found in same packet (any keyframe is preceded by SPS ...)\r\n          if (spsfound && data.length > 4) {\r\n            // retrieve slice type by parsing beginning of NAL unit (follow H264 spec, slice_header definition) to detect keyframe embedded in NDR\r\n            const sliceType = this.readSliceType(data);\r\n            // 2 : I slice, 4 : SI slice, 7 : I slice, 9: SI slice\r\n            // SI slice : A slice that is coded using intra prediction only and using quantisation of the prediction samples.\r\n            // An SI slice can be coded such that its decoded samples can be constructed identically to an SP slice.\r\n            // I slice: A slice that is not an SI slice that is decoded using intra prediction only.\r\n            // if (sliceType === 2 || sliceType === 7) {\r\n            if (\r\n              sliceType === 2 ||\r\n              sliceType === 4 ||\r\n              sliceType === 7 ||\r\n              sliceType === 9\r\n            ) {\r\n              iskey = true;\r\n            }\r\n          }\r\n\r\n          if (iskey) {\r\n            // if we have non-keyframe data already, that cannot belong to the same frame as a keyframe, so force a push\r\n            if (VideoSample?.frame && !VideoSample.key) {\r\n              this.pushAccessUnit(VideoSample, track);\r\n              VideoSample = this.VideoSample = null;\r\n            }\r\n          }\r\n\r\n          if (!VideoSample) {\r\n            VideoSample = this.VideoSample = this.createVideoSample(\r\n              true,\r\n              pes.pts,\r\n              pes.dts,\r\n              '',\r\n            );\r\n          }\r\n\r\n          if (debug) {\r\n            VideoSample.debug += 'NDR ';\r\n          }\r\n\r\n          VideoSample.frame = true;\r\n          VideoSample.key = iskey;\r\n\r\n          break;\r\n          // IDR\r\n        }\r\n        case 5:\r\n          push = true;\r\n          // handle PES not starting with AUD\r\n          // if we have frame data already, that cannot belong to the same frame, so force a push\r\n          if (VideoSample?.frame && !VideoSample.key) {\r\n            this.pushAccessUnit(VideoSample, track);\r\n            VideoSample = this.VideoSample = null;\r\n          }\r\n          if (!VideoSample) {\r\n            VideoSample = this.VideoSample = this.createVideoSample(\r\n              true,\r\n              pes.pts,\r\n              pes.dts,\r\n              '',\r\n            );\r\n          }\r\n\r\n          if (debug) {\r\n            VideoSample.debug += 'IDR ';\r\n          }\r\n\r\n          VideoSample.key = true;\r\n          VideoSample.frame = true;\r\n          break;\r\n        // SEI\r\n        case 6: {\r\n          push = true;\r\n          if (debug && VideoSample) {\r\n            VideoSample.debug += 'SEI ';\r\n          }\r\n          parseSEIMessageFromNALu(\r\n            unit.data,\r\n            1,\r\n            pes.pts as number,\r\n            textTrack.samples,\r\n          );\r\n          break;\r\n          // SPS\r\n        }\r\n        case 7: {\r\n          push = true;\r\n          spsfound = true;\r\n          if (debug && VideoSample) {\r\n            VideoSample.debug += 'SPS ';\r\n          }\r\n          const sps = unit.data;\r\n          const config = this.readSPS(sps);\r\n          if (\r\n            !track.sps ||\r\n            track.width !== config.width ||\r\n            track.height !== config.height ||\r\n            track.pixelRatio?.[0] !== config.pixelRatio[0] ||\r\n            track.pixelRatio?.[1] !== config.pixelRatio[1]\r\n          ) {\r\n            track.width = config.width;\r\n            track.height = config.height;\r\n            track.pixelRatio = config.pixelRatio;\r\n            track.sps = [sps];\r\n            track.duration = duration;\r\n            const codecarray = sps.subarray(1, 4);\r\n            let codecstring = 'avc1.';\r\n            for (let i = 0; i < 3; i++) {\r\n              let h = codecarray[i].toString(16);\r\n              if (h.length < 2) {\r\n                h = '0' + h;\r\n              }\r\n\r\n              codecstring += h;\r\n            }\r\n            track.codec = codecstring;\r\n          }\r\n          break;\r\n        }\r\n        // PPS\r\n        case 8:\r\n          push = true;\r\n          if (debug && VideoSample) {\r\n            VideoSample.debug += 'PPS ';\r\n          }\r\n\r\n          track.pps = [unit.data];\r\n\r\n          break;\r\n        // AUD\r\n        case 9:\r\n          push = true;\r\n          track.audFound = true;\r\n          if (VideoSample) {\r\n            this.pushAccessUnit(VideoSample, track);\r\n          }\r\n\r\n          VideoSample = this.VideoSample = this.createVideoSample(\r\n            false,\r\n            pes.pts,\r\n            pes.dts,\r\n            debug ? 'AUD ' : '',\r\n          );\r\n          break;\r\n        // Filler Data\r\n        case 12:\r\n          push = true;\r\n          break;\r\n        default:\r\n          push = false;\r\n          if (VideoSample) {\r\n            VideoSample.debug += 'unknown NAL ' + unit.type + ' ';\r\n          }\r\n\r\n          break;\r\n      }\r\n      if (VideoSample && push) {\r\n        const units = VideoSample.units;\r\n        units.push(unit);\r\n      }\r\n    });\r\n    // if last PES packet, push samples\r\n    if (last && VideoSample) {\r\n      this.pushAccessUnit(VideoSample, track);\r\n      this.VideoSample = null;\r\n    }\r\n  }\r\n\r\n  protected getNALuType(data: Uint8Array, offset: number): number {\r\n    return data[offset] & 0x1f;\r\n  }\r\n\r\n  readSliceType(data: Uint8Array) {\r\n    const eg = new ExpGolomb(data);\r\n    // skip NALu type\r\n    eg.readUByte();\r\n    // discard first_mb_in_slice\r\n    eg.readUEG();\r\n    // return slice_type\r\n    return eg.readUEG();\r\n  }\r\n\r\n  /**\r\n   * The scaling list is optionally transmitted as part of a sequence parameter\r\n   * set and is not relevant to transmuxing.\r\n   * @param count the number of entries in this scaling list\r\n   * @see Recommendation ITU-T H.264, Section 7.3.2.1.1.1\r\n   */\r\n  skipScalingList(count: number, reader: ExpGolomb): void {\r\n    let lastScale = 8;\r\n    let nextScale = 8;\r\n    let deltaScale;\r\n    for (let j = 0; j < count; j++) {\r\n      if (nextScale !== 0) {\r\n        deltaScale = reader.readEG();\r\n        nextScale = (lastScale + deltaScale + 256) % 256;\r\n      }\r\n      lastScale = nextScale === 0 ? lastScale : nextScale;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Read a sequence parameter set and return some interesting video\r\n   * properties. A sequence parameter set is the H264 metadata that\r\n   * describes the properties of upcoming video frames.\r\n   * @returns an object with configuration parsed from the\r\n   * sequence parameter set, including the dimensions of the\r\n   * associated video frames.\r\n   */\r\n  readSPS(sps: Uint8Array): {\r\n    width: number;\r\n    height: number;\r\n    pixelRatio: [number, number];\r\n  } {\r\n    const eg = new ExpGolomb(sps);\r\n    let frameCropLeftOffset = 0;\r\n    let frameCropRightOffset = 0;\r\n    let frameCropTopOffset = 0;\r\n    let frameCropBottomOffset = 0;\r\n    let numRefFramesInPicOrderCntCycle;\r\n    let scalingListCount;\r\n    let i;\r\n    const readUByte = eg.readUByte.bind(eg);\r\n    const readBits = eg.readBits.bind(eg);\r\n    const readUEG = eg.readUEG.bind(eg);\r\n    const readBoolean = eg.readBoolean.bind(eg);\r\n    const skipBits = eg.skipBits.bind(eg);\r\n    const skipEG = eg.skipEG.bind(eg);\r\n    const skipUEG = eg.skipUEG.bind(eg);\r\n    const skipScalingList = this.skipScalingList.bind(this);\r\n\r\n    readUByte();\r\n    const profileIdc = readUByte(); // profile_idc\r\n    readBits(5); // profileCompat constraint_set[0-4]_flag, u(5)\r\n    skipBits(3); // reserved_zero_3bits u(3),\r\n    readUByte(); // level_idc u(8)\r\n    skipUEG(); // seq_parameter_set_id\r\n    // some profiles have more optional data we don't need\r\n    if (\r\n      profileIdc === 100 ||\r\n      profileIdc === 110 ||\r\n      profileIdc === 122 ||\r\n      profileIdc === 244 ||\r\n      profileIdc === 44 ||\r\n      profileIdc === 83 ||\r\n      profileIdc === 86 ||\r\n      profileIdc === 118 ||\r\n      profileIdc === 128\r\n    ) {\r\n      const chromaFormatIdc = readUEG();\r\n      if (chromaFormatIdc === 3) {\r\n        skipBits(1);\r\n      } // separate_colour_plane_flag\r\n\r\n      skipUEG(); // bit_depth_luma_minus8\r\n      skipUEG(); // bit_depth_chroma_minus8\r\n      skipBits(1); // qpprime_y_zero_transform_bypass_flag\r\n      if (readBoolean()) {\r\n        // seq_scaling_matrix_present_flag\r\n        scalingListCount = chromaFormatIdc !== 3 ? 8 : 12;\r\n        for (i = 0; i < scalingListCount; i++) {\r\n          if (readBoolean()) {\r\n            // seq_scaling_list_present_flag[ i ]\r\n            if (i < 6) {\r\n              skipScalingList(16, eg);\r\n            } else {\r\n              skipScalingList(64, eg);\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n    skipUEG(); // log2_max_frame_num_minus4\r\n    const picOrderCntType = readUEG();\r\n    if (picOrderCntType === 0) {\r\n      readUEG(); // log2_max_pic_order_cnt_lsb_minus4\r\n    } else if (picOrderCntType === 1) {\r\n      skipBits(1); // delta_pic_order_always_zero_flag\r\n      skipEG(); // offset_for_non_ref_pic\r\n      skipEG(); // offset_for_top_to_bottom_field\r\n      numRefFramesInPicOrderCntCycle = readUEG();\r\n      for (i = 0; i < numRefFramesInPicOrderCntCycle; i++) {\r\n        skipEG();\r\n      } // offset_for_ref_frame[ i ]\r\n    }\r\n    skipUEG(); // max_num_ref_frames\r\n    skipBits(1); // gaps_in_frame_num_value_allowed_flag\r\n    const picWidthInMbsMinus1 = readUEG();\r\n    const picHeightInMapUnitsMinus1 = readUEG();\r\n    const frameMbsOnlyFlag = readBits(1);\r\n    if (frameMbsOnlyFlag === 0) {\r\n      skipBits(1);\r\n    } // mb_adaptive_frame_field_flag\r\n\r\n    skipBits(1); // direct_8x8_inference_flag\r\n    if (readBoolean()) {\r\n      // frame_cropping_flag\r\n      frameCropLeftOffset = readUEG();\r\n      frameCropRightOffset = readUEG();\r\n      frameCropTopOffset = readUEG();\r\n      frameCropBottomOffset = readUEG();\r\n    }\r\n    let pixelRatio: [number, number] = [1, 1];\r\n    if (readBoolean()) {\r\n      // vui_parameters_present_flag\r\n      if (readBoolean()) {\r\n        // aspect_ratio_info_present_flag\r\n        const aspectRatioIdc = readUByte();\r\n        switch (aspectRatioIdc) {\r\n          case 1:\r\n            pixelRatio = [1, 1];\r\n            break;\r\n          case 2:\r\n            pixelRatio = [12, 11];\r\n            break;\r\n          case 3:\r\n            pixelRatio = [10, 11];\r\n            break;\r\n          case 4:\r\n            pixelRatio = [16, 11];\r\n            break;\r\n          case 5:\r\n            pixelRatio = [40, 33];\r\n            break;\r\n          case 6:\r\n            pixelRatio = [24, 11];\r\n            break;\r\n          case 7:\r\n            pixelRatio = [20, 11];\r\n            break;\r\n          case 8:\r\n            pixelRatio = [32, 11];\r\n            break;\r\n          case 9:\r\n            pixelRatio = [80, 33];\r\n            break;\r\n          case 10:\r\n            pixelRatio = [18, 11];\r\n            break;\r\n          case 11:\r\n            pixelRatio = [15, 11];\r\n            break;\r\n          case 12:\r\n            pixelRatio = [64, 33];\r\n            break;\r\n          case 13:\r\n            pixelRatio = [160, 99];\r\n            break;\r\n          case 14:\r\n            pixelRatio = [4, 3];\r\n            break;\r\n          case 15:\r\n            pixelRatio = [3, 2];\r\n            break;\r\n          case 16:\r\n            pixelRatio = [2, 1];\r\n            break;\r\n          case 255: {\r\n            pixelRatio = [\r\n              (readUByte() << 8) | readUByte(),\r\n              (readUByte() << 8) | readUByte(),\r\n            ];\r\n            break;\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return {\r\n      width: Math.ceil(\r\n        (picWidthInMbsMinus1 + 1) * 16 -\r\n          frameCropLeftOffset * 2 -\r\n          frameCropRightOffset * 2,\r\n      ),\r\n      height:\r\n        (2 - frameMbsOnlyFlag) * (picHeightInMapUnitsMinus1 + 1) * 16 -\r\n        (frameMbsOnlyFlag ? 2 : 4) *\r\n          (frameCropTopOffset + frameCropBottomOffset),\r\n      pixelRatio: pixelRatio,\r\n    };\r\n  }\r\n}\r\n\r\nexport default AvcVideoParser;\r\n","import BaseVideoParser from './base-video-parser';\r\nimport { DemuxedVideoTrack, DemuxedUserdataTrack } from '../../types/demuxer';\r\nimport { parseSEIMessageFromNALu } from '../../utils/mp4-tools';\r\n\r\nimport type { PES } from '../tsdemuxer';\r\n\r\nimport ExpGolomb from './exp-golomb';\r\n\r\nclass HevcVideoParser extends BaseVideoParser {\r\n  protected initVPS: Uint8Array | null = null;\r\n\r\n  public parsePES(\r\n    track: DemuxedVideoTrack,\r\n    textTrack: DemuxedUserdataTrack,\r\n    pes: PES,\r\n    last: boolean,\r\n    duration: number,\r\n  ) {\r\n    const units = this.parseNALu(track, pes.data);\r\n    const debug = false;\r\n    let VideoSample = this.VideoSample;\r\n    let push: boolean;\r\n    let spsfound = false;\r\n    // free pes.data to save up some memory\r\n    (pes as any).data = null;\r\n\r\n    // if new NAL units found and last sample still there, let's push ...\r\n    // this helps parsing streams with missing AUD (only do this if AUD never found)\r\n    if (VideoSample && units.length && !track.audFound) {\r\n      this.pushAccessUnit(VideoSample, track);\r\n      VideoSample = this.VideoSample = this.createVideoSample(\r\n        false,\r\n        pes.pts,\r\n        pes.dts,\r\n        '',\r\n      );\r\n    }\r\n\r\n    units.forEach((unit) => {\r\n      switch (unit.type) {\r\n        // NON-IDR, NON RANDOM ACCESS SLICE\r\n        case 0:\r\n        case 1:\r\n        case 2:\r\n        case 3:\r\n        case 4:\r\n        case 5:\r\n        case 6:\r\n        case 7:\r\n        case 8:\r\n        case 9:\r\n          if (!VideoSample) {\r\n            VideoSample = this.VideoSample = this.createVideoSample(\r\n              false,\r\n              pes.pts,\r\n              pes.dts,\r\n              '',\r\n            );\r\n          }\r\n          if (debug) {\r\n            VideoSample.debug += 'NDR ';\r\n          }\r\n          VideoSample.frame = true;\r\n          push = true;\r\n          break;\r\n\r\n        // CRA, BLA (random access picture)\r\n        case 16:\r\n        case 17:\r\n        case 18:\r\n        case 21:\r\n          push = true;\r\n          if (spsfound) {\r\n            // handle PES not starting with AUD\r\n            // if we have frame data already, that cannot belong to the same frame, so force a push\r\n            if (VideoSample?.frame && !VideoSample.key) {\r\n              this.pushAccessUnit(VideoSample, track);\r\n              VideoSample = this.VideoSample = null;\r\n            }\r\n          }\r\n          if (!VideoSample) {\r\n            VideoSample = this.VideoSample = this.createVideoSample(\r\n              true,\r\n              pes.pts,\r\n              pes.dts,\r\n              '',\r\n            );\r\n          }\r\n\r\n          if (debug) {\r\n            VideoSample.debug += 'RAP ';\r\n          }\r\n\r\n          VideoSample.key = true;\r\n          VideoSample.frame = true;\r\n          break;\r\n\r\n        // IDR\r\n        case 19:\r\n        case 20:\r\n          push = true;\r\n          // handle PES not starting with AUD\r\n          // if we have frame data already, that cannot belong to the same frame, so force a push\r\n          if (VideoSample?.frame && !VideoSample.key) {\r\n            this.pushAccessUnit(VideoSample, track);\r\n            VideoSample = this.VideoSample = null;\r\n          }\r\n          if (!VideoSample) {\r\n            VideoSample = this.VideoSample = this.createVideoSample(\r\n              true,\r\n              pes.pts,\r\n              pes.dts,\r\n              '',\r\n            );\r\n          }\r\n\r\n          if (debug) {\r\n            VideoSample.debug += 'IDR ';\r\n          }\r\n          VideoSample.key = true;\r\n          VideoSample.frame = true;\r\n          break;\r\n\r\n        // SEI\r\n        case 39:\r\n          push = true;\r\n          if (debug && VideoSample) {\r\n            VideoSample.debug += 'SEI ';\r\n          }\r\n          parseSEIMessageFromNALu(\r\n            unit.data,\r\n            2, // NALu header size\r\n            pes.pts as number,\r\n            textTrack.samples,\r\n          );\r\n          break;\r\n\r\n        // VPS\r\n        case 32:\r\n          push = true;\r\n          if (debug && VideoSample) {\r\n            VideoSample.debug += 'VPS ';\r\n          }\r\n          if (!track.vps) {\r\n            const config = this.readVPS(unit.data);\r\n            track.params = { ...config };\r\n            this.initVPS = unit.data;\r\n          }\r\n          track.vps = [unit.data];\r\n          break;\r\n\r\n        // SPS\r\n        case 33:\r\n          push = true;\r\n          spsfound = true;\r\n          if (debug && VideoSample) {\r\n            VideoSample.debug += 'SPS ';\r\n          }\r\n          if (typeof track.params === 'object') {\r\n            if (\r\n              track.vps !== undefined &&\r\n              track.vps[0] !== this.initVPS &&\r\n              track.sps !== undefined &&\r\n              !this.matchSPS(track.sps[0], unit.data)\r\n            ) {\r\n              this.initVPS = track.vps[0];\r\n              track.sps = track.pps = undefined;\r\n            }\r\n            if (!track.sps) {\r\n              const config = this.readSPS(unit.data);\r\n              track.width = config.width;\r\n              track.height = config.height;\r\n              track.pixelRatio = config.pixelRatio;\r\n              track.duration = duration;\r\n              track.codec = config.codecString;\r\n              track.sps = [];\r\n              for (const prop in config.params) {\r\n                track.params[prop] = config.params[prop];\r\n              }\r\n            }\r\n            if (track.vps !== undefined && track.vps[0] === this.initVPS) {\r\n              track.sps.push(unit.data);\r\n            }\r\n          }\r\n          if (!VideoSample) {\r\n            VideoSample = this.VideoSample = this.createVideoSample(\r\n              true,\r\n              pes.pts,\r\n              pes.dts,\r\n              '',\r\n            );\r\n          }\r\n          VideoSample.key = true;\r\n          break;\r\n\r\n        // PPS\r\n        case 34:\r\n          push = true;\r\n          if (debug && VideoSample) {\r\n            VideoSample.debug += 'PPS ';\r\n          }\r\n          if (typeof track.params === 'object') {\r\n            if (!track.pps) {\r\n              track.pps = [];\r\n              const config = this.readPPS(unit.data);\r\n              for (const prop in config) {\r\n                track.params[prop] = config[prop];\r\n              }\r\n            }\r\n            if (this.initVPS !== null || track.pps.length === 0) {\r\n              track.pps.push(unit.data);\r\n            }\r\n          }\r\n          break;\r\n\r\n        // ACCESS UNIT DELIMITER\r\n        case 35:\r\n          push = true;\r\n          track.audFound = true;\r\n          if (VideoSample) {\r\n            this.pushAccessUnit(VideoSample, track);\r\n          }\r\n          VideoSample = this.VideoSample = this.createVideoSample(\r\n            false,\r\n            pes.pts,\r\n            pes.dts,\r\n            debug ? 'AUD ' : '',\r\n          );\r\n          break;\r\n\r\n        default:\r\n          push = false;\r\n          if (VideoSample) {\r\n            VideoSample.debug += 'unknown or irrelevant NAL ' + unit.type + ' ';\r\n          }\r\n          break;\r\n      }\r\n      if (VideoSample && push) {\r\n        const units = VideoSample.units;\r\n        units.push(unit);\r\n      }\r\n    });\r\n    // if last PES packet, push samples\r\n    if (last && VideoSample) {\r\n      this.pushAccessUnit(VideoSample, track);\r\n      this.VideoSample = null;\r\n    }\r\n  }\r\n\r\n  protected getNALuType(data: Uint8Array, offset: number): number {\r\n    return (data[offset] & 0x7e) >>> 1;\r\n  }\r\n\r\n  protected ebsp2rbsp(arr: Uint8Array): Uint8Array {\r\n    const dst = new Uint8Array(arr.byteLength);\r\n    let dstIdx = 0;\r\n    for (let i = 0; i < arr.byteLength; i++) {\r\n      if (i >= 2) {\r\n        // Unescape: Skip 0x03 after 00 00\r\n        if (arr[i] === 0x03 && arr[i - 1] === 0x00 && arr[i - 2] === 0x00) {\r\n          continue;\r\n        }\r\n      }\r\n      dst[dstIdx] = arr[i];\r\n      dstIdx++;\r\n    }\r\n    return new Uint8Array(dst.buffer, 0, dstIdx);\r\n  }\r\n\r\n  readVPS(vps: Uint8Array): {\r\n    numTemporalLayers: number;\r\n    temporalIdNested: boolean;\r\n  } {\r\n    const eg = new ExpGolomb(vps);\r\n    // remove header\r\n    eg.readUByte();\r\n    eg.readUByte();\r\n\r\n    eg.readBits(4); // video_parameter_set_id\r\n    eg.skipBits(2);\r\n    eg.readBits(6); // max_layers_minus1\r\n    const max_sub_layers_minus1 = eg.readBits(3);\r\n    const temporal_id_nesting_flag = eg.readBoolean();\r\n    // ...vui fps can be here, but empty fps value is not critical for metadata\r\n\r\n    return {\r\n      numTemporalLayers: max_sub_layers_minus1 + 1,\r\n      temporalIdNested: temporal_id_nesting_flag,\r\n    };\r\n  }\r\n\r\n  readSPS(sps: Uint8Array): {\r\n    codecString: string;\r\n    params: object;\r\n    width: number;\r\n    height: number;\r\n    pixelRatio: [number, number];\r\n  } {\r\n    const eg = new ExpGolomb(this.ebsp2rbsp(sps));\r\n    eg.readUByte();\r\n    eg.readUByte();\r\n\r\n    eg.readBits(4); //video_parameter_set_id\r\n    const max_sub_layers_minus1 = eg.readBits(3);\r\n    eg.readBoolean(); // temporal_id_nesting_flag\r\n\r\n    // profile_tier_level\r\n    const general_profile_space = eg.readBits(2);\r\n    const general_tier_flag = eg.readBoolean();\r\n    const general_profile_idc = eg.readBits(5);\r\n    const general_profile_compatibility_flags_1 = eg.readUByte();\r\n    const general_profile_compatibility_flags_2 = eg.readUByte();\r\n    const general_profile_compatibility_flags_3 = eg.readUByte();\r\n    const general_profile_compatibility_flags_4 = eg.readUByte();\r\n    const general_constraint_indicator_flags_1 = eg.readUByte();\r\n    const general_constraint_indicator_flags_2 = eg.readUByte();\r\n    const general_constraint_indicator_flags_3 = eg.readUByte();\r\n    const general_constraint_indicator_flags_4 = eg.readUByte();\r\n    const general_constraint_indicator_flags_5 = eg.readUByte();\r\n    const general_constraint_indicator_flags_6 = eg.readUByte();\r\n    const general_level_idc = eg.readUByte();\r\n    const sub_layer_profile_present_flags: boolean[] = [];\r\n    const sub_layer_level_present_flags: boolean[] = [];\r\n    for (let i = 0; i < max_sub_layers_minus1; i++) {\r\n      sub_layer_profile_present_flags.push(eg.readBoolean());\r\n      sub_layer_level_present_flags.push(eg.readBoolean());\r\n    }\r\n    if (max_sub_layers_minus1 > 0) {\r\n      for (let i = max_sub_layers_minus1; i < 8; i++) {\r\n        eg.readBits(2);\r\n      }\r\n    }\r\n    for (let i = 0; i < max_sub_layers_minus1; i++) {\r\n      if (sub_layer_profile_present_flags[i]) {\r\n        eg.readUByte(); // sub_layer_profile_space, sub_layer_tier_flag, sub_layer_profile_idc\r\n        eg.readUByte();\r\n        eg.readUByte();\r\n        eg.readUByte();\r\n        eg.readUByte(); // sub_layer_profile_compatibility_flag\r\n        eg.readUByte();\r\n        eg.readUByte();\r\n        eg.readUByte();\r\n        eg.readUByte();\r\n        eg.readUByte();\r\n        eg.readUByte();\r\n      }\r\n      if (sub_layer_level_present_flags[i]) {\r\n        eg.readUByte();\r\n      }\r\n    }\r\n\r\n    eg.readUEG(); // seq_parameter_set_id\r\n    const chroma_format_idc = eg.readUEG();\r\n    if (chroma_format_idc == 3) {\r\n      eg.skipBits(1); //separate_colour_plane_flag\r\n    }\r\n    const pic_width_in_luma_samples = eg.readUEG();\r\n    const pic_height_in_luma_samples = eg.readUEG();\r\n    const conformance_window_flag = eg.readBoolean();\r\n    let pic_left_offset = 0,\r\n      pic_right_offset = 0,\r\n      pic_top_offset = 0,\r\n      pic_bottom_offset = 0;\r\n    if (conformance_window_flag) {\r\n      pic_left_offset += eg.readUEG();\r\n      pic_right_offset += eg.readUEG();\r\n      pic_top_offset += eg.readUEG();\r\n      pic_bottom_offset += eg.readUEG();\r\n    }\r\n    const bit_depth_luma_minus8 = eg.readUEG();\r\n    const bit_depth_chroma_minus8 = eg.readUEG();\r\n    const log2_max_pic_order_cnt_lsb_minus4 = eg.readUEG();\r\n    const sub_layer_ordering_info_present_flag = eg.readBoolean();\r\n    for (\r\n      let i = sub_layer_ordering_info_present_flag ? 0 : max_sub_layers_minus1;\r\n      i <= max_sub_layers_minus1;\r\n      i++\r\n    ) {\r\n      eg.skipUEG(); // max_dec_pic_buffering_minus1[i]\r\n      eg.skipUEG(); // max_num_reorder_pics[i]\r\n      eg.skipUEG(); // max_latency_increase_plus1[i]\r\n    }\r\n    eg.skipUEG(); // log2_min_luma_coding_block_size_minus3\r\n    eg.skipUEG(); // log2_diff_max_min_luma_coding_block_size\r\n    eg.skipUEG(); // log2_min_transform_block_size_minus2\r\n    eg.skipUEG(); // log2_diff_max_min_transform_block_size\r\n    eg.skipUEG(); // max_transform_hierarchy_depth_inter\r\n    eg.skipUEG(); // max_transform_hierarchy_depth_intra\r\n    const scaling_list_enabled_flag = eg.readBoolean();\r\n    if (scaling_list_enabled_flag) {\r\n      const sps_scaling_list_data_present_flag = eg.readBoolean();\r\n      if (sps_scaling_list_data_present_flag) {\r\n        for (let sizeId = 0; sizeId < 4; sizeId++) {\r\n          for (\r\n            let matrixId = 0;\r\n            matrixId < (sizeId === 3 ? 2 : 6);\r\n            matrixId++\r\n          ) {\r\n            const scaling_list_pred_mode_flag = eg.readBoolean();\r\n            if (!scaling_list_pred_mode_flag) {\r\n              eg.readUEG(); // scaling_list_pred_matrix_id_delta\r\n            } else {\r\n              const coefNum = Math.min(64, 1 << (4 + (sizeId << 1)));\r\n              if (sizeId > 1) {\r\n                eg.readEG();\r\n              }\r\n              for (let i = 0; i < coefNum; i++) {\r\n                eg.readEG();\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    eg.readBoolean(); // amp_enabled_flag\r\n    eg.readBoolean(); // sample_adaptive_offset_enabled_flag\r\n    const pcm_enabled_flag = eg.readBoolean();\r\n    if (pcm_enabled_flag) {\r\n      eg.readUByte();\r\n      eg.skipUEG();\r\n      eg.skipUEG();\r\n      eg.readBoolean();\r\n    }\r\n    const num_short_term_ref_pic_sets = eg.readUEG();\r\n    let num_delta_pocs = 0;\r\n    for (let i = 0; i < num_short_term_ref_pic_sets; i++) {\r\n      let inter_ref_pic_set_prediction_flag = false;\r\n      if (i !== 0) {\r\n        inter_ref_pic_set_prediction_flag = eg.readBoolean();\r\n      }\r\n      if (inter_ref_pic_set_prediction_flag) {\r\n        if (i === num_short_term_ref_pic_sets) {\r\n          eg.readUEG();\r\n        }\r\n        eg.readBoolean();\r\n        eg.readUEG();\r\n        let next_num_delta_pocs = 0;\r\n        for (let j = 0; j <= num_delta_pocs; j++) {\r\n          const used_by_curr_pic_flag = eg.readBoolean();\r\n          let use_delta_flag = false;\r\n          if (!used_by_curr_pic_flag) {\r\n            use_delta_flag = eg.readBoolean();\r\n          }\r\n          if (used_by_curr_pic_flag || use_delta_flag) {\r\n            next_num_delta_pocs++;\r\n          }\r\n        }\r\n        num_delta_pocs = next_num_delta_pocs;\r\n      } else {\r\n        const num_negative_pics = eg.readUEG();\r\n        const num_positive_pics = eg.readUEG();\r\n        num_delta_pocs = num_negative_pics + num_positive_pics;\r\n        for (let j = 0; j < num_negative_pics; j++) {\r\n          eg.readUEG();\r\n          eg.readBoolean();\r\n        }\r\n        for (let j = 0; j < num_positive_pics; j++) {\r\n          eg.readUEG();\r\n          eg.readBoolean();\r\n        }\r\n      }\r\n    }\r\n\r\n    const long_term_ref_pics_present_flag = eg.readBoolean();\r\n    if (long_term_ref_pics_present_flag) {\r\n      const num_long_term_ref_pics_sps = eg.readUEG();\r\n      for (let i = 0; i < num_long_term_ref_pics_sps; i++) {\r\n        for (let j = 0; j < log2_max_pic_order_cnt_lsb_minus4 + 4; j++) {\r\n          eg.readBits(1);\r\n        }\r\n        eg.readBits(1);\r\n      }\r\n    }\r\n\r\n    let min_spatial_segmentation_idc = 0;\r\n    let sar_width = 1,\r\n      sar_height = 1;\r\n    let fps_fixed = true,\r\n      fps_den = 1,\r\n      fps_num = 0;\r\n    eg.readBoolean(); // sps_temporal_mvp_enabled_flag\r\n    eg.readBoolean(); // strong_intra_smoothing_enabled_flag\r\n    let default_display_window_flag = false;\r\n    const vui_parameters_present_flag = eg.readBoolean();\r\n    if (vui_parameters_present_flag) {\r\n      const aspect_ratio_info_present_flag = eg.readBoolean();\r\n      if (aspect_ratio_info_present_flag) {\r\n        const aspect_ratio_idc = eg.readUByte();\r\n        const sar_width_table = [\r\n          1, 12, 10, 16, 40, 24, 20, 32, 80, 18, 15, 64, 160, 4, 3, 2,\r\n        ];\r\n        const sar_height_table = [\r\n          1, 11, 11, 11, 33, 11, 11, 11, 33, 11, 11, 33, 99, 3, 2, 1,\r\n        ];\r\n        if (aspect_ratio_idc > 0 && aspect_ratio_idc < 16) {\r\n          sar_width = sar_width_table[aspect_ratio_idc - 1];\r\n          sar_height = sar_height_table[aspect_ratio_idc - 1];\r\n        } else if (aspect_ratio_idc === 255) {\r\n          sar_width = eg.readBits(16);\r\n          sar_height = eg.readBits(16);\r\n        }\r\n      }\r\n      const overscan_info_present_flag = eg.readBoolean();\r\n      if (overscan_info_present_flag) {\r\n        eg.readBoolean();\r\n      }\r\n      const video_signal_type_present_flag = eg.readBoolean();\r\n      if (video_signal_type_present_flag) {\r\n        eg.readBits(3);\r\n        eg.readBoolean();\r\n        const colour_description_present_flag = eg.readBoolean();\r\n        if (colour_description_present_flag) {\r\n          eg.readUByte();\r\n          eg.readUByte();\r\n          eg.readUByte();\r\n        }\r\n      }\r\n      const chroma_loc_info_present_flag = eg.readBoolean();\r\n      if (chroma_loc_info_present_flag) {\r\n        eg.readUEG();\r\n        eg.readUEG();\r\n      }\r\n      eg.readBoolean(); // neutral_chroma_indication_flag\r\n      eg.readBoolean(); // field_seq_flag\r\n      eg.readBoolean(); // frame_field_info_present_flag\r\n      default_display_window_flag = eg.readBoolean();\r\n      if (default_display_window_flag) {\r\n        pic_left_offset += eg.readUEG();\r\n        pic_right_offset += eg.readUEG();\r\n        pic_top_offset += eg.readUEG();\r\n        pic_bottom_offset += eg.readUEG();\r\n      }\r\n      const vui_timing_info_present_flag = eg.readBoolean();\r\n      if (vui_timing_info_present_flag) {\r\n        fps_den = eg.readBits(32);\r\n        fps_num = eg.readBits(32);\r\n        const vui_poc_proportional_to_timing_flag = eg.readBoolean();\r\n        if (vui_poc_proportional_to_timing_flag) {\r\n          eg.readUEG();\r\n        }\r\n        const vui_hrd_parameters_present_flag = eg.readBoolean();\r\n        if (vui_hrd_parameters_present_flag) {\r\n          //const commonInfPresentFlag = true;\r\n          //if (commonInfPresentFlag) {\r\n          const nal_hrd_parameters_present_flag = eg.readBoolean();\r\n          const vcl_hrd_parameters_present_flag = eg.readBoolean();\r\n          let sub_pic_hrd_params_present_flag = false;\r\n          if (\r\n            nal_hrd_parameters_present_flag ||\r\n            vcl_hrd_parameters_present_flag\r\n          ) {\r\n            sub_pic_hrd_params_present_flag = eg.readBoolean();\r\n            if (sub_pic_hrd_params_present_flag) {\r\n              eg.readUByte();\r\n              eg.readBits(5);\r\n              eg.readBoolean();\r\n              eg.readBits(5);\r\n            }\r\n            eg.readBits(4); // bit_rate_scale\r\n            eg.readBits(4); // cpb_size_scale\r\n            if (sub_pic_hrd_params_present_flag) {\r\n              eg.readBits(4);\r\n            }\r\n            eg.readBits(5);\r\n            eg.readBits(5);\r\n            eg.readBits(5);\r\n          }\r\n          //}\r\n          for (let i = 0; i <= max_sub_layers_minus1; i++) {\r\n            fps_fixed = eg.readBoolean(); // fixed_pic_rate_general_flag\r\n            const fixed_pic_rate_within_cvs_flag =\r\n              fps_fixed || eg.readBoolean();\r\n            let low_delay_hrd_flag = false;\r\n            if (fixed_pic_rate_within_cvs_flag) {\r\n              eg.readEG();\r\n            } else {\r\n              low_delay_hrd_flag = eg.readBoolean();\r\n            }\r\n            const cpb_cnt = low_delay_hrd_flag ? 1 : eg.readUEG() + 1;\r\n            if (nal_hrd_parameters_present_flag) {\r\n              for (let j = 0; j < cpb_cnt; j++) {\r\n                eg.readUEG();\r\n                eg.readUEG();\r\n                if (sub_pic_hrd_params_present_flag) {\r\n                  eg.readUEG();\r\n                  eg.readUEG();\r\n                }\r\n                eg.skipBits(1);\r\n              }\r\n            }\r\n            if (vcl_hrd_parameters_present_flag) {\r\n              for (let j = 0; j < cpb_cnt; j++) {\r\n                eg.readUEG();\r\n                eg.readUEG();\r\n                if (sub_pic_hrd_params_present_flag) {\r\n                  eg.readUEG();\r\n                  eg.readUEG();\r\n                }\r\n                eg.skipBits(1);\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n      const bitstream_restriction_flag = eg.readBoolean();\r\n      if (bitstream_restriction_flag) {\r\n        eg.readBoolean(); // tiles_fixed_structure_flag\r\n        eg.readBoolean(); // motion_vectors_over_pic_boundaries_flag\r\n        eg.readBoolean(); // restricted_ref_pic_lists_flag\r\n        min_spatial_segmentation_idc = eg.readUEG();\r\n      }\r\n    }\r\n\r\n    let width = pic_width_in_luma_samples,\r\n      height = pic_height_in_luma_samples;\r\n    if (conformance_window_flag || default_display_window_flag) {\r\n      let chroma_scale_w = 1,\r\n        chroma_scale_h = 1;\r\n      if (chroma_format_idc === 1) {\r\n        // YUV 420\r\n        chroma_scale_w = chroma_scale_h = 2;\r\n      } else if (chroma_format_idc == 2) {\r\n        // YUV 422\r\n        chroma_scale_w = 2;\r\n      }\r\n      width =\r\n        pic_width_in_luma_samples -\r\n        chroma_scale_w * pic_right_offset -\r\n        chroma_scale_w * pic_left_offset;\r\n      height =\r\n        pic_height_in_luma_samples -\r\n        chroma_scale_h * pic_bottom_offset -\r\n        chroma_scale_h * pic_top_offset;\r\n    }\r\n\r\n    const profile_space_string = general_profile_space\r\n      ? ['A', 'B', 'C'][general_profile_space]\r\n      : '';\r\n    const profile_compatibility_buf =\r\n      (general_profile_compatibility_flags_1 << 24) |\r\n      (general_profile_compatibility_flags_2 << 16) |\r\n      (general_profile_compatibility_flags_3 << 8) |\r\n      general_profile_compatibility_flags_4;\r\n    let profile_compatibility_rev = 0;\r\n    for (let i = 0; i < 32; i++) {\r\n      profile_compatibility_rev =\r\n        (profile_compatibility_rev |\r\n          (((profile_compatibility_buf >> i) & 1) << (31 - i))) >>>\r\n        0; // reverse bit position (and cast as UInt32)\r\n    }\r\n    let profile_compatibility_flags_string =\r\n      profile_compatibility_rev.toString(16);\r\n    if (\r\n      general_profile_idc === 1 &&\r\n      profile_compatibility_flags_string === '2'\r\n    ) {\r\n      profile_compatibility_flags_string = '6';\r\n    }\r\n    const tier_flag_string = general_tier_flag ? 'H' : 'L';\r\n\r\n    return {\r\n      codecString: `hvc1.${profile_space_string}${general_profile_idc}.${profile_compatibility_flags_string}.${tier_flag_string}${general_level_idc}.B0`,\r\n      params: {\r\n        general_tier_flag,\r\n        general_profile_idc,\r\n        general_profile_space,\r\n        general_profile_compatibility_flags: [\r\n          general_profile_compatibility_flags_1,\r\n          general_profile_compatibility_flags_2,\r\n          general_profile_compatibility_flags_3,\r\n          general_profile_compatibility_flags_4,\r\n        ],\r\n        general_constraint_indicator_flags: [\r\n          general_constraint_indicator_flags_1,\r\n          general_constraint_indicator_flags_2,\r\n          general_constraint_indicator_flags_3,\r\n          general_constraint_indicator_flags_4,\r\n          general_constraint_indicator_flags_5,\r\n          general_constraint_indicator_flags_6,\r\n        ],\r\n        general_level_idc,\r\n        bit_depth: bit_depth_luma_minus8 + 8,\r\n        bit_depth_luma_minus8,\r\n        bit_depth_chroma_minus8,\r\n        min_spatial_segmentation_idc,\r\n        chroma_format_idc: chroma_format_idc,\r\n        frame_rate: {\r\n          fixed: fps_fixed,\r\n          fps: fps_num / fps_den,\r\n        },\r\n      },\r\n      width,\r\n      height,\r\n      pixelRatio: [sar_width, sar_height],\r\n    };\r\n  }\r\n\r\n  readPPS(pps: Uint8Array): {\r\n    parallelismType: number;\r\n  } {\r\n    const eg = new ExpGolomb(this.ebsp2rbsp(pps));\r\n    eg.readUByte();\r\n    eg.readUByte();\r\n    eg.skipUEG(); // pic_parameter_set_id\r\n    eg.skipUEG(); // seq_parameter_set_id\r\n    eg.skipBits(2); // dependent_slice_segments_enabled_flag, output_flag_present_flag\r\n    eg.skipBits(3); // num_extra_slice_header_bits\r\n    eg.skipBits(2); // sign_data_hiding_enabled_flag, cabac_init_present_flag\r\n    eg.skipUEG();\r\n    eg.skipUEG();\r\n    eg.skipEG(); // init_qp_minus26\r\n    eg.skipBits(2); // constrained_intra_pred_flag, transform_skip_enabled_flag\r\n    const cu_qp_delta_enabled_flag = eg.readBoolean();\r\n    if (cu_qp_delta_enabled_flag) {\r\n      eg.skipUEG();\r\n    }\r\n    eg.skipEG(); // cb_qp_offset\r\n    eg.skipEG(); // cr_qp_offset\r\n    eg.skipBits(4); // pps_slice_chroma_qp_offsets_present_flag, weighted_pred_flag, weighted_bipred_flag, transquant_bypass_enabled_flag\r\n    const tiles_enabled_flag = eg.readBoolean();\r\n    const entropy_coding_sync_enabled_flag = eg.readBoolean();\r\n    let parallelismType = 1; // slice-based parallel decoding\r\n    if (entropy_coding_sync_enabled_flag && tiles_enabled_flag) {\r\n      parallelismType = 0; // mixed-type parallel decoding\r\n    } else if (entropy_coding_sync_enabled_flag) {\r\n      parallelismType = 3; // wavefront-based parallel decoding\r\n    } else if (tiles_enabled_flag) {\r\n      parallelismType = 2; // tile-based parallel decoding\r\n    }\r\n\r\n    return {\r\n      parallelismType,\r\n    };\r\n  }\r\n\r\n  matchSPS(sps1: Uint8Array, sps2: Uint8Array): boolean {\r\n    // compare without headers and VPS related params\r\n    return (\r\n      String.fromCharCode.apply(null, sps1).substr(3) ===\r\n      String.fromCharCode.apply(null, sps2).substr(3)\r\n    );\r\n  }\r\n}\r\n\r\nexport default HevcVideoParser;\r\n","/**\r\n * SAMPLE-AES decrypter\r\n */\r\n\r\nimport { HlsConfig } from '../config';\r\nimport Decrypter from '../crypt/decrypter';\r\nimport { HlsEventEmitter } from '../events';\r\nimport type {\r\n  AudioSample,\r\n  VideoSample,\r\n  VideoSampleUnit,\r\n  DemuxedVideoTrackBase,\r\n  KeyData,\r\n} from '../types/demuxer';\r\nimport { discardEPB } from '../utils/mp4-tools';\r\n\r\nclass SampleAesDecrypter {\r\n  private keyData: KeyData;\r\n  private decrypter: Decrypter;\r\n\r\n  constructor(observer: HlsEventEmitter, config: HlsConfig, keyData: KeyData) {\r\n    this.keyData = keyData;\r\n    this.decrypter = new Decrypter(config, {\r\n      removePKCS7Padding: false,\r\n    });\r\n  }\r\n\r\n  decryptBuffer(encryptedData: Uint8Array | ArrayBuffer): Promise<ArrayBuffer> {\r\n    return this.decrypter.decrypt(\r\n      encryptedData,\r\n      this.keyData.key.buffer,\r\n      this.keyData.iv.buffer,\r\n    );\r\n  }\r\n\r\n  // AAC - encrypt all full 16 bytes blocks starting from offset 16\r\n  private decryptAacSample(\r\n    samples: AudioSample[],\r\n    sampleIndex: number,\r\n    callback: () => void,\r\n  ) {\r\n    const curUnit = samples[sampleIndex].unit;\r\n    if (curUnit.length <= 16) {\r\n      // No encrypted portion in this sample (first 16 bytes is not\r\n      // encrypted, see https://developer.apple.com/library/archive/documentation/AudioVideo/Conceptual/HLS_Sample_Encryption/Encryption/Encryption.html),\r\n      return;\r\n    }\r\n    const encryptedData = curUnit.subarray(\r\n      16,\r\n      curUnit.length - (curUnit.length % 16),\r\n    );\r\n    const encryptedBuffer = encryptedData.buffer.slice(\r\n      encryptedData.byteOffset,\r\n      encryptedData.byteOffset + encryptedData.length,\r\n    );\r\n\r\n    this.decryptBuffer(encryptedBuffer).then((decryptedBuffer: ArrayBuffer) => {\r\n      const decryptedData = new Uint8Array(decryptedBuffer);\r\n      curUnit.set(decryptedData, 16);\r\n\r\n      if (!this.decrypter.isSync()) {\r\n        this.decryptAacSamples(samples, sampleIndex + 1, callback);\r\n      }\r\n    });\r\n  }\r\n\r\n  decryptAacSamples(\r\n    samples: AudioSample[],\r\n    sampleIndex: number,\r\n    callback: () => void,\r\n  ) {\r\n    for (; ; sampleIndex++) {\r\n      if (sampleIndex >= samples.length) {\r\n        callback();\r\n        return;\r\n      }\r\n\r\n      if (samples[sampleIndex].unit.length < 32) {\r\n        continue;\r\n      }\r\n\r\n      this.decryptAacSample(samples, sampleIndex, callback);\r\n\r\n      if (!this.decrypter.isSync()) {\r\n        return;\r\n      }\r\n    }\r\n  }\r\n\r\n  // AVC - encrypt one 16 bytes block out of ten, starting from offset 32\r\n  getAvcEncryptedData(decodedData: Uint8Array) {\r\n    const encryptedDataLen =\r\n      Math.floor((decodedData.length - 48) / 160) * 16 + 16;\r\n    const encryptedData = new Int8Array(encryptedDataLen);\r\n    let outputPos = 0;\r\n    for (\r\n      let inputPos = 32;\r\n      inputPos < decodedData.length - 16;\r\n      inputPos += 160, outputPos += 16\r\n    ) {\r\n      encryptedData.set(\r\n        decodedData.subarray(inputPos, inputPos + 16),\r\n        outputPos,\r\n      );\r\n    }\r\n\r\n    return encryptedData;\r\n  }\r\n\r\n  getAvcDecryptedUnit(\r\n    decodedData: Uint8Array,\r\n    decryptedData: ArrayLike<number> | ArrayBuffer | SharedArrayBuffer,\r\n  ) {\r\n    const uint8DecryptedData = new Uint8Array(decryptedData);\r\n    let inputPos = 0;\r\n    for (\r\n      let outputPos = 32;\r\n      outputPos < decodedData.length - 16;\r\n      outputPos += 160, inputPos += 16\r\n    ) {\r\n      decodedData.set(\r\n        uint8DecryptedData.subarray(inputPos, inputPos + 16),\r\n        outputPos,\r\n      );\r\n    }\r\n\r\n    return decodedData;\r\n  }\r\n\r\n  decryptAvcSample(\r\n    samples: VideoSample[],\r\n    sampleIndex: number,\r\n    unitIndex: number,\r\n    callback: () => void,\r\n    curUnit: VideoSampleUnit,\r\n  ) {\r\n    const decodedData = discardEPB(curUnit.data);\r\n    const encryptedData = this.getAvcEncryptedData(decodedData);\r\n\r\n    this.decryptBuffer(encryptedData.buffer).then(\r\n      (decryptedBuffer: ArrayBuffer) => {\r\n        curUnit.data = this.getAvcDecryptedUnit(decodedData, decryptedBuffer);\r\n\r\n        if (!this.decrypter.isSync()) {\r\n          this.decryptAvcSamples(samples, sampleIndex, unitIndex + 1, callback);\r\n        }\r\n      },\r\n    );\r\n  }\r\n\r\n  decryptAvcSamples(\r\n    samples: DemuxedVideoTrackBase['samples'],\r\n    sampleIndex: number,\r\n    unitIndex: number,\r\n    callback: () => void,\r\n  ) {\r\n    if (samples instanceof Uint8Array) {\r\n      throw new Error('Cannot decrypt samples of type Uint8Array');\r\n    }\r\n\r\n    for (; ; sampleIndex++, unitIndex = 0) {\r\n      if (sampleIndex >= samples.length) {\r\n        callback();\r\n        return;\r\n      }\r\n\r\n      const curUnits = samples[sampleIndex].units;\r\n      for (; ; unitIndex++) {\r\n        if (unitIndex >= curUnits.length) {\r\n          break;\r\n        }\r\n\r\n        const curUnit = curUnits[unitIndex];\r\n        if (\r\n          curUnit.data.length <= 48 ||\r\n          (curUnit.type !== 1 && curUnit.type !== 5)\r\n        ) {\r\n          continue;\r\n        }\r\n\r\n        this.decryptAvcSample(\r\n          samples,\r\n          sampleIndex,\r\n          unitIndex,\r\n          callback,\r\n          curUnit,\r\n        );\r\n\r\n        if (!this.decrypter.isSync()) {\r\n          return;\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport default SampleAesDecrypter;\r\n","/**\r\n * highly optimized TS demuxer:\r\n * parse PAT, PMT\r\n * extract PES packet from audio and video PIDs\r\n * extract AVC/H264 (or HEVC/H265) NAL units and AAC/ADTS samples from PES packet\r\n * trigger the remuxer upon parsing completion\r\n * it also tries to workaround as best as it can audio codec switch (HE-AAC to AAC and vice versa), without having to restart the MediaSource.\r\n * it also controls the remuxing process :\r\n * upon discontinuity or level switch detection, it will also notifies the remuxer so that it can reset its state.\r\n */\r\n\r\nimport * as ADTS from './audio/adts';\r\nimport * as MpegAudio from './audio/mpegaudio';\r\nimport * as AC3 from './audio/ac3-demuxer';\r\nimport BaseVideoParser from './video/base-video-parser';\r\nimport AvcVideoParser from './video/avc-video-parser';\r\nimport HevcVideoParser from './video/hevc-video-parser';\r\nimport SampleAesDecrypter from './sample-aes';\r\nimport { Events } from '../events';\r\nimport { appendUint8Array, RemuxerTrackIdConfig } from '../utils/mp4-tools';\r\nimport { logger } from '../utils/logger';\r\nimport { ErrorTypes, ErrorDetails } from '../errors';\r\nimport type { HlsConfig } from '../config';\r\nimport type { HlsEventEmitter } from '../events';\r\nimport {\r\n  DemuxedVideoTrack,\r\n  DemuxedAudioTrack,\r\n  DemuxedTrack,\r\n  Demuxer,\r\n  DemuxerResult,\r\n  VideoSample,\r\n  DemuxedMetadataTrack,\r\n  DemuxedUserdataTrack,\r\n  ElementaryStreamData,\r\n  KeyData,\r\n  MetadataSchema,\r\n} from '../types/demuxer';\r\nimport { AudioFrame } from '../types/demuxer';\r\n\r\nexport type ParsedTimestamp = {\r\n  pts?: number;\r\n  dts?: number;\r\n};\r\n\r\nexport type PES = ParsedTimestamp & {\r\n  data: Uint8Array;\r\n  len: number;\r\n};\r\n\r\nexport type ParsedVideoSample = ParsedTimestamp &\r\n  Omit<VideoSample, 'pts' | 'dts'>;\r\n\r\nexport interface TypeSupported {\r\n  mpeg: boolean;\r\n  mp3: boolean;\r\n  ac3: boolean;\r\n}\r\n\r\nconst PACKET_LENGTH = 188;\r\n\r\nclass TSDemuxer implements Demuxer {\r\n  private readonly observer: HlsEventEmitter;\r\n  private readonly config: HlsConfig;\r\n  private typeSupported: TypeSupported;\r\n\r\n  private sampleAes: SampleAesDecrypter | null = null;\r\n  private pmtParsed: boolean = false;\r\n  private audioCodec?: string;\r\n  private videoCodec?: string;\r\n  private _duration: number = 0;\r\n  private _pmtId: number = -1;\r\n\r\n  private _videoTrack?: DemuxedVideoTrack;\r\n  private _audioTrack?: DemuxedAudioTrack;\r\n  private _id3Track?: DemuxedMetadataTrack;\r\n  private _txtTrack?: DemuxedUserdataTrack;\r\n  private aacOverFlow: AudioFrame | null = null;\r\n  private remainderData: Uint8Array | null = null;\r\n  private videoParser: BaseVideoParser | null;\r\n\r\n  constructor(\r\n    observer: HlsEventEmitter,\r\n    config: HlsConfig,\r\n    typeSupported: TypeSupported,\r\n  ) {\r\n    this.observer = observer;\r\n    this.config = config;\r\n    this.typeSupported = typeSupported;\r\n    this.videoParser = null;\r\n  }\r\n\r\n  static probe(data: Uint8Array) {\r\n    const syncOffset = TSDemuxer.syncOffset(data);\r\n    if (syncOffset > 0) {\r\n      logger.warn(\r\n        `MPEG2-TS detected but first sync word found @ offset ${syncOffset}`,\r\n      );\r\n    }\r\n    return syncOffset !== -1;\r\n  }\r\n\r\n  static syncOffset(data: Uint8Array): number {\r\n    const length = data.length;\r\n    let scanwindow =\r\n      Math.min(PACKET_LENGTH * 5, data.length - PACKET_LENGTH) + 1;\r\n    let i = 0;\r\n    while (i < scanwindow) {\r\n      // a TS init segment should contain at least 2 TS packets: PAT and PMT, each starting with 0x47\r\n      let foundPat = false;\r\n      let packetStart = -1;\r\n      let tsPackets = 0;\r\n      for (let j = i; j < length; j += PACKET_LENGTH) {\r\n        if (data[j] === 0x47) {\r\n          tsPackets++;\r\n          if (packetStart === -1) {\r\n            packetStart = j;\r\n            // First sync word found at offset, increase scan length (#5251)\r\n            if (packetStart !== 0) {\r\n              scanwindow =\r\n                Math.min(\r\n                  packetStart + PACKET_LENGTH * 99,\r\n                  data.length - PACKET_LENGTH,\r\n                ) + 1;\r\n            }\r\n          }\r\n          if (!foundPat) {\r\n            foundPat = parsePID(data, j) === 0;\r\n          }\r\n          // Sync word found at 0 with 3 packets, or found at offset least 2 packets up to scanwindow (#5501)\r\n          if (\r\n            foundPat &&\r\n            tsPackets > 1 &&\r\n            ((packetStart === 0 && tsPackets > 2) ||\r\n              j + PACKET_LENGTH > scanwindow)\r\n          ) {\r\n            return packetStart;\r\n          }\r\n        } else if (tsPackets) {\r\n          // Exit if sync word found, but does not contain contiguous packets (#5501)\r\n          return -1;\r\n        } else {\r\n          break;\r\n        }\r\n      }\r\n      i++;\r\n    }\r\n    return -1;\r\n  }\r\n\r\n  /**\r\n   * Creates a track model internal to demuxer used to drive remuxing input\r\n   */\r\n  static createTrack(\r\n    type: 'audio' | 'video' | 'id3' | 'text',\r\n    duration?: number,\r\n  ): DemuxedTrack {\r\n    return {\r\n      container:\r\n        type === 'video' || type === 'audio' ? 'video/mp2t' : undefined,\r\n      type,\r\n      id: RemuxerTrackIdConfig[type],\r\n      pid: -1,\r\n      inputTimeScale: 90000,\r\n      sequenceNumber: 0,\r\n      samples: [],\r\n      dropped: 0,\r\n      duration: type === 'audio' ? duration : undefined,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Initializes a new init segment on the demuxer/remuxer interface. Needed for discontinuities/track-switches (or at stream start)\r\n   * Resets all internal track instances of the demuxer.\r\n   */\r\n  public resetInitSegment(\r\n    initSegment: Uint8Array | undefined,\r\n    audioCodec: string,\r\n    videoCodec: string,\r\n    trackDuration: number,\r\n  ) {\r\n    this.pmtParsed = false;\r\n    this._pmtId = -1;\r\n\r\n    this._videoTrack = TSDemuxer.createTrack('video') as DemuxedVideoTrack;\r\n    this._audioTrack = TSDemuxer.createTrack(\r\n      'audio',\r\n      trackDuration,\r\n    ) as DemuxedAudioTrack;\r\n    this._id3Track = TSDemuxer.createTrack('id3') as DemuxedMetadataTrack;\r\n    this._txtTrack = TSDemuxer.createTrack('text') as DemuxedUserdataTrack;\r\n    this._audioTrack.segmentCodec = 'aac';\r\n\r\n    // flush any partial content\r\n    this.aacOverFlow = null;\r\n    this.remainderData = null;\r\n    this.audioCodec = audioCodec;\r\n    this.videoCodec = videoCodec;\r\n    this._duration = trackDuration;\r\n  }\r\n\r\n  public resetTimeStamp() {}\r\n\r\n  public resetContiguity(): void {\r\n    const { _audioTrack, _videoTrack, _id3Track } = this;\r\n    if (_audioTrack) {\r\n      _audioTrack.pesData = null;\r\n    }\r\n    if (_videoTrack) {\r\n      _videoTrack.pesData = null;\r\n    }\r\n    if (_id3Track) {\r\n      _id3Track.pesData = null;\r\n    }\r\n    this.aacOverFlow = null;\r\n    this.remainderData = null;\r\n  }\r\n\r\n  public demux(\r\n    data: Uint8Array,\r\n    timeOffset: number,\r\n    isSampleAes = false,\r\n    flush = false,\r\n  ): DemuxerResult {\r\n    if (!isSampleAes) {\r\n      this.sampleAes = null;\r\n    }\r\n\r\n    let pes: PES | null;\r\n\r\n    const videoTrack = this._videoTrack as DemuxedVideoTrack;\r\n    const audioTrack = this._audioTrack as DemuxedAudioTrack;\r\n    const id3Track = this._id3Track as DemuxedMetadataTrack;\r\n    const textTrack = this._txtTrack as DemuxedUserdataTrack;\r\n\r\n    let videoPid = videoTrack.pid;\r\n    let videoData = videoTrack.pesData;\r\n    let audioPid = audioTrack.pid;\r\n    let id3Pid = id3Track.pid;\r\n    let audioData = audioTrack.pesData;\r\n    let id3Data = id3Track.pesData;\r\n    let unknownPID: number | null = null;\r\n    let pmtParsed = this.pmtParsed;\r\n    let pmtId = this._pmtId;\r\n\r\n    let len = data.length;\r\n    if (this.remainderData) {\r\n      data = appendUint8Array(this.remainderData, data);\r\n      len = data.length;\r\n      this.remainderData = null;\r\n    }\r\n\r\n    if (len < PACKET_LENGTH && !flush) {\r\n      this.remainderData = data;\r\n      return {\r\n        audioTrack,\r\n        videoTrack,\r\n        id3Track,\r\n        textTrack,\r\n      };\r\n    }\r\n\r\n    const syncOffset = Math.max(0, TSDemuxer.syncOffset(data));\r\n    len -= (len - syncOffset) % PACKET_LENGTH;\r\n    if (len < data.byteLength && !flush) {\r\n      this.remainderData = new Uint8Array(\r\n        data.buffer,\r\n        len,\r\n        data.buffer.byteLength - len,\r\n      );\r\n    }\r\n\r\n    // loop through TS packets\r\n    let tsPacketErrors = 0;\r\n    for (let start = syncOffset; start < len; start += PACKET_LENGTH) {\r\n      if (data[start] === 0x47) {\r\n        const stt = !!(data[start + 1] & 0x40);\r\n        const pid = parsePID(data, start);\r\n        const atf = (data[start + 3] & 0x30) >> 4;\r\n\r\n        // if an adaption field is present, its length is specified by the fifth byte of the TS packet header.\r\n        let offset: number;\r\n        if (atf > 1) {\r\n          offset = start + 5 + data[start + 4];\r\n          // continue if there is only adaptation field\r\n          if (offset === start + PACKET_LENGTH) {\r\n            continue;\r\n          }\r\n        } else {\r\n          offset = start + 4;\r\n        }\r\n        switch (pid) {\r\n          case videoPid:\r\n            if (stt) {\r\n              if (videoData && (pes = parsePES(videoData))) {\r\n                if (this.videoParser === null) {\r\n                  switch (videoTrack.segmentCodec) {\r\n                    case 'avc':\r\n                      this.videoParser = new AvcVideoParser();\r\n                      break;\r\n                    case 'hevc':\r\n                      this.videoParser = new HevcVideoParser();\r\n                      break;\r\n                  }\r\n                }\r\n                if (this.videoParser !== null) {\r\n                  this.videoParser.parsePES(\r\n                    videoTrack,\r\n                    textTrack,\r\n                    pes,\r\n                    false,\r\n                    this._duration,\r\n                  );\r\n                }\r\n              }\r\n\r\n              videoData = { data: [], size: 0 };\r\n            }\r\n            if (videoData) {\r\n              videoData.data.push(data.subarray(offset, start + PACKET_LENGTH));\r\n              videoData.size += start + PACKET_LENGTH - offset;\r\n            }\r\n            break;\r\n          case audioPid:\r\n            if (stt) {\r\n              if (audioData && (pes = parsePES(audioData))) {\r\n                switch (audioTrack.segmentCodec) {\r\n                  case 'aac':\r\n                    this.parseAACPES(audioTrack, pes);\r\n                    break;\r\n                  case 'mp3':\r\n                    this.parseMPEGPES(audioTrack, pes);\r\n                    break;\r\n                  case 'ac3':\r\n                    if (__USE_M2TS_ADVANCED_CODECS__) {\r\n                      this.parseAC3PES(audioTrack, pes);\r\n                    }\r\n                    break;\r\n                }\r\n              }\r\n              audioData = { data: [], size: 0 };\r\n            }\r\n            if (audioData) {\r\n              audioData.data.push(data.subarray(offset, start + PACKET_LENGTH));\r\n              audioData.size += start + PACKET_LENGTH - offset;\r\n            }\r\n            break;\r\n          case id3Pid:\r\n            if (stt) {\r\n              if (id3Data && (pes = parsePES(id3Data))) {\r\n                this.parseID3PES(id3Track, pes);\r\n              }\r\n\r\n              id3Data = { data: [], size: 0 };\r\n            }\r\n            if (id3Data) {\r\n              id3Data.data.push(data.subarray(offset, start + PACKET_LENGTH));\r\n              id3Data.size += start + PACKET_LENGTH - offset;\r\n            }\r\n            break;\r\n          case 0:\r\n            if (stt) {\r\n              offset += data[offset] + 1;\r\n            }\r\n\r\n            pmtId = this._pmtId = parsePAT(data, offset);\r\n            // logger.log('PMT PID:'  + this._pmtId);\r\n            break;\r\n          case pmtId: {\r\n            if (stt) {\r\n              offset += data[offset] + 1;\r\n            }\r\n\r\n            const parsedPIDs = parsePMT(\r\n              data,\r\n              offset,\r\n              this.typeSupported,\r\n              isSampleAes,\r\n            );\r\n\r\n            // only update track id if track PID found while parsing PMT\r\n            // this is to avoid resetting the PID to -1 in case\r\n            // track PID transiently disappears from the stream\r\n            // this could happen in case of transient missing audio samples for example\r\n            // NOTE this is only the PID of the track as found in TS,\r\n            // but we are not using this for MP4 track IDs.\r\n            videoPid = parsedPIDs.videoPid;\r\n            if (videoPid > 0) {\r\n              videoTrack.pid = videoPid;\r\n              videoTrack.segmentCodec = parsedPIDs.segmentVideoCodec;\r\n            }\r\n\r\n            audioPid = parsedPIDs.audioPid;\r\n            if (audioPid > 0) {\r\n              audioTrack.pid = audioPid;\r\n              audioTrack.segmentCodec = parsedPIDs.segmentAudioCodec;\r\n            }\r\n            id3Pid = parsedPIDs.id3Pid;\r\n            if (id3Pid > 0) {\r\n              id3Track.pid = id3Pid;\r\n            }\r\n\r\n            if (unknownPID !== null && !pmtParsed) {\r\n              logger.warn(\r\n                `MPEG-TS PMT found at ${start} after unknown PID '${unknownPID}'. Backtracking to sync byte @${syncOffset} to parse all TS packets.`,\r\n              );\r\n              unknownPID = null;\r\n              // we set it to -188, the += 188 in the for loop will reset start to 0\r\n              start = syncOffset - 188;\r\n            }\r\n            pmtParsed = this.pmtParsed = true;\r\n            break;\r\n          }\r\n          case 0x11:\r\n          case 0x1fff:\r\n            break;\r\n          default:\r\n            unknownPID = pid;\r\n            break;\r\n        }\r\n      } else {\r\n        tsPacketErrors++;\r\n      }\r\n    }\r\n\r\n    if (tsPacketErrors > 0) {\r\n      const error = new Error(\r\n        `Found ${tsPacketErrors} TS packet/s that do not start with 0x47`,\r\n      );\r\n      this.observer.emit(Events.ERROR, Events.ERROR, {\r\n        type: ErrorTypes.MEDIA_ERROR,\r\n        details: ErrorDetails.FRAG_PARSING_ERROR,\r\n        fatal: false,\r\n        error,\r\n        reason: error.message,\r\n      });\r\n    }\r\n\r\n    videoTrack.pesData = videoData;\r\n    audioTrack.pesData = audioData;\r\n    id3Track.pesData = id3Data;\r\n\r\n    const demuxResult: DemuxerResult = {\r\n      audioTrack,\r\n      videoTrack,\r\n      id3Track,\r\n      textTrack,\r\n    };\r\n\r\n    if (flush) {\r\n      this.extractRemainingSamples(demuxResult);\r\n    }\r\n\r\n    return demuxResult;\r\n  }\r\n\r\n  public flush(): DemuxerResult | Promise<DemuxerResult> {\r\n    const { remainderData } = this;\r\n    this.remainderData = null;\r\n    let result: DemuxerResult;\r\n    if (remainderData) {\r\n      result = this.demux(remainderData, -1, false, true);\r\n    } else {\r\n      result = {\r\n        videoTrack: this._videoTrack as DemuxedVideoTrack,\r\n        audioTrack: this._audioTrack as DemuxedAudioTrack,\r\n        id3Track: this._id3Track as DemuxedMetadataTrack,\r\n        textTrack: this._txtTrack as DemuxedUserdataTrack,\r\n      };\r\n    }\r\n    this.extractRemainingSamples(result);\r\n    if (this.sampleAes) {\r\n      return this.decrypt(result, this.sampleAes);\r\n    }\r\n    return result;\r\n  }\r\n\r\n  private extractRemainingSamples(demuxResult: DemuxerResult) {\r\n    const { audioTrack, videoTrack, id3Track, textTrack } = demuxResult;\r\n    const videoData = videoTrack.pesData;\r\n    const audioData = audioTrack.pesData;\r\n    const id3Data = id3Track.pesData;\r\n    // try to parse last PES packets\r\n    let pes: PES | null;\r\n    if (videoData && (pes = parsePES(videoData))) {\r\n      if (this.videoParser === null) {\r\n        switch (videoTrack.segmentCodec) {\r\n          case 'avc':\r\n            this.videoParser = new AvcVideoParser();\r\n            break;\r\n          case 'hevc':\r\n            this.videoParser = new HevcVideoParser();\r\n            break;\r\n        }\r\n      }\r\n      if (this.videoParser !== null) {\r\n        this.videoParser.parsePES(\r\n          videoTrack as DemuxedVideoTrack,\r\n          textTrack as DemuxedUserdataTrack,\r\n          pes,\r\n          true,\r\n          this._duration,\r\n        );\r\n        videoTrack.pesData = null;\r\n      }\r\n    } else {\r\n      // either avcData null or PES truncated, keep it for next frag parsing\r\n      videoTrack.pesData = videoData;\r\n    }\r\n\r\n    if (audioData && (pes = parsePES(audioData))) {\r\n      switch (audioTrack.segmentCodec) {\r\n        case 'aac':\r\n          this.parseAACPES(audioTrack, pes);\r\n          break;\r\n        case 'mp3':\r\n          this.parseMPEGPES(audioTrack, pes);\r\n          break;\r\n        case 'ac3':\r\n          if (__USE_M2TS_ADVANCED_CODECS__) {\r\n            this.parseAC3PES(audioTrack, pes);\r\n          }\r\n          break;\r\n      }\r\n      audioTrack.pesData = null;\r\n    } else {\r\n      if (audioData?.size) {\r\n        logger.log(\r\n          'last AAC PES packet truncated,might overlap between fragments',\r\n        );\r\n      }\r\n\r\n      // either audioData null or PES truncated, keep it for next frag parsing\r\n      audioTrack.pesData = audioData;\r\n    }\r\n\r\n    if (id3Data && (pes = parsePES(id3Data))) {\r\n      this.parseID3PES(id3Track, pes);\r\n      id3Track.pesData = null;\r\n    } else {\r\n      // either id3Data null or PES truncated, keep it for next frag parsing\r\n      id3Track.pesData = id3Data;\r\n    }\r\n  }\r\n\r\n  public demuxSampleAes(\r\n    data: Uint8Array,\r\n    keyData: KeyData,\r\n    timeOffset: number,\r\n  ): Promise<DemuxerResult> {\r\n    const demuxResult = this.demux(\r\n      data,\r\n      timeOffset,\r\n      true,\r\n      !this.config.progressive,\r\n    );\r\n    const sampleAes = (this.sampleAes = new SampleAesDecrypter(\r\n      this.observer,\r\n      this.config,\r\n      keyData,\r\n    ));\r\n    return this.decrypt(demuxResult, sampleAes);\r\n  }\r\n\r\n  private decrypt(\r\n    demuxResult: DemuxerResult,\r\n    sampleAes: SampleAesDecrypter,\r\n  ): Promise<DemuxerResult> {\r\n    return new Promise((resolve) => {\r\n      const { audioTrack, videoTrack } = demuxResult;\r\n      if (audioTrack.samples && audioTrack.segmentCodec === 'aac') {\r\n        sampleAes.decryptAacSamples(audioTrack.samples, 0, () => {\r\n          if (videoTrack.samples) {\r\n            sampleAes.decryptAvcSamples(videoTrack.samples, 0, 0, () => {\r\n              resolve(demuxResult);\r\n            });\r\n          } else {\r\n            resolve(demuxResult);\r\n          }\r\n        });\r\n      } else if (videoTrack.samples) {\r\n        sampleAes.decryptAvcSamples(videoTrack.samples, 0, 0, () => {\r\n          resolve(demuxResult);\r\n        });\r\n      }\r\n    });\r\n  }\r\n\r\n  public destroy() {\r\n    this._duration = 0;\r\n  }\r\n\r\n  private parseAACPES(track: DemuxedAudioTrack, pes: PES) {\r\n    let startOffset = 0;\r\n    const aacOverFlow = this.aacOverFlow;\r\n    let data = pes.data;\r\n    if (aacOverFlow) {\r\n      this.aacOverFlow = null;\r\n      const frameMissingBytes = aacOverFlow.missing;\r\n      const sampleLength = aacOverFlow.sample.unit.byteLength;\r\n      // logger.log(`AAC: append overflowing ${sampleLength} bytes to beginning of new PES`);\r\n      if (frameMissingBytes === -1) {\r\n        data = appendUint8Array(aacOverFlow.sample.unit, data);\r\n      } else {\r\n        const frameOverflowBytes = sampleLength - frameMissingBytes;\r\n        aacOverFlow.sample.unit.set(\r\n          data.subarray(0, frameMissingBytes),\r\n          frameOverflowBytes,\r\n        );\r\n        track.samples.push(aacOverFlow.sample);\r\n        startOffset = aacOverFlow.missing;\r\n      }\r\n    }\r\n    // look for ADTS header (0xFFFx)\r\n    let offset: number;\r\n    let len: number;\r\n    for (offset = startOffset, len = data.length; offset < len - 1; offset++) {\r\n      if (ADTS.isHeader(data, offset)) {\r\n        break;\r\n      }\r\n    }\r\n    // if ADTS header does not start straight from the beginning of the PES payload, raise an error\r\n    if (offset !== startOffset) {\r\n      let reason: string;\r\n      const recoverable = offset < len - 1;\r\n      if (recoverable) {\r\n        reason = `AAC PES did not start with ADTS header,offset:${offset}`;\r\n      } else {\r\n        reason = 'No ADTS header found in AAC PES';\r\n      }\r\n      const error = new Error(reason);\r\n      logger.warn(`parsing error: ${reason}`);\r\n      this.observer.emit(Events.ERROR, Events.ERROR, {\r\n        type: ErrorTypes.MEDIA_ERROR,\r\n        details: ErrorDetails.FRAG_PARSING_ERROR,\r\n        fatal: false,\r\n        levelRetry: recoverable,\r\n        error,\r\n        reason,\r\n      });\r\n      if (!recoverable) {\r\n        return;\r\n      }\r\n    }\r\n\r\n    ADTS.initTrackConfig(\r\n      track,\r\n      this.observer,\r\n      data,\r\n      offset,\r\n      this.audioCodec as string,\r\n    );\r\n\r\n    let pts: number;\r\n    if (pes.pts !== undefined) {\r\n      pts = pes.pts;\r\n    } else if (aacOverFlow) {\r\n      // if last AAC frame is overflowing, we should ensure timestamps are contiguous:\r\n      // first sample PTS should be equal to last sample PTS + frameDuration\r\n      const frameDuration = ADTS.getFrameDuration(track.samplerate as number);\r\n      pts = aacOverFlow.sample.pts + frameDuration;\r\n    } else {\r\n      logger.warn('[tsdemuxer]: AAC PES unknown PTS');\r\n      return;\r\n    }\r\n\r\n    // scan for aac samples\r\n    let frameIndex = 0;\r\n    let frame;\r\n    while (offset < len) {\r\n      frame = ADTS.appendFrame(track, data, offset, pts, frameIndex);\r\n      offset += frame.length;\r\n      if (!frame.missing) {\r\n        frameIndex++;\r\n        for (; offset < len - 1; offset++) {\r\n          if (ADTS.isHeader(data, offset)) {\r\n            break;\r\n          }\r\n        }\r\n      } else {\r\n        this.aacOverFlow = frame;\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  private parseMPEGPES(track: DemuxedAudioTrack, pes: PES) {\r\n    const data = pes.data;\r\n    const length = data.length;\r\n    let frameIndex = 0;\r\n    let offset = 0;\r\n    const pts = pes.pts;\r\n    if (pts === undefined) {\r\n      logger.warn('[tsdemuxer]: MPEG PES unknown PTS');\r\n      return;\r\n    }\r\n\r\n    while (offset < length) {\r\n      if (MpegAudio.isHeader(data, offset)) {\r\n        const frame = MpegAudio.appendFrame(\r\n          track,\r\n          data,\r\n          offset,\r\n          pts,\r\n          frameIndex,\r\n        );\r\n        if (frame) {\r\n          offset += frame.length;\r\n          frameIndex++;\r\n        } else {\r\n          // logger.log('Unable to parse Mpeg audio frame');\r\n          break;\r\n        }\r\n      } else {\r\n        // nothing found, keep looking\r\n        offset++;\r\n      }\r\n    }\r\n  }\r\n\r\n  private parseAC3PES(track: DemuxedAudioTrack, pes: PES) {\r\n    if (__USE_M2TS_ADVANCED_CODECS__) {\r\n      const data = pes.data;\r\n      const pts = pes.pts;\r\n      if (pts === undefined) {\r\n        logger.warn('[tsdemuxer]: AC3 PES unknown PTS');\r\n        return;\r\n      }\r\n      const length = data.length;\r\n      let frameIndex = 0;\r\n      let offset = 0;\r\n      let parsed;\r\n\r\n      while (\r\n        offset < length &&\r\n        (parsed = AC3.appendFrame(track, data, offset, pts, frameIndex++)) > 0\r\n      ) {\r\n        offset += parsed;\r\n      }\r\n    }\r\n  }\r\n\r\n  private parseID3PES(id3Track: DemuxedMetadataTrack, pes: PES) {\r\n    if (pes.pts === undefined) {\r\n      logger.warn('[tsdemuxer]: ID3 PES unknown PTS');\r\n      return;\r\n    }\r\n    const id3Sample = Object.assign({}, pes as Required<PES>, {\r\n      type: this._videoTrack ? MetadataSchema.emsg : MetadataSchema.audioId3,\r\n      duration: Number.POSITIVE_INFINITY,\r\n    });\r\n    id3Track.samples.push(id3Sample);\r\n  }\r\n}\r\n\r\nfunction parsePID(data: Uint8Array, offset: number): number {\r\n  // pid is a 13-bit field starting at the last bit of TS[1]\r\n  return ((data[offset + 1] & 0x1f) << 8) + data[offset + 2];\r\n}\r\n\r\nfunction parsePAT(data: Uint8Array, offset: number): number {\r\n  // skip the PSI header and parse the first PMT entry\r\n  return ((data[offset + 10] & 0x1f) << 8) | data[offset + 11];\r\n}\r\n\r\nfunction parsePMT(\r\n  data: Uint8Array,\r\n  offset: number,\r\n  typeSupported: TypeSupported,\r\n  isSampleAes: boolean,\r\n) {\r\n  const result = {\r\n    audioPid: -1,\r\n    videoPid: -1,\r\n    id3Pid: -1,\r\n    segmentVideoCodec: 'avc',\r\n    segmentAudioCodec: 'aac',\r\n  };\r\n  const sectionLength = ((data[offset + 1] & 0x0f) << 8) | data[offset + 2];\r\n  const tableEnd = offset + 3 + sectionLength - 4;\r\n  // to determine where the table is, we have to figure out how\r\n  // long the program info descriptors are\r\n  const programInfoLength =\r\n    ((data[offset + 10] & 0x0f) << 8) | data[offset + 11];\r\n  // advance the offset to the first entry in the mapping table\r\n  offset += 12 + programInfoLength;\r\n  while (offset < tableEnd) {\r\n    const pid = parsePID(data, offset);\r\n    const esInfoLength = ((data[offset + 3] & 0x0f) << 8) | data[offset + 4];\r\n    switch (data[offset]) {\r\n      case 0xcf: // SAMPLE-AES AAC\r\n        if (!isSampleAes) {\r\n          logEncryptedSamplesFoundInUnencryptedStream('ADTS AAC');\r\n          break;\r\n        }\r\n      /* falls through */\r\n      case 0x0f: // ISO/IEC 13818-7 ADTS AAC (MPEG-2 lower bit-rate audio)\r\n        // logger.log('AAC PID:'  + pid);\r\n        if (result.audioPid === -1) {\r\n          result.audioPid = pid;\r\n        }\r\n\r\n        break;\r\n\r\n      // Packetized metadata (ID3)\r\n      case 0x15:\r\n        // logger.log('ID3 PID:'  + pid);\r\n        if (result.id3Pid === -1) {\r\n          result.id3Pid = pid;\r\n        }\r\n\r\n        break;\r\n\r\n      case 0xdb: // SAMPLE-AES AVC\r\n        if (!isSampleAes) {\r\n          logEncryptedSamplesFoundInUnencryptedStream('H.264');\r\n          break;\r\n        }\r\n      /* falls through */\r\n      case 0x1b: // ITU-T Rec. H.264 and ISO/IEC 14496-10 (lower bit-rate video)\r\n        // logger.log('AVC PID:'  + pid);\r\n        if (result.videoPid === -1) {\r\n          result.videoPid = pid;\r\n          result.segmentVideoCodec = 'avc';\r\n        }\r\n\r\n        break;\r\n\r\n      // ISO/IEC 11172-3 (MPEG-1 audio)\r\n      // or ISO/IEC 13818-3 (MPEG-2 halved sample rate audio)\r\n      case 0x03:\r\n      case 0x04:\r\n        // logger.log('MPEG PID:'  + pid);\r\n        if (!typeSupported.mpeg && !typeSupported.mp3) {\r\n          logger.log('MPEG audio found, not supported in this browser');\r\n        } else if (result.audioPid === -1) {\r\n          result.audioPid = pid;\r\n          result.segmentAudioCodec = 'mp3';\r\n        }\r\n        break;\r\n\r\n      case 0xc1: // SAMPLE-AES AC3\r\n        if (!isSampleAes) {\r\n          logEncryptedSamplesFoundInUnencryptedStream('AC-3');\r\n          break;\r\n        }\r\n      /* falls through */\r\n      case 0x81:\r\n        if (__USE_M2TS_ADVANCED_CODECS__) {\r\n          if (!typeSupported.ac3) {\r\n            logger.log('AC-3 audio found, not supported in this browser');\r\n          } else if (result.audioPid === -1) {\r\n            result.audioPid = pid;\r\n            result.segmentAudioCodec = 'ac3';\r\n          }\r\n        } else {\r\n          logger.warn('AC-3 in M2TS support not included in build');\r\n        }\r\n        break;\r\n\r\n      case 0x06:\r\n        // stream_type 6 can mean a lot of different things in case of DVB.\r\n        // We need to look at the descriptors. Right now, we're only interested\r\n        // in AC-3 audio, so we do the descriptor parsing only when we don't have\r\n        // an audio PID yet.\r\n        if (result.audioPid === -1 && esInfoLength > 0) {\r\n          let parsePos = offset + 5;\r\n          let remaining = esInfoLength;\r\n\r\n          while (remaining > 2) {\r\n            const descriptorId = data[parsePos];\r\n\r\n            switch (descriptorId) {\r\n              case 0x6a: // DVB Descriptor for AC-3\r\n                if (__USE_M2TS_ADVANCED_CODECS__) {\r\n                  if (typeSupported.ac3 !== true) {\r\n                    logger.log(\r\n                      'AC-3 audio found, not supported in this browser for now',\r\n                    );\r\n                  } else {\r\n                    result.audioPid = pid;\r\n                    result.segmentAudioCodec = 'ac3';\r\n                  }\r\n                } else {\r\n                  logger.warn('AC-3 in M2TS support not included in build');\r\n                }\r\n                break;\r\n            }\r\n\r\n            const descriptorLen = data[parsePos + 1] + 2;\r\n            parsePos += descriptorLen;\r\n            remaining -= descriptorLen;\r\n          }\r\n        }\r\n        break;\r\n\r\n      case 0xc2: // SAMPLE-AES EC3\r\n      /* falls through */\r\n      case 0x87:\r\n        logger.warn('Unsupported EC-3 in M2TS found');\r\n        break;\r\n\r\n      case 0x24: // ITU-T Rec. H.265 and ISO/IEC 23008-2 (HEVC)\r\n        if (result.videoPid === -1) {\r\n          result.videoPid = pid;\r\n          result.segmentVideoCodec = 'hevc';\r\n          logger.log('HEVC in M2TS found');\r\n        }\r\n        break;\r\n\r\n      default:\r\n        // logger.log('unknown stream type:' + data[offset]);\r\n        break;\r\n    }\r\n    // move to the next table entry\r\n    // skip past the elementary stream descriptors, if present\r\n    offset += esInfoLength + 5;\r\n  }\r\n  return result;\r\n}\r\n\r\nfunction logEncryptedSamplesFoundInUnencryptedStream(type: string) {\r\n  logger.log(`${type} with AES-128-CBC encryption found in unencrypted stream`);\r\n}\r\n\r\nfunction parsePES(stream: ElementaryStreamData): PES | null {\r\n  let i = 0;\r\n  let frag: Uint8Array;\r\n  let pesLen: number;\r\n  let pesHdrLen: number;\r\n  let pesPts: number | undefined;\r\n  let pesDts: number | undefined;\r\n  const data = stream.data;\r\n  // safety check\r\n  if (!stream || stream.size === 0) {\r\n    return null;\r\n  }\r\n\r\n  // we might need up to 19 bytes to read PES header\r\n  // if first chunk of data is less than 19 bytes, let's merge it with following ones until we get 19 bytes\r\n  // usually only one merge is needed (and this is rare ...)\r\n  while (data[0].length < 19 && data.length > 1) {\r\n    data[0] = appendUint8Array(data[0], data[1]);\r\n    data.splice(1, 1);\r\n  }\r\n  // retrieve PTS/DTS from first fragment\r\n  frag = data[0];\r\n  const pesPrefix = (frag[0] << 16) + (frag[1] << 8) + frag[2];\r\n  if (pesPrefix === 1) {\r\n    pesLen = (frag[4] << 8) + frag[5];\r\n    // if PES parsed length is not zero and greater than total received length, stop parsing. PES might be truncated\r\n    // minus 6 : PES header size\r\n    if (pesLen && pesLen > stream.size - 6) {\r\n      return null;\r\n    }\r\n\r\n    const pesFlags = frag[7];\r\n    if (pesFlags & 0xc0) {\r\n      /* PES header described here : http://dvd.sourceforge.net/dvdinfo/pes-hdr.html\r\n          as PTS / DTS is 33 bit we cannot use bitwise operator in JS,\r\n          as Bitwise operators treat their operands as a sequence of 32 bits */\r\n      pesPts =\r\n        (frag[9] & 0x0e) * 536870912 + // 1 << 29\r\n        (frag[10] & 0xff) * 4194304 + // 1 << 22\r\n        (frag[11] & 0xfe) * 16384 + // 1 << 14\r\n        (frag[12] & 0xff) * 128 + // 1 << 7\r\n        (frag[13] & 0xfe) / 2;\r\n\r\n      if (pesFlags & 0x40) {\r\n        pesDts =\r\n          (frag[14] & 0x0e) * 536870912 + // 1 << 29\r\n          (frag[15] & 0xff) * 4194304 + // 1 << 22\r\n          (frag[16] & 0xfe) * 16384 + // 1 << 14\r\n          (frag[17] & 0xff) * 128 + // 1 << 7\r\n          (frag[18] & 0xfe) / 2;\r\n\r\n        if (pesPts - pesDts > 60 * 90000) {\r\n          logger.warn(\r\n            `${Math.round(\r\n              (pesPts - pesDts) / 90000,\r\n            )}s delta between PTS and DTS, align them`,\r\n          );\r\n          pesPts = pesDts;\r\n        }\r\n      } else {\r\n        pesDts = pesPts;\r\n      }\r\n    }\r\n    pesHdrLen = frag[8];\r\n    // 9 bytes : 6 bytes for PES header + 3 bytes for PES extension\r\n    let payloadStartOffset = pesHdrLen + 9;\r\n    if (stream.size <= payloadStartOffset) {\r\n      return null;\r\n    }\r\n    stream.size -= payloadStartOffset;\r\n    // reassemble PES packet\r\n    const pesData = new Uint8Array(stream.size);\r\n    for (let j = 0, dataLen = data.length; j < dataLen; j++) {\r\n      frag = data[j];\r\n      let len = frag.byteLength;\r\n      if (payloadStartOffset) {\r\n        if (payloadStartOffset > len) {\r\n          // trim full frag if PES header bigger than frag\r\n          payloadStartOffset -= len;\r\n          continue;\r\n        } else {\r\n          // trim partial frag if PES header smaller than frag\r\n          frag = frag.subarray(payloadStartOffset);\r\n          len -= payloadStartOffset;\r\n          payloadStartOffset = 0;\r\n        }\r\n      }\r\n      pesData.set(frag, i);\r\n      i += len;\r\n    }\r\n    if (pesLen) {\r\n      // payload size : remove PES header + PES extension\r\n      pesLen -= pesHdrLen + 3;\r\n    }\r\n    return { data: pesData, pts: pesPts, dts: pesDts, len: pesLen };\r\n  }\r\n  return null;\r\n}\r\n\r\nexport default TSDemuxer;\r\n","/**\r\n * MP3 demuxer\r\n */\r\nimport BaseAudioDemuxer from './base-audio-demuxer';\r\nimport { getID3Data, getTimeStamp } from '../id3';\r\nimport { getAudioBSID } from './dolby';\r\nimport { logger } from '../../utils/logger';\r\nimport * as MpegAudio from './mpegaudio';\r\n\r\nclass MP3Demuxer extends BaseAudioDemuxer {\r\n  resetInitSegment(\r\n    initSegment: Uint8Array | undefined,\r\n    audioCodec: string | undefined,\r\n    videoCodec: string | undefined,\r\n    trackDuration: number,\r\n  ) {\r\n    super.resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration);\r\n    this._audioTrack = {\r\n      container: 'audio/mpeg',\r\n      type: 'audio',\r\n      id: 2,\r\n      pid: -1,\r\n      sequenceNumber: 0,\r\n      segmentCodec: 'mp3',\r\n      samples: [],\r\n      manifestCodec: audioCodec,\r\n      duration: trackDuration,\r\n      inputTimeScale: 90000,\r\n      dropped: 0,\r\n    };\r\n  }\r\n\r\n  static probe(data: Uint8Array | undefined): boolean {\r\n    if (!data) {\r\n      return false;\r\n    }\r\n\r\n    // check if data contains ID3 timestamp and MPEG sync word\r\n    // Look for MPEG header | 1111 1111 | 111X XYZX | where X can be either 0 or 1 and Y or Z should be 1\r\n    // Layer bits (position 14 and 15) in header should be always different from 0 (Layer I or Layer II or Layer III)\r\n    // More info http://www.mp3-tech.org/programmer/frame_header.html\r\n    const id3Data = getID3Data(data, 0);\r\n    let offset = id3Data?.length || 0;\r\n\r\n    // Check for ac-3|ec-3 sync bytes and return false if present\r\n    if (\r\n      id3Data &&\r\n      data[offset] === 0x0b &&\r\n      data[offset + 1] === 0x77 &&\r\n      getTimeStamp(id3Data) !== undefined &&\r\n      // check the bsid to confirm ac-3 or ec-3 (not mp3)\r\n      getAudioBSID(data, offset) <= 16\r\n    ) {\r\n      return false;\r\n    }\r\n\r\n    for (let length = data.length; offset < length; offset++) {\r\n      if (MpegAudio.probe(data, offset)) {\r\n        logger.log('MPEG Audio sync word found !');\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  canParse(data, offset) {\r\n    return MpegAudio.canParse(data, offset);\r\n  }\r\n\r\n  appendFrame(track, data, offset) {\r\n    if (this.basePTS === null) {\r\n      return;\r\n    }\r\n    return MpegAudio.appendFrame(\r\n      track,\r\n      data,\r\n      offset,\r\n      this.basePTS,\r\n      this.frameIndex,\r\n    );\r\n  }\r\n}\r\n\r\nexport default MP3Demuxer;\r\n","/**\r\n *  AAC helper\r\n */\r\n\r\nclass AAC {\r\n  static getSilentFrame(\r\n    codec?: string,\r\n    channelCount?: number,\r\n  ): Uint8Array | undefined {\r\n    switch (codec) {\r\n      case 'mp4a.40.2':\r\n        if (channelCount === 1) {\r\n          return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x23, 0x80]);\r\n        } else if (channelCount === 2) {\r\n          return new Uint8Array([\r\n            0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80,\r\n          ]);\r\n        } else if (channelCount === 3) {\r\n          return new Uint8Array([\r\n            0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64,\r\n            0x00, 0x8e,\r\n          ]);\r\n        } else if (channelCount === 4) {\r\n          return new Uint8Array([\r\n            0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64,\r\n            0x00, 0x80, 0x2c, 0x80, 0x08, 0x02, 0x38,\r\n          ]);\r\n        } else if (channelCount === 5) {\r\n          return new Uint8Array([\r\n            0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64,\r\n            0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x38,\r\n          ]);\r\n        } else if (channelCount === 6) {\r\n          return new Uint8Array([\r\n            0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64,\r\n            0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x00, 0xb2,\r\n            0x00, 0x20, 0x08, 0xe0,\r\n          ]);\r\n        }\r\n\r\n        break;\r\n      // handle HE-AAC below (mp4a.40.5 / mp4a.40.29)\r\n      default:\r\n        if (channelCount === 1) {\r\n          // ffmpeg -y -f lavfi -i \"aevalsrc=0:d=0.05\" -c:a libfdk_aac -profile:a aac_he -b:a 4k output.aac && hexdump -v -e '16/1 \"0x%x,\" \"\\n\"' -v output.aac\r\n          return new Uint8Array([\r\n            0x1, 0x40, 0x22, 0x80, 0xa3, 0x4e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0,\r\n            0x0, 0x1c, 0x6, 0xf1, 0xc1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a,\r\n            0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a,\r\n            0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a,\r\n            0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a,\r\n            0x5a, 0x5e,\r\n          ]);\r\n        } else if (channelCount === 2) {\r\n          // ffmpeg -y -f lavfi -i \"aevalsrc=0|0:d=0.05\" -c:a libfdk_aac -profile:a aac_he_v2 -b:a 4k output.aac && hexdump -v -e '16/1 \"0x%x,\" \"\\n\"' -v output.aac\r\n          return new Uint8Array([\r\n            0x1, 0x40, 0x22, 0x80, 0xa3, 0x5e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0,\r\n            0x0, 0x0, 0x95, 0x0, 0x6, 0xf1, 0xa1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a,\r\n            0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a,\r\n            0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a,\r\n            0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a,\r\n            0x5a, 0x5e,\r\n          ]);\r\n        } else if (channelCount === 3) {\r\n          // ffmpeg -y -f lavfi -i \"aevalsrc=0|0|0:d=0.05\" -c:a libfdk_aac -profile:a aac_he_v2 -b:a 4k output.aac && hexdump -v -e '16/1 \"0x%x,\" \"\\n\"' -v output.aac\r\n          return new Uint8Array([\r\n            0x1, 0x40, 0x22, 0x80, 0xa3, 0x5e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0,\r\n            0x0, 0x0, 0x95, 0x0, 0x6, 0xf1, 0xa1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a,\r\n            0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a,\r\n            0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a,\r\n            0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a,\r\n            0x5a, 0x5e,\r\n          ]);\r\n        }\r\n        break;\r\n    }\r\n    return undefined;\r\n  }\r\n}\r\n\r\nexport default AAC;\r\n","/**\r\n * Generate MP4 Box\r\n */\r\n\r\nimport { appendUint8Array } from '../utils/mp4-tools';\r\n\r\ntype HdlrTypes = {\r\n  video: Uint8Array;\r\n  audio: Uint8Array;\r\n};\r\n\r\nconst UINT32_MAX = Math.pow(2, 32) - 1;\r\n\r\nclass MP4 {\r\n  public static types: Record<string, number[]>;\r\n  private static HDLR_TYPES: HdlrTypes;\r\n  private static STTS: Uint8Array;\r\n  private static STSC: Uint8Array;\r\n  private static STCO: Uint8Array;\r\n  private static STSZ: Uint8Array;\r\n  private static VMHD: Uint8Array;\r\n  private static SMHD: Uint8Array;\r\n  private static STSD: Uint8Array;\r\n  private static FTYP: Uint8Array;\r\n  private static DINF: Uint8Array;\r\n\r\n  static init() {\r\n    MP4.types = {\r\n      avc1: [], // codingname\r\n      avcC: [],\r\n      hvc1: [],\r\n      hvcC: [],\r\n      btrt: [],\r\n      dinf: [],\r\n      dref: [],\r\n      esds: [],\r\n      ftyp: [],\r\n      hdlr: [],\r\n      mdat: [],\r\n      mdhd: [],\r\n      mdia: [],\r\n      mfhd: [],\r\n      minf: [],\r\n      moof: [],\r\n      moov: [],\r\n      mp4a: [],\r\n      '.mp3': [],\r\n      dac3: [],\r\n      'ac-3': [],\r\n      mvex: [],\r\n      mvhd: [],\r\n      pasp: [],\r\n      sdtp: [],\r\n      stbl: [],\r\n      stco: [],\r\n      stsc: [],\r\n      stsd: [],\r\n      stsz: [],\r\n      stts: [],\r\n      tfdt: [],\r\n      tfhd: [],\r\n      traf: [],\r\n      trak: [],\r\n      trun: [],\r\n      trex: [],\r\n      tkhd: [],\r\n      vmhd: [],\r\n      smhd: [],\r\n    };\r\n\r\n    let i: string;\r\n    for (i in MP4.types) {\r\n      if (MP4.types.hasOwnProperty(i)) {\r\n        MP4.types[i] = [\r\n          i.charCodeAt(0),\r\n          i.charCodeAt(1),\r\n          i.charCodeAt(2),\r\n          i.charCodeAt(3),\r\n        ];\r\n      }\r\n    }\r\n\r\n    const videoHdlr = new Uint8Array([\r\n      0x00, // version 0\r\n      0x00,\r\n      0x00,\r\n      0x00, // flags\r\n      0x00,\r\n      0x00,\r\n      0x00,\r\n      0x00, // pre_defined\r\n      0x76,\r\n      0x69,\r\n      0x64,\r\n      0x65, // handler_type: 'vide'\r\n      0x00,\r\n      0x00,\r\n      0x00,\r\n      0x00, // reserved\r\n      0x00,\r\n      0x00,\r\n      0x00,\r\n      0x00, // reserved\r\n      0x00,\r\n      0x00,\r\n      0x00,\r\n      0x00, // reserved\r\n      0x56,\r\n      0x69,\r\n      0x64,\r\n      0x65,\r\n      0x6f,\r\n      0x48,\r\n      0x61,\r\n      0x6e,\r\n      0x64,\r\n      0x6c,\r\n      0x65,\r\n      0x72,\r\n      0x00, // name: 'VideoHandler'\r\n    ]);\r\n\r\n    const audioHdlr = new Uint8Array([\r\n      0x00, // version 0\r\n      0x00,\r\n      0x00,\r\n      0x00, // flags\r\n      0x00,\r\n      0x00,\r\n      0x00,\r\n      0x00, // pre_defined\r\n      0x73,\r\n      0x6f,\r\n      0x75,\r\n      0x6e, // handler_type: 'soun'\r\n      0x00,\r\n      0x00,\r\n      0x00,\r\n      0x00, // reserved\r\n      0x00,\r\n      0x00,\r\n      0x00,\r\n      0x00, // reserved\r\n      0x00,\r\n      0x00,\r\n      0x00,\r\n      0x00, // reserved\r\n      0x53,\r\n      0x6f,\r\n      0x75,\r\n      0x6e,\r\n      0x64,\r\n      0x48,\r\n      0x61,\r\n      0x6e,\r\n      0x64,\r\n      0x6c,\r\n      0x65,\r\n      0x72,\r\n      0x00, // name: 'SoundHandler'\r\n    ]);\r\n\r\n    MP4.HDLR_TYPES = {\r\n      video: videoHdlr,\r\n      audio: audioHdlr,\r\n    };\r\n\r\n    const dref = new Uint8Array([\r\n      0x00, // version 0\r\n      0x00,\r\n      0x00,\r\n      0x00, // flags\r\n      0x00,\r\n      0x00,\r\n      0x00,\r\n      0x01, // entry_count\r\n      0x00,\r\n      0x00,\r\n      0x00,\r\n      0x0c, // entry_size\r\n      0x75,\r\n      0x72,\r\n      0x6c,\r\n      0x20, // 'url' type\r\n      0x00, // version 0\r\n      0x00,\r\n      0x00,\r\n      0x01, // entry_flags\r\n    ]);\r\n\r\n    const stco = new Uint8Array([\r\n      0x00, // version\r\n      0x00,\r\n      0x00,\r\n      0x00, // flags\r\n      0x00,\r\n      0x00,\r\n      0x00,\r\n      0x00, // entry_count\r\n    ]);\r\n\r\n    MP4.STTS = MP4.STSC = MP4.STCO = stco;\r\n\r\n    MP4.STSZ = new Uint8Array([\r\n      0x00, // version\r\n      0x00,\r\n      0x00,\r\n      0x00, // flags\r\n      0x00,\r\n      0x00,\r\n      0x00,\r\n      0x00, // sample_size\r\n      0x00,\r\n      0x00,\r\n      0x00,\r\n      0x00, // sample_count\r\n    ]);\r\n    MP4.VMHD = new Uint8Array([\r\n      0x00, // version\r\n      0x00,\r\n      0x00,\r\n      0x01, // flags\r\n      0x00,\r\n      0x00, // graphicsmode\r\n      0x00,\r\n      0x00,\r\n      0x00,\r\n      0x00,\r\n      0x00,\r\n      0x00, // opcolor\r\n    ]);\r\n    MP4.SMHD = new Uint8Array([\r\n      0x00, // version\r\n      0x00,\r\n      0x00,\r\n      0x00, // flags\r\n      0x00,\r\n      0x00, // balance\r\n      0x00,\r\n      0x00, // reserved\r\n    ]);\r\n\r\n    MP4.STSD = new Uint8Array([\r\n      0x00, // version 0\r\n      0x00,\r\n      0x00,\r\n      0x00, // flags\r\n      0x00,\r\n      0x00,\r\n      0x00,\r\n      0x01,\r\n    ]); // entry_count\r\n\r\n    const majorBrand = new Uint8Array([105, 115, 111, 109]); // isom\r\n    const avc1Brand = new Uint8Array([97, 118, 99, 49]); // avc1\r\n    const minorVersion = new Uint8Array([0, 0, 0, 1]);\r\n\r\n    MP4.FTYP = MP4.box(\r\n      MP4.types.ftyp,\r\n      majorBrand,\r\n      minorVersion,\r\n      majorBrand,\r\n      avc1Brand,\r\n    );\r\n    MP4.DINF = MP4.box(MP4.types.dinf, MP4.box(MP4.types.dref, dref));\r\n  }\r\n\r\n  static box(type, ...payload: Uint8Array[]) {\r\n    let size = 8;\r\n    let i = payload.length;\r\n    const len = i;\r\n    // calculate the total size we need to allocate\r\n    while (i--) {\r\n      size += payload[i].byteLength;\r\n    }\r\n\r\n    const result = new Uint8Array(size);\r\n    result[0] = (size >> 24) & 0xff;\r\n    result[1] = (size >> 16) & 0xff;\r\n    result[2] = (size >> 8) & 0xff;\r\n    result[3] = size & 0xff;\r\n    result.set(type, 4);\r\n    // copy the payload into the result\r\n    for (i = 0, size = 8; i < len; i++) {\r\n      // copy payload[i] array @ offset size\r\n      result.set(payload[i], size);\r\n      size += payload[i].byteLength;\r\n    }\r\n    return result;\r\n  }\r\n\r\n  static hdlr(type) {\r\n    return MP4.box(MP4.types.hdlr, MP4.HDLR_TYPES[type]);\r\n  }\r\n\r\n  static mdat(data) {\r\n    return MP4.box(MP4.types.mdat, data);\r\n  }\r\n\r\n  static mdhd(timescale, duration) {\r\n    duration *= timescale;\r\n    const upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));\r\n    const lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));\r\n    return MP4.box(\r\n      MP4.types.mdhd,\r\n      new Uint8Array([\r\n        0x01, // version 1\r\n        0x00,\r\n        0x00,\r\n        0x00, // flags\r\n        0x00,\r\n        0x00,\r\n        0x00,\r\n        0x00,\r\n        0x00,\r\n        0x00,\r\n        0x00,\r\n        0x02, // creation_time\r\n        0x00,\r\n        0x00,\r\n        0x00,\r\n        0x00,\r\n        0x00,\r\n        0x00,\r\n        0x00,\r\n        0x03, // modification_time\r\n        (timescale >> 24) & 0xff,\r\n        (timescale >> 16) & 0xff,\r\n        (timescale >> 8) & 0xff,\r\n        timescale & 0xff, // timescale\r\n        upperWordDuration >> 24,\r\n        (upperWordDuration >> 16) & 0xff,\r\n        (upperWordDuration >> 8) & 0xff,\r\n        upperWordDuration & 0xff,\r\n        lowerWordDuration >> 24,\r\n        (lowerWordDuration >> 16) & 0xff,\r\n        (lowerWordDuration >> 8) & 0xff,\r\n        lowerWordDuration & 0xff,\r\n        0x55,\r\n        0xc4, // 'und' language (undetermined)\r\n        0x00,\r\n        0x00,\r\n      ]),\r\n    );\r\n  }\r\n\r\n  static mdia(track) {\r\n    return MP4.box(\r\n      MP4.types.mdia,\r\n      MP4.mdhd(track.timescale, track.duration),\r\n      MP4.hdlr(track.type),\r\n      MP4.minf(track),\r\n    );\r\n  }\r\n\r\n  static mfhd(sequenceNumber) {\r\n    return MP4.box(\r\n      MP4.types.mfhd,\r\n      new Uint8Array([\r\n        0x00,\r\n        0x00,\r\n        0x00,\r\n        0x00, // flags\r\n        sequenceNumber >> 24,\r\n        (sequenceNumber >> 16) & 0xff,\r\n        (sequenceNumber >> 8) & 0xff,\r\n        sequenceNumber & 0xff, // sequence_number\r\n      ]),\r\n    );\r\n  }\r\n\r\n  static minf(track) {\r\n    if (track.type === 'audio') {\r\n      return MP4.box(\r\n        MP4.types.minf,\r\n        MP4.box(MP4.types.smhd, MP4.SMHD),\r\n        MP4.DINF,\r\n        MP4.stbl(track),\r\n      );\r\n    } else {\r\n      return MP4.box(\r\n        MP4.types.minf,\r\n        MP4.box(MP4.types.vmhd, MP4.VMHD),\r\n        MP4.DINF,\r\n        MP4.stbl(track),\r\n      );\r\n    }\r\n  }\r\n\r\n  static moof(sn, baseMediaDecodeTime, track) {\r\n    return MP4.box(\r\n      MP4.types.moof,\r\n      MP4.mfhd(sn),\r\n      MP4.traf(track, baseMediaDecodeTime),\r\n    );\r\n  }\r\n\r\n  static moov(tracks) {\r\n    let i = tracks.length;\r\n    const boxes: Uint8Array[] = [];\r\n\r\n    while (i--) {\r\n      boxes[i] = MP4.trak(tracks[i]);\r\n    }\r\n\r\n    return MP4.box.apply(\r\n      null,\r\n      [MP4.types.moov, MP4.mvhd(tracks[0].timescale, tracks[0].duration)]\r\n        .concat(boxes)\r\n        .concat(MP4.mvex(tracks)),\r\n    );\r\n  }\r\n\r\n  static mvex(tracks) {\r\n    let i = tracks.length;\r\n    const boxes: Uint8Array[] = [];\r\n\r\n    while (i--) {\r\n      boxes[i] = MP4.trex(tracks[i]);\r\n    }\r\n\r\n    return MP4.box.apply(null, [MP4.types.mvex, ...boxes]);\r\n  }\r\n\r\n  static mvhd(timescale, duration) {\r\n    duration *= timescale;\r\n    const upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));\r\n    const lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));\r\n    const bytes = new Uint8Array([\r\n      0x01, // version 1\r\n      0x00,\r\n      0x00,\r\n      0x00, // flags\r\n      0x00,\r\n      0x00,\r\n      0x00,\r\n      0x00,\r\n      0x00,\r\n      0x00,\r\n      0x00,\r\n      0x02, // creation_time\r\n      0x00,\r\n      0x00,\r\n      0x00,\r\n      0x00,\r\n      0x00,\r\n      0x00,\r\n      0x00,\r\n      0x03, // modification_time\r\n      (timescale >> 24) & 0xff,\r\n      (timescale >> 16) & 0xff,\r\n      (timescale >> 8) & 0xff,\r\n      timescale & 0xff, // timescale\r\n      upperWordDuration >> 24,\r\n      (upperWordDuration >> 16) & 0xff,\r\n      (upperWordDuration >> 8) & 0xff,\r\n      upperWordDuration & 0xff,\r\n      lowerWordDuration >> 24,\r\n      (lowerWordDuration >> 16) & 0xff,\r\n      (lowerWordDuration >> 8) & 0xff,\r\n      lowerWordDuration & 0xff,\r\n      0x00,\r\n      0x01,\r\n      0x00,\r\n      0x00, // 1.0 rate\r\n      0x01,\r\n      0x00, // 1.0 volume\r\n      0x00,\r\n      0x00, // reserved\r\n      0x00,\r\n      0x00,\r\n      0x00,\r\n      0x00, // reserved\r\n      0x00,\r\n      0x00,\r\n      0x00,\r\n      0x00, // reserved\r\n      0x00,\r\n      0x01,\r\n      0x00,\r\n      0x00,\r\n      0x00,\r\n      0x00,\r\n      0x00,\r\n      0x00,\r\n      0x00,\r\n      0x00,\r\n      0x00,\r\n      0x00,\r\n      0x00,\r\n      0x00,\r\n      0x00,\r\n      0x00,\r\n      0x00,\r\n      0x01,\r\n      0x00,\r\n      0x00,\r\n      0x00,\r\n      0x00,\r\n      0x00,\r\n      0x00,\r\n      0x00,\r\n      0x00,\r\n      0x00,\r\n      0x00,\r\n      0x00,\r\n      0x00,\r\n      0x00,\r\n      0x00,\r\n      0x40,\r\n      0x00,\r\n      0x00,\r\n      0x00, // transformation: unity matrix\r\n      0x00,\r\n      0x00,\r\n      0x00,\r\n      0x00,\r\n      0x00,\r\n      0x00,\r\n      0x00,\r\n      0x00,\r\n      0x00,\r\n      0x00,\r\n      0x00,\r\n      0x00,\r\n      0x00,\r\n      0x00,\r\n      0x00,\r\n      0x00,\r\n      0x00,\r\n      0x00,\r\n      0x00,\r\n      0x00,\r\n      0x00,\r\n      0x00,\r\n      0x00,\r\n      0x00, // pre_defined\r\n      0xff,\r\n      0xff,\r\n      0xff,\r\n      0xff, // next_track_ID\r\n    ]);\r\n    return MP4.box(MP4.types.mvhd, bytes);\r\n  }\r\n\r\n  static sdtp(track) {\r\n    const samples = track.samples || [];\r\n    const bytes = new Uint8Array(4 + samples.length);\r\n    let i;\r\n    let flags;\r\n    // leave the full box header (4 bytes) all zero\r\n    // write the sample table\r\n    for (i = 0; i < samples.length; i++) {\r\n      flags = samples[i].flags;\r\n      bytes[i + 4] =\r\n        (flags.dependsOn << 4) |\r\n        (flags.isDependedOn << 2) |\r\n        flags.hasRedundancy;\r\n    }\r\n\r\n    return MP4.box(MP4.types.sdtp, bytes);\r\n  }\r\n\r\n  static stbl(track) {\r\n    return MP4.box(\r\n      MP4.types.stbl,\r\n      MP4.stsd(track),\r\n      MP4.box(MP4.types.stts, MP4.STTS),\r\n      MP4.box(MP4.types.stsc, MP4.STSC),\r\n      MP4.box(MP4.types.stsz, MP4.STSZ),\r\n      MP4.box(MP4.types.stco, MP4.STCO),\r\n    );\r\n  }\r\n\r\n  static avc1(track) {\r\n    let sps: number[] = [];\r\n    let pps: number[] = [];\r\n    let i;\r\n    let data;\r\n    let len;\r\n    // assemble the SPSs\r\n\r\n    for (i = 0; i < track.sps.length; i++) {\r\n      data = track.sps[i];\r\n      len = data.byteLength;\r\n      sps.push((len >>> 8) & 0xff);\r\n      sps.push(len & 0xff);\r\n\r\n      // SPS\r\n      sps = sps.concat(Array.prototype.slice.call(data));\r\n    }\r\n\r\n    // assemble the PPSs\r\n    for (i = 0; i < track.pps.length; i++) {\r\n      data = track.pps[i];\r\n      len = data.byteLength;\r\n      pps.push((len >>> 8) & 0xff);\r\n      pps.push(len & 0xff);\r\n\r\n      pps = pps.concat(Array.prototype.slice.call(data));\r\n    }\r\n\r\n    const avcc = MP4.box(\r\n      MP4.types.avcC,\r\n      new Uint8Array(\r\n        [\r\n          0x01, // version\r\n          sps[3], // profile\r\n          sps[4], // profile compat\r\n          sps[5], // level\r\n          0xfc | 3, // lengthSizeMinusOne, hard-coded to 4 bytes\r\n          0xe0 | track.sps.length, // 3bit reserved (111) + numOfSequenceParameterSets\r\n        ]\r\n          .concat(sps)\r\n          .concat([\r\n            track.pps.length, // numOfPictureParameterSets\r\n          ])\r\n          .concat(pps),\r\n      ),\r\n    ); // \"PPS\"\r\n    const width = track.width;\r\n    const height = track.height;\r\n    const hSpacing = track.pixelRatio[0];\r\n    const vSpacing = track.pixelRatio[1];\r\n\r\n    return MP4.box(\r\n      MP4.types.avc1,\r\n      new Uint8Array([\r\n        0x00,\r\n        0x00,\r\n        0x00, // reserved\r\n        0x00,\r\n        0x00,\r\n        0x00, // reserved\r\n        0x00,\r\n        0x01, // data_reference_index\r\n        0x00,\r\n        0x00, // pre_defined\r\n        0x00,\r\n        0x00, // reserved\r\n        0x00,\r\n        0x00,\r\n        0x00,\r\n        0x00,\r\n        0x00,\r\n        0x00,\r\n        0x00,\r\n        0x00,\r\n        0x00,\r\n        0x00,\r\n        0x00,\r\n        0x00, // pre_defined\r\n        (width >> 8) & 0xff,\r\n        width & 0xff, // width\r\n        (height >> 8) & 0xff,\r\n        height & 0xff, // height\r\n        0x00,\r\n        0x48,\r\n        0x00,\r\n        0x00, // horizresolution\r\n        0x00,\r\n        0x48,\r\n        0x00,\r\n        0x00, // vertresolution\r\n        0x00,\r\n        0x00,\r\n        0x00,\r\n        0x00, // reserved\r\n        0x00,\r\n        0x01, // frame_count\r\n        0x12,\r\n        0x64,\r\n        0x61,\r\n        0x69,\r\n        0x6c, // dailymotion/hls.js\r\n        0x79,\r\n        0x6d,\r\n        0x6f,\r\n        0x74,\r\n        0x69,\r\n        0x6f,\r\n        0x6e,\r\n        0x2f,\r\n        0x68,\r\n        0x6c,\r\n        0x73,\r\n        0x2e,\r\n        0x6a,\r\n        0x73,\r\n        0x00,\r\n        0x00,\r\n        0x00,\r\n        0x00,\r\n        0x00,\r\n        0x00,\r\n        0x00,\r\n        0x00,\r\n        0x00,\r\n        0x00,\r\n        0x00,\r\n        0x00,\r\n        0x00, // compressorname\r\n        0x00,\r\n        0x18, // depth = 24\r\n        0x11,\r\n        0x11,\r\n      ]), // pre_defined = -1\r\n      avcc,\r\n      MP4.box(\r\n        MP4.types.btrt,\r\n        new Uint8Array([\r\n          0x00,\r\n          0x1c,\r\n          0x9c,\r\n          0x80, // bufferSizeDB\r\n          0x00,\r\n          0x2d,\r\n          0xc6,\r\n          0xc0, // maxBitrate\r\n          0x00,\r\n          0x2d,\r\n          0xc6,\r\n          0xc0,\r\n        ]),\r\n      ), // avgBitrate\r\n      MP4.box(\r\n        MP4.types.pasp,\r\n        new Uint8Array([\r\n          hSpacing >> 24, // hSpacing\r\n          (hSpacing >> 16) & 0xff,\r\n          (hSpacing >> 8) & 0xff,\r\n          hSpacing & 0xff,\r\n          vSpacing >> 24, // vSpacing\r\n          (vSpacing >> 16) & 0xff,\r\n          (vSpacing >> 8) & 0xff,\r\n          vSpacing & 0xff,\r\n        ]),\r\n      ),\r\n    );\r\n  }\r\n\r\n  static esds(track) {\r\n    const configlen = track.config.length;\r\n    return new Uint8Array(\r\n      [\r\n        0x00, // version 0\r\n        0x00,\r\n        0x00,\r\n        0x00, // flags\r\n\r\n        0x03, // descriptor_type\r\n        0x17 + configlen, // length\r\n        0x00,\r\n        0x01, // es_id\r\n        0x00, // stream_priority\r\n\r\n        0x04, // descriptor_type\r\n        0x0f + configlen, // length\r\n        0x40, // codec : mpeg4_audio\r\n        0x15, // stream_type\r\n        0x00,\r\n        0x00,\r\n        0x00, // buffer_size\r\n        0x00,\r\n        0x00,\r\n        0x00,\r\n        0x00, // maxBitrate\r\n        0x00,\r\n        0x00,\r\n        0x00,\r\n        0x00, // avgBitrate\r\n\r\n        0x05, // descriptor_type\r\n      ]\r\n        .concat([configlen])\r\n        .concat(track.config)\r\n        .concat([0x06, 0x01, 0x02]),\r\n    ); // GASpecificConfig)); // length + audio config descriptor\r\n  }\r\n\r\n  static audioStsd(track) {\r\n    const samplerate = track.samplerate;\r\n    return new Uint8Array([\r\n      0x00,\r\n      0x00,\r\n      0x00, // reserved\r\n      0x00,\r\n      0x00,\r\n      0x00, // reserved\r\n      0x00,\r\n      0x01, // data_reference_index\r\n      0x00,\r\n      0x00,\r\n      0x00,\r\n      0x00,\r\n      0x00,\r\n      0x00,\r\n      0x00,\r\n      0x00, // reserved\r\n      0x00,\r\n      track.channelCount, // channelcount\r\n      0x00,\r\n      0x10, // sampleSize:16bits\r\n      0x00,\r\n      0x00,\r\n      0x00,\r\n      0x00, // reserved2\r\n      (samplerate >> 8) & 0xff,\r\n      samplerate & 0xff, //\r\n      0x00,\r\n      0x00,\r\n    ]);\r\n  }\r\n\r\n  static mp4a(track) {\r\n    return MP4.box(\r\n      MP4.types.mp4a,\r\n      MP4.audioStsd(track),\r\n      MP4.box(MP4.types.esds, MP4.esds(track)),\r\n    );\r\n  }\r\n\r\n  static mp3(track) {\r\n    return MP4.box(MP4.types['.mp3'], MP4.audioStsd(track));\r\n  }\r\n\r\n  static ac3(track) {\r\n    return MP4.box(\r\n      MP4.types['ac-3'],\r\n      MP4.audioStsd(track),\r\n      MP4.box(MP4.types.dac3, track.config),\r\n    );\r\n  }\r\n\r\n  static stsd(track) {\r\n    if (track.type === 'audio') {\r\n      if (track.segmentCodec === 'mp3' && track.codec === 'mp3') {\r\n        return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp3(track));\r\n      }\r\n      if (track.segmentCodec === 'ac3') {\r\n        return MP4.box(MP4.types.stsd, MP4.STSD, MP4.ac3(track));\r\n      }\r\n      return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp4a(track));\r\n    } else if (track.segmentCodec === 'avc') {\r\n      return MP4.box(MP4.types.stsd, MP4.STSD, MP4.avc1(track));\r\n    } else {\r\n      return MP4.box(MP4.types.stsd, MP4.STSD, MP4.hvc1(track));\r\n    }\r\n  }\r\n\r\n  static tkhd(track) {\r\n    const id = track.id;\r\n    const duration = track.duration * track.timescale;\r\n    const width = track.width;\r\n    const height = track.height;\r\n    const upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));\r\n    const lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));\r\n    return MP4.box(\r\n      MP4.types.tkhd,\r\n      new Uint8Array([\r\n        0x01, // version 1\r\n        0x00,\r\n        0x00,\r\n        0x07, // flags\r\n        0x00,\r\n        0x00,\r\n        0x00,\r\n        0x00,\r\n        0x00,\r\n        0x00,\r\n        0x00,\r\n        0x02, // creation_time\r\n        0x00,\r\n        0x00,\r\n        0x00,\r\n        0x00,\r\n        0x00,\r\n        0x00,\r\n        0x00,\r\n        0x03, // modification_time\r\n        (id >> 24) & 0xff,\r\n        (id >> 16) & 0xff,\r\n        (id >> 8) & 0xff,\r\n        id & 0xff, // track_ID\r\n        0x00,\r\n        0x00,\r\n        0x00,\r\n        0x00, // reserved\r\n        upperWordDuration >> 24,\r\n        (upperWordDuration >> 16) & 0xff,\r\n        (upperWordDuration >> 8) & 0xff,\r\n        upperWordDuration & 0xff,\r\n        lowerWordDuration >> 24,\r\n        (lowerWordDuration >> 16) & 0xff,\r\n        (lowerWordDuration >> 8) & 0xff,\r\n        lowerWordDuration & 0xff,\r\n        0x00,\r\n        0x00,\r\n        0x00,\r\n        0x00,\r\n        0x00,\r\n        0x00,\r\n        0x00,\r\n        0x00, // reserved\r\n        0x00,\r\n        0x00, // layer\r\n        0x00,\r\n        0x00, // alternate_group\r\n        0x00,\r\n        0x00, // non-audio track volume\r\n        0x00,\r\n        0x00, // reserved\r\n        0x00,\r\n        0x01,\r\n        0x00,\r\n        0x00,\r\n        0x00,\r\n        0x00,\r\n        0x00,\r\n        0x00,\r\n        0x00,\r\n        0x00,\r\n        0x00,\r\n        0x00,\r\n        0x00,\r\n        0x00,\r\n        0x00,\r\n        0x00,\r\n        0x00,\r\n        0x01,\r\n        0x00,\r\n        0x00,\r\n        0x00,\r\n        0x00,\r\n        0x00,\r\n        0x00,\r\n        0x00,\r\n        0x00,\r\n        0x00,\r\n        0x00,\r\n        0x00,\r\n        0x00,\r\n        0x00,\r\n        0x00,\r\n        0x40,\r\n        0x00,\r\n        0x00,\r\n        0x00, // transformation: unity matrix\r\n        (width >> 8) & 0xff,\r\n        width & 0xff,\r\n        0x00,\r\n        0x00, // width\r\n        (height >> 8) & 0xff,\r\n        height & 0xff,\r\n        0x00,\r\n        0x00, // height\r\n      ]),\r\n    );\r\n  }\r\n\r\n  static traf(track, baseMediaDecodeTime) {\r\n    const sampleDependencyTable = MP4.sdtp(track);\r\n    const id = track.id;\r\n    const upperWordBaseMediaDecodeTime = Math.floor(\r\n      baseMediaDecodeTime / (UINT32_MAX + 1),\r\n    );\r\n    const lowerWordBaseMediaDecodeTime = Math.floor(\r\n      baseMediaDecodeTime % (UINT32_MAX + 1),\r\n    );\r\n    return MP4.box(\r\n      MP4.types.traf,\r\n      MP4.box(\r\n        MP4.types.tfhd,\r\n        new Uint8Array([\r\n          0x00, // version 0\r\n          0x00,\r\n          0x00,\r\n          0x00, // flags\r\n          id >> 24,\r\n          (id >> 16) & 0xff,\r\n          (id >> 8) & 0xff,\r\n          id & 0xff, // track_ID\r\n        ]),\r\n      ),\r\n      MP4.box(\r\n        MP4.types.tfdt,\r\n        new Uint8Array([\r\n          0x01, // version 1\r\n          0x00,\r\n          0x00,\r\n          0x00, // flags\r\n          upperWordBaseMediaDecodeTime >> 24,\r\n          (upperWordBaseMediaDecodeTime >> 16) & 0xff,\r\n          (upperWordBaseMediaDecodeTime >> 8) & 0xff,\r\n          upperWordBaseMediaDecodeTime & 0xff,\r\n          lowerWordBaseMediaDecodeTime >> 24,\r\n          (lowerWordBaseMediaDecodeTime >> 16) & 0xff,\r\n          (lowerWordBaseMediaDecodeTime >> 8) & 0xff,\r\n          lowerWordBaseMediaDecodeTime & 0xff,\r\n        ]),\r\n      ),\r\n      MP4.trun(\r\n        track,\r\n        sampleDependencyTable.length +\r\n          16 + // tfhd\r\n          20 + // tfdt\r\n          8 + // traf header\r\n          16 + // mfhd\r\n          8 + // moof header\r\n          8,\r\n      ), // mdat header\r\n      sampleDependencyTable,\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Generate a track box.\r\n   * @param track a track definition\r\n   */\r\n  static trak(track) {\r\n    track.duration = track.duration || 0xffffffff;\r\n    return MP4.box(MP4.types.trak, MP4.tkhd(track), MP4.mdia(track));\r\n  }\r\n\r\n  static trex(track) {\r\n    const id = track.id;\r\n    return MP4.box(\r\n      MP4.types.trex,\r\n      new Uint8Array([\r\n        0x00, // version 0\r\n        0x00,\r\n        0x00,\r\n        0x00, // flags\r\n        id >> 24,\r\n        (id >> 16) & 0xff,\r\n        (id >> 8) & 0xff,\r\n        id & 0xff, // track_ID\r\n        0x00,\r\n        0x00,\r\n        0x00,\r\n        0x01, // default_sample_description_index\r\n        0x00,\r\n        0x00,\r\n        0x00,\r\n        0x00, // default_sample_duration\r\n        0x00,\r\n        0x00,\r\n        0x00,\r\n        0x00, // default_sample_size\r\n        0x00,\r\n        0x01,\r\n        0x00,\r\n        0x01, // default_sample_flags\r\n      ]),\r\n    );\r\n  }\r\n\r\n  static trun(track, offset) {\r\n    const samples = track.samples || [];\r\n    const len = samples.length;\r\n    const arraylen = 12 + 16 * len;\r\n    const array = new Uint8Array(arraylen);\r\n    let i;\r\n    let sample;\r\n    let duration;\r\n    let size;\r\n    let flags;\r\n    let cts;\r\n    offset += 8 + arraylen;\r\n    array.set(\r\n      [\r\n        track.type === 'video' ? 0x01 : 0x00, // version 1 for video with signed-int sample_composition_time_offset\r\n        0x00,\r\n        0x0f,\r\n        0x01, // flags\r\n        (len >>> 24) & 0xff,\r\n        (len >>> 16) & 0xff,\r\n        (len >>> 8) & 0xff,\r\n        len & 0xff, // sample_count\r\n        (offset >>> 24) & 0xff,\r\n        (offset >>> 16) & 0xff,\r\n        (offset >>> 8) & 0xff,\r\n        offset & 0xff, // data_offset\r\n      ],\r\n      0,\r\n    );\r\n    for (i = 0; i < len; i++) {\r\n      sample = samples[i];\r\n      duration = sample.duration;\r\n      size = sample.size;\r\n      flags = sample.flags;\r\n      cts = sample.cts;\r\n      array.set(\r\n        [\r\n          (duration >>> 24) & 0xff,\r\n          (duration >>> 16) & 0xff,\r\n          (duration >>> 8) & 0xff,\r\n          duration & 0xff, // sample_duration\r\n          (size >>> 24) & 0xff,\r\n          (size >>> 16) & 0xff,\r\n          (size >>> 8) & 0xff,\r\n          size & 0xff, // sample_size\r\n          (flags.isLeading << 2) | flags.dependsOn,\r\n          (flags.isDependedOn << 6) |\r\n            (flags.hasRedundancy << 4) |\r\n            (flags.paddingValue << 1) |\r\n            flags.isNonSync,\r\n          flags.degradPrio & (0xf0 << 8),\r\n          flags.degradPrio & 0x0f, // sample_flags\r\n          (cts >>> 24) & 0xff,\r\n          (cts >>> 16) & 0xff,\r\n          (cts >>> 8) & 0xff,\r\n          cts & 0xff, // sample_composition_time_offset\r\n        ],\r\n        12 + 16 * i,\r\n      );\r\n    }\r\n    return MP4.box(MP4.types.trun, array);\r\n  }\r\n\r\n  static initSegment(tracks) {\r\n    if (!MP4.types) {\r\n      MP4.init();\r\n    }\r\n\r\n    const movie = MP4.moov(tracks);\r\n    const result = appendUint8Array(MP4.FTYP, movie);\r\n    return result;\r\n  }\r\n\r\n  static hvc1(track) {\r\n    const ps = track.params;\r\n    const units = [track.vps, track.sps, track.pps];\r\n    const NALuLengthSize = 4;\r\n    const config = new Uint8Array([\r\n      0x01,\r\n      (ps.general_profile_space << 6) |\r\n        (ps.general_tier_flag ? 32 : 0) |\r\n        ps.general_profile_idc,\r\n      ps.general_profile_compatibility_flags[0],\r\n      ps.general_profile_compatibility_flags[1],\r\n      ps.general_profile_compatibility_flags[2],\r\n      ps.general_profile_compatibility_flags[3],\r\n      ps.general_constraint_indicator_flags[0],\r\n      ps.general_constraint_indicator_flags[1],\r\n      ps.general_constraint_indicator_flags[2],\r\n      ps.general_constraint_indicator_flags[3],\r\n      ps.general_constraint_indicator_flags[4],\r\n      ps.general_constraint_indicator_flags[5],\r\n      ps.general_level_idc,\r\n      240 | (ps.min_spatial_segmentation_idc >> 8),\r\n      255 & ps.min_spatial_segmentation_idc,\r\n      252 | ps.parallelismType,\r\n      252 | ps.chroma_format_idc,\r\n      248 | ps.bit_depth_luma_minus8,\r\n      248 | ps.bit_depth_chroma_minus8,\r\n      0x00,\r\n      parseInt(ps.frame_rate.fps),\r\n      (NALuLengthSize - 1) |\r\n        (ps.temporal_id_nested << 2) |\r\n        (ps.num_temporal_layers << 3) |\r\n        (ps.frame_rate.fixed ? 64 : 0),\r\n      units.length,\r\n    ]);\r\n\r\n    // compute hvcC size in bytes\r\n    let length = config.length;\r\n    for (let i = 0; i < units.length; i += 1) {\r\n      length += 3;\r\n      for (let j = 0; j < units[i].length; j += 1) {\r\n        length += 2 + units[i][j].length;\r\n      }\r\n    }\r\n\r\n    const hvcC = new Uint8Array(length);\r\n    hvcC.set(config, 0);\r\n    length = config.length;\r\n    // append parameter set units: one vps, one or more sps and pps\r\n    const iMax = units.length - 1;\r\n    for (let i = 0; i < units.length; i += 1) {\r\n      hvcC.set(\r\n        new Uint8Array([\r\n          (32 + i) | (i === iMax ? 128 : 0),\r\n          0x00,\r\n          units[i].length,\r\n        ]),\r\n        length,\r\n      );\r\n      length += 3;\r\n      for (let j = 0; j < units[i].length; j += 1) {\r\n        hvcC.set(\r\n          new Uint8Array([units[i][j].length >> 8, units[i][j].length & 255]),\r\n          length,\r\n        );\r\n        length += 2;\r\n        hvcC.set(units[i][j], length);\r\n        length += units[i][j].length;\r\n      }\r\n    }\r\n    const hvcc = MP4.box(MP4.types.hvcC, hvcC);\r\n    const width = track.width;\r\n    const height = track.height;\r\n    const hSpacing = track.pixelRatio[0];\r\n    const vSpacing = track.pixelRatio[1];\r\n\r\n    return MP4.box(\r\n      MP4.types.hvc1,\r\n      new Uint8Array([\r\n        0x00,\r\n        0x00,\r\n        0x00, // reserved\r\n        0x00,\r\n        0x00,\r\n        0x00, // reserved\r\n        0x00,\r\n        0x01, // data_reference_index\r\n        0x00,\r\n        0x00, // pre_defined\r\n        0x00,\r\n        0x00, // reserved\r\n        0x00,\r\n        0x00,\r\n        0x00,\r\n        0x00,\r\n        0x00,\r\n        0x00,\r\n        0x00,\r\n        0x00,\r\n        0x00,\r\n        0x00,\r\n        0x00,\r\n        0x00, // pre_defined\r\n        (width >> 8) & 0xff,\r\n        width & 0xff, // width\r\n        (height >> 8) & 0xff,\r\n        height & 0xff, // height\r\n        0x00,\r\n        0x48,\r\n        0x00,\r\n        0x00, // horizresolution\r\n        0x00,\r\n        0x48,\r\n        0x00,\r\n        0x00, // vertresolution\r\n        0x00,\r\n        0x00,\r\n        0x00,\r\n        0x00, // reserved\r\n        0x00,\r\n        0x01, // frame_count\r\n        0x12,\r\n        0x64,\r\n        0x61,\r\n        0x69,\r\n        0x6c, // dailymotion/hls.js\r\n        0x79,\r\n        0x6d,\r\n        0x6f,\r\n        0x74,\r\n        0x69,\r\n        0x6f,\r\n        0x6e,\r\n        0x2f,\r\n        0x68,\r\n        0x6c,\r\n        0x73,\r\n        0x2e,\r\n        0x6a,\r\n        0x73,\r\n        0x00,\r\n        0x00,\r\n        0x00,\r\n        0x00,\r\n        0x00,\r\n        0x00,\r\n        0x00,\r\n        0x00,\r\n        0x00,\r\n        0x00,\r\n        0x00,\r\n        0x00,\r\n        0x00, // compressorname\r\n        0x00,\r\n        0x18, // depth = 24\r\n        0x11,\r\n        0x11,\r\n      ]), // pre_defined = -1\r\n      hvcc,\r\n      MP4.box(\r\n        MP4.types.btrt,\r\n        new Uint8Array([\r\n          0x00,\r\n          0x1c,\r\n          0x9c,\r\n          0x80, // bufferSizeDB\r\n          0x00,\r\n          0x2d,\r\n          0xc6,\r\n          0xc0, // maxBitrate\r\n          0x00,\r\n          0x2d,\r\n          0xc6,\r\n          0xc0,\r\n        ]),\r\n      ), // avgBitrate\r\n      MP4.box(\r\n        MP4.types.pasp,\r\n        new Uint8Array([\r\n          hSpacing >> 24, // hSpacing\r\n          (hSpacing >> 16) & 0xff,\r\n          (hSpacing >> 8) & 0xff,\r\n          hSpacing & 0xff,\r\n          vSpacing >> 24, // vSpacing\r\n          (vSpacing >> 16) & 0xff,\r\n          (vSpacing >> 8) & 0xff,\r\n          vSpacing & 0xff,\r\n        ]),\r\n      ),\r\n    );\r\n  }\r\n}\r\n\r\nexport default MP4;\r\n","import type { LoaderConfig } from '../config';\r\nimport type { Fragment } from '../loader/fragment';\r\nimport type { Part } from '../loader/fragment';\r\nimport type { KeyLoaderInfo } from '../loader/key-loader';\r\nimport type { LevelDetails } from '../loader/level-details';\r\nimport type { HlsUrlParameters } from './level';\r\n\r\nexport interface LoaderContext {\r\n  // target URL\r\n  url: string;\r\n  // loader response type (arraybuffer or default response type for playlist)\r\n  responseType: string;\r\n  // headers\r\n  headers?: Record<string, string>;\r\n  // start byte range offset\r\n  rangeStart?: number;\r\n  // end byte range offset\r\n  rangeEnd?: number;\r\n  // true if onProgress should report partial chunk of loaded content\r\n  progressData?: boolean;\r\n}\r\n\r\nexport interface FragmentLoaderContext extends LoaderContext {\r\n  frag: Fragment;\r\n  part: Part | null;\r\n  resetIV?: boolean;\r\n}\r\n\r\nexport interface KeyLoaderContext extends LoaderContext {\r\n  keyInfo: KeyLoaderInfo;\r\n  frag: Fragment;\r\n}\r\n\r\nexport interface LoaderConfiguration {\r\n  // LoaderConfig policy that overrides required settings\r\n  loadPolicy: LoaderConfig;\r\n  /**\r\n   * @deprecated use LoaderConfig timeoutRetry and errorRetry maxNumRetry\r\n   */\r\n  // Max number of load retries\r\n  maxRetry: number;\r\n  /**\r\n   * @deprecated use LoaderConfig maxTimeToFirstByteMs and maxLoadTimeMs\r\n   */\r\n  // Timeout after which `onTimeOut` callback will be triggered\r\n  //  when loading has not finished after that delay\r\n  timeout: number;\r\n  /**\r\n   * @deprecated use LoaderConfig timeoutRetry and errorRetry retryDelayMs\r\n   */\r\n  // Delay between an I/O error and following connection retry (ms).\r\n  // This to avoid spamming the server\r\n  retryDelay: number;\r\n  /**\r\n   * @deprecated use LoaderConfig timeoutRetry and errorRetry maxRetryDelayMs\r\n   */\r\n  // max connection retry delay (ms)\r\n  maxRetryDelay: number;\r\n  // When streaming progressively, this is the minimum chunk size required to emit a PROGRESS event\r\n  highWaterMark?: number;\r\n}\r\n\r\nexport interface LoaderResponse {\r\n  url: string;\r\n  data?: string | ArrayBuffer | Object;\r\n  // Errors can include HTTP status code and error message\r\n  // Successful responses should include status code 200\r\n  code?: number;\r\n  text?: string;\r\n}\r\n\r\nexport interface LoaderStats {\r\n  aborted: boolean;\r\n  loaded: number;\r\n  retry: number;\r\n  total: number;\r\n  chunkCount: number;\r\n  bwEstimate: number;\r\n  loading: HlsProgressivePerformanceTiming;\r\n  parsing: HlsPerformanceTiming;\r\n  buffering: HlsProgressivePerformanceTiming;\r\n}\r\n\r\nexport interface HlsPerformanceTiming {\r\n  start: number;\r\n  end: number;\r\n}\r\n\r\nexport interface HlsChunkPerformanceTiming extends HlsPerformanceTiming {\r\n  executeStart: number;\r\n  executeEnd: number;\r\n}\r\n\r\nexport interface HlsProgressivePerformanceTiming extends HlsPerformanceTiming {\r\n  first: number;\r\n}\r\n\r\nexport type LoaderOnSuccess<T extends LoaderContext> = (\r\n  response: LoaderResponse,\r\n  stats: LoaderStats,\r\n  context: T,\r\n  networkDetails: any,\r\n) => void;\r\n\r\nexport type LoaderOnProgress<T extends LoaderContext> = (\r\n  stats: LoaderStats,\r\n  context: T,\r\n  data: string | ArrayBuffer,\r\n  networkDetails: any,\r\n) => void;\r\n\r\nexport type LoaderOnError<T extends LoaderContext> = (\r\n  error: {\r\n    // error status code\r\n    code: number;\r\n    // error description\r\n    text: string;\r\n  },\r\n  context: T,\r\n  networkDetails: any,\r\n  stats: LoaderStats,\r\n) => void;\r\n\r\nexport type LoaderOnTimeout<T extends LoaderContext> = (\r\n  stats: LoaderStats,\r\n  context: T,\r\n  networkDetails: any,\r\n) => void;\r\n\r\nexport type LoaderOnAbort<T extends LoaderContext> = (\r\n  stats: LoaderStats,\r\n  context: T,\r\n  networkDetails: any,\r\n) => void;\r\n\r\nexport interface LoaderCallbacks<T extends LoaderContext> {\r\n  onSuccess: LoaderOnSuccess<T>;\r\n  onError: LoaderOnError<T>;\r\n  onTimeout: LoaderOnTimeout<T>;\r\n  onAbort?: LoaderOnAbort<T>;\r\n  onProgress?: LoaderOnProgress<T>;\r\n}\r\n\r\nexport interface Loader<T extends LoaderContext> {\r\n  destroy(): void;\r\n  abort(): void;\r\n  load(\r\n    context: T,\r\n    config: LoaderConfiguration,\r\n    callbacks: LoaderCallbacks<T>,\r\n  ): void;\r\n  /**\r\n   * `getCacheAge()` is called by hls.js to get the duration that a given object\r\n   * has been sitting in a cache proxy when playing live.  If implemented,\r\n   * this should return a value in seconds.\r\n   *\r\n   * For HTTP based loaders, this should return the contents of the \"age\" header.\r\n   *\r\n   * @returns time object being lodaded\r\n   */\r\n  getCacheAge?: () => number | null;\r\n  getResponseHeader?: (name: string) => string | null;\r\n  context: T | null;\r\n  stats: LoaderStats;\r\n}\r\n\r\nexport const enum PlaylistContextType {\r\n  MANIFEST = 'manifest',\r\n  LEVEL = 'level',\r\n  AUDIO_TRACK = 'audioTrack',\r\n  SUBTITLE_TRACK = 'subtitleTrack',\r\n}\r\n\r\nexport const enum PlaylistLevelType {\r\n  MAIN = 'main',\r\n  AUDIO = 'audio',\r\n  SUBTITLE = 'subtitle',\r\n}\r\n\r\nexport interface PlaylistLoaderContext extends LoaderContext {\r\n  type: PlaylistContextType;\r\n  // the level index to load\r\n  level: number | null;\r\n  // level or track id from LevelLoadingData / TrackLoadingData\r\n  id: number | null;\r\n  // track group id\r\n  groupId?: string;\r\n  // internal representation of a parsed m3u8 level playlist\r\n  levelDetails?: LevelDetails;\r\n  // Blocking playlist request delivery directives (or null id none were added to playlist url\r\n  deliveryDirectives: HlsUrlParameters | null;\r\n}\r\n","const MPEG_TS_CLOCK_FREQ_HZ = 90000;\r\n\r\nexport type RationalTimestamp = {\r\n  baseTime: number; // ticks\r\n  timescale: number; // ticks per second\r\n};\r\n\r\nexport function toTimescaleFromBase(\r\n  baseTime: number,\r\n  destScale: number,\r\n  srcBase: number = 1,\r\n  round: boolean = false,\r\n): number {\r\n  const result = baseTime * destScale * srcBase; // equivalent to `(value * scale) / (1 / base)`\r\n  return round ? Math.round(result) : result;\r\n}\r\n\r\nexport function toTimescaleFromScale(\r\n  baseTime: number,\r\n  destScale: number,\r\n  srcScale: number = 1,\r\n  round: boolean = false,\r\n): number {\r\n  return toTimescaleFromBase(baseTime, destScale, 1 / srcScale, round);\r\n}\r\n\r\nexport function toMsFromMpegTsClock(\r\n  baseTime: number,\r\n  round: boolean = false,\r\n): number {\r\n  return toTimescaleFromBase(baseTime, 1000, 1 / MPEG_TS_CLOCK_FREQ_HZ, round);\r\n}\r\n\r\nexport function toMpegTsClockFromTimescale(\r\n  baseTime: number,\r\n  srcScale: number = 1,\r\n): number {\r\n  return toTimescaleFromBase(baseTime, MPEG_TS_CLOCK_FREQ_HZ, 1 / srcScale);\r\n}\r\n","import AAC from './aac-helper';\r\nimport MP4 from './mp4-generator';\r\nimport type { HlsEventEmitter } from '../events';\r\nimport { Events } from '../events';\r\nimport { ErrorTypes, ErrorDetails } from '../errors';\r\nimport { logger } from '../utils/logger';\r\nimport {\r\n  InitSegmentData,\r\n  Remuxer,\r\n  RemuxerResult,\r\n  RemuxedMetadata,\r\n  RemuxedTrack,\r\n  RemuxedUserdata,\r\n} from '../types/remuxer';\r\nimport { PlaylistLevelType } from '../types/loader';\r\nimport {\r\n  RationalTimestamp,\r\n  toMsFromMpegTsClock,\r\n} from '../utils/timescale-conversion';\r\nimport type {\r\n  AudioSample,\r\n  VideoSample,\r\n  DemuxedAudioTrack,\r\n  DemuxedVideoTrack,\r\n  DemuxedMetadataTrack,\r\n  DemuxedUserdataTrack,\r\n} from '../types/demuxer';\r\nimport type { TrackSet } from '../types/track';\r\nimport type { SourceBufferName } from '../types/buffer';\r\nimport type { Fragment } from '../loader/fragment';\r\nimport type { HlsConfig } from '../config';\r\n\r\nconst MAX_SILENT_FRAME_DURATION = 10 * 1000; // 10 seconds\r\nconst AAC_SAMPLES_PER_FRAME = 1024;\r\nconst MPEG_AUDIO_SAMPLE_PER_FRAME = 1152;\r\nconst AC3_SAMPLES_PER_FRAME = 1536;\r\n\r\nlet chromeVersion: number | null = null;\r\nlet safariWebkitVersion: number | null = null;\r\n\r\nexport default class MP4Remuxer implements Remuxer {\r\n  private observer: HlsEventEmitter;\r\n  private config: HlsConfig;\r\n  private typeSupported: any;\r\n  private ISGenerated: boolean = false;\r\n  private _initPTS: RationalTimestamp | null = null;\r\n  private _initDTS: RationalTimestamp | null = null;\r\n  private nextAvcDts: number | null = null;\r\n  private nextAudioPts: number | null = null;\r\n  private videoSampleDuration: number | null = null;\r\n  private isAudioContiguous: boolean = false;\r\n  private isVideoContiguous: boolean = false;\r\n  private videoTrackConfig?: {\r\n    width?: number;\r\n    height?: number;\r\n    pixelRatio?: [number, number];\r\n  };\r\n\r\n  constructor(\r\n    observer: HlsEventEmitter,\r\n    config: HlsConfig,\r\n    typeSupported,\r\n    vendor = '',\r\n  ) {\r\n    this.observer = observer;\r\n    this.config = config;\r\n    this.typeSupported = typeSupported;\r\n    this.ISGenerated = false;\r\n\r\n    if (chromeVersion === null) {\r\n      const userAgent = navigator.userAgent || '';\r\n      const result = userAgent.match(/Chrome\\/(\\d+)/i);\r\n      chromeVersion = result ? parseInt(result[1]) : 0;\r\n    }\r\n    if (safariWebkitVersion === null) {\r\n      const result = navigator.userAgent.match(/Safari\\/(\\d+)/i);\r\n      safariWebkitVersion = result ? parseInt(result[1]) : 0;\r\n    }\r\n  }\r\n\r\n  destroy() {\r\n    // @ts-ignore\r\n    this.config = this.videoTrackConfig = this._initPTS = this._initDTS = null;\r\n  }\r\n\r\n  resetTimeStamp(defaultTimeStamp: RationalTimestamp | null) {\r\n    logger.log('[mp4-remuxer]: initPTS & initDTS reset');\r\n    this._initPTS = this._initDTS = defaultTimeStamp;\r\n  }\r\n\r\n  resetNextTimestamp() {\r\n    logger.log('[mp4-remuxer]: reset next timestamp');\r\n    this.isVideoContiguous = false;\r\n    this.isAudioContiguous = false;\r\n  }\r\n\r\n  resetInitSegment() {\r\n    logger.log('[mp4-remuxer]: ISGenerated flag reset');\r\n    this.ISGenerated = false;\r\n    this.videoTrackConfig = undefined;\r\n  }\r\n\r\n  getVideoStartPts(videoSamples) {\r\n    let rolloverDetected = false;\r\n    const startPTS = videoSamples.reduce((minPTS, sample) => {\r\n      const delta = sample.pts - minPTS;\r\n      if (delta < -4294967296) {\r\n        // 2^32, see PTSNormalize for reasoning, but we're hitting a rollover here, and we don't want that to impact the timeOffset calculation\r\n        rolloverDetected = true;\r\n        return normalizePts(minPTS, sample.pts);\r\n      } else if (delta > 0) {\r\n        return minPTS;\r\n      } else {\r\n        return sample.pts;\r\n      }\r\n    }, videoSamples[0].pts);\r\n    if (rolloverDetected) {\r\n      logger.debug('PTS rollover detected');\r\n    }\r\n    return startPTS;\r\n  }\r\n\r\n  remux(\r\n    audioTrack: DemuxedAudioTrack,\r\n    videoTrack: DemuxedVideoTrack,\r\n    id3Track: DemuxedMetadataTrack,\r\n    textTrack: DemuxedUserdataTrack,\r\n    timeOffset: number,\r\n    accurateTimeOffset: boolean,\r\n    flush: boolean,\r\n    playlistType: PlaylistLevelType,\r\n  ): RemuxerResult {\r\n    let video: RemuxedTrack | undefined;\r\n    let audio: RemuxedTrack | undefined;\r\n    let initSegment: InitSegmentData | undefined;\r\n    let text: RemuxedUserdata | undefined;\r\n    let id3: RemuxedMetadata | undefined;\r\n    let independent: boolean | undefined;\r\n    let audioTimeOffset = timeOffset;\r\n    let videoTimeOffset = timeOffset;\r\n\r\n    // If we're remuxing audio and video progressively, wait until we've received enough samples for each track before proceeding.\r\n    // This is done to synchronize the audio and video streams. We know if the current segment will have samples if the \"pid\"\r\n    // parameter is greater than -1. The pid is set when the PMT is parsed, which contains the tracks list.\r\n    // However, if the initSegment has already been generated, or we've reached the end of a segment (flush),\r\n    // then we can remux one track without waiting for the other.\r\n    const hasAudio = audioTrack.pid > -1;\r\n    const hasVideo = videoTrack.pid > -1;\r\n    const length = videoTrack.samples.length;\r\n    const enoughAudioSamples = audioTrack.samples.length > 0;\r\n    const enoughVideoSamples = (flush && length > 0) || length > 1;\r\n    const canRemuxAvc =\r\n      ((!hasAudio || enoughAudioSamples) &&\r\n        (!hasVideo || enoughVideoSamples)) ||\r\n      this.ISGenerated ||\r\n      flush;\r\n\r\n    if (canRemuxAvc) {\r\n      if (this.ISGenerated) {\r\n        const config = this.videoTrackConfig;\r\n        if (\r\n          config &&\r\n          (videoTrack.width !== config.width ||\r\n            videoTrack.height !== config.height ||\r\n            videoTrack.pixelRatio?.[0] !== config.pixelRatio?.[0] ||\r\n            videoTrack.pixelRatio?.[1] !== config.pixelRatio?.[1])\r\n        ) {\r\n          this.resetInitSegment();\r\n        }\r\n      } else {\r\n        initSegment = this.generateIS(\r\n          audioTrack,\r\n          videoTrack,\r\n          timeOffset,\r\n          accurateTimeOffset,\r\n        );\r\n      }\r\n\r\n      const isVideoContiguous = this.isVideoContiguous;\r\n      let firstKeyFrameIndex = -1;\r\n      let firstKeyFramePTS;\r\n\r\n      if (enoughVideoSamples) {\r\n        firstKeyFrameIndex = findKeyframeIndex(videoTrack.samples);\r\n        if (!isVideoContiguous && this.config.forceKeyFrameOnDiscontinuity) {\r\n          independent = true;\r\n          if (firstKeyFrameIndex > 0) {\r\n            logger.warn(\r\n              `[mp4-remuxer]: Dropped ${firstKeyFrameIndex} out of ${length} video samples due to a missing keyframe`,\r\n            );\r\n            const startPTS = this.getVideoStartPts(videoTrack.samples);\r\n            videoTrack.samples = videoTrack.samples.slice(firstKeyFrameIndex);\r\n            videoTrack.dropped += firstKeyFrameIndex;\r\n            videoTimeOffset +=\r\n              (videoTrack.samples[0].pts - startPTS) /\r\n              videoTrack.inputTimeScale;\r\n            firstKeyFramePTS = videoTimeOffset;\r\n          } else if (firstKeyFrameIndex === -1) {\r\n            logger.warn(\r\n              `[mp4-remuxer]: No keyframe found out of ${length} video samples`,\r\n            );\r\n            independent = false;\r\n          }\r\n        }\r\n      }\r\n\r\n      if (this.ISGenerated) {\r\n        if (enoughAudioSamples && enoughVideoSamples) {\r\n          // timeOffset is expected to be the offset of the first timestamp of this fragment (first DTS)\r\n          // if first audio DTS is not aligned with first video DTS then we need to take that into account\r\n          // when providing timeOffset to remuxAudio / remuxVideo. if we don't do that, there might be a permanent / small\r\n          // drift between audio and video streams\r\n          const startPTS = this.getVideoStartPts(videoTrack.samples);\r\n          const tsDelta =\r\n            normalizePts(audioTrack.samples[0].pts, startPTS) - startPTS;\r\n          const audiovideoTimestampDelta = tsDelta / videoTrack.inputTimeScale;\r\n          audioTimeOffset += Math.max(0, audiovideoTimestampDelta);\r\n          videoTimeOffset += Math.max(0, -audiovideoTimestampDelta);\r\n        }\r\n\r\n        // Purposefully remuxing audio before video, so that remuxVideo can use nextAudioPts, which is calculated in remuxAudio.\r\n        if (enoughAudioSamples) {\r\n          // if initSegment was generated without audio samples, regenerate it again\r\n          if (!audioTrack.samplerate) {\r\n            logger.warn(\r\n              '[mp4-remuxer]: regenerate InitSegment as audio detected',\r\n            );\r\n            initSegment = this.generateIS(\r\n              audioTrack,\r\n              videoTrack,\r\n              timeOffset,\r\n              accurateTimeOffset,\r\n            );\r\n          }\r\n          audio = this.remuxAudio(\r\n            audioTrack,\r\n            audioTimeOffset,\r\n            this.isAudioContiguous,\r\n            accurateTimeOffset,\r\n            hasVideo ||\r\n              enoughVideoSamples ||\r\n              playlistType === PlaylistLevelType.AUDIO\r\n              ? videoTimeOffset\r\n              : undefined,\r\n          );\r\n          if (enoughVideoSamples) {\r\n            const audioTrackLength = audio ? audio.endPTS - audio.startPTS : 0;\r\n            // if initSegment was generated without video samples, regenerate it again\r\n            if (!videoTrack.inputTimeScale) {\r\n              logger.warn(\r\n                '[mp4-remuxer]: regenerate InitSegment as video detected',\r\n              );\r\n              initSegment = this.generateIS(\r\n                audioTrack,\r\n                videoTrack,\r\n                timeOffset,\r\n                accurateTimeOffset,\r\n              );\r\n            }\r\n            video = this.remuxVideo(\r\n              videoTrack,\r\n              videoTimeOffset,\r\n              isVideoContiguous,\r\n              audioTrackLength,\r\n            );\r\n          }\r\n        } else if (enoughVideoSamples) {\r\n          video = this.remuxVideo(\r\n            videoTrack,\r\n            videoTimeOffset,\r\n            isVideoContiguous,\r\n            0,\r\n          );\r\n        }\r\n        if (video) {\r\n          video.firstKeyFrame = firstKeyFrameIndex;\r\n          video.independent = firstKeyFrameIndex !== -1;\r\n          video.firstKeyFramePTS = firstKeyFramePTS;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Allow ID3 and text to remux, even if more audio/video samples are required\r\n    if (this.ISGenerated && this._initPTS && this._initDTS) {\r\n      if (id3Track.samples.length) {\r\n        id3 = flushTextTrackMetadataCueSamples(\r\n          id3Track,\r\n          timeOffset,\r\n          this._initPTS,\r\n          this._initDTS,\r\n        );\r\n      }\r\n\r\n      if (textTrack.samples.length) {\r\n        text = flushTextTrackUserdataCueSamples(\r\n          textTrack,\r\n          timeOffset,\r\n          this._initPTS,\r\n        );\r\n      }\r\n    }\r\n\r\n    return {\r\n      audio,\r\n      video,\r\n      initSegment,\r\n      independent,\r\n      text,\r\n      id3,\r\n    };\r\n  }\r\n\r\n  generateIS(\r\n    audioTrack: DemuxedAudioTrack,\r\n    videoTrack: DemuxedVideoTrack,\r\n    timeOffset: number,\r\n    accurateTimeOffset: boolean,\r\n  ): InitSegmentData | undefined {\r\n    const audioSamples = audioTrack.samples;\r\n    const videoSamples = videoTrack.samples;\r\n    const typeSupported = this.typeSupported;\r\n    const tracks: TrackSet = {};\r\n    const _initPTS = this._initPTS;\r\n    let computePTSDTS = !_initPTS || accurateTimeOffset;\r\n    let container = 'audio/mp4';\r\n    let initPTS: number | undefined;\r\n    let initDTS: number | undefined;\r\n    let timescale: number | undefined;\r\n\r\n    if (computePTSDTS) {\r\n      initPTS = initDTS = Infinity;\r\n    }\r\n\r\n    if (audioTrack.config && audioSamples.length) {\r\n      // let's use audio sampling rate as MP4 time scale.\r\n      // rationale is that there is a integer nb of audio frames per audio sample (1024 for AAC)\r\n      // using audio sampling rate here helps having an integer MP4 frame duration\r\n      // this avoids potential rounding issue and AV sync issue\r\n      audioTrack.timescale = audioTrack.samplerate;\r\n      switch (audioTrack.segmentCodec) {\r\n        case 'mp3':\r\n          if (typeSupported.mpeg) {\r\n            // Chrome and Safari\r\n            container = 'audio/mpeg';\r\n            audioTrack.codec = '';\r\n          } else if (typeSupported.mp3) {\r\n            // Firefox\r\n            audioTrack.codec = 'mp3';\r\n          }\r\n          break;\r\n\r\n        case 'ac3':\r\n          audioTrack.codec = 'ac-3';\r\n          break;\r\n      }\r\n      tracks.audio = {\r\n        id: 'audio',\r\n        container: container,\r\n        codec: audioTrack.codec,\r\n        initSegment:\r\n          audioTrack.segmentCodec === 'mp3' && typeSupported.mpeg\r\n            ? new Uint8Array(0)\r\n            : MP4.initSegment([audioTrack]),\r\n        metadata: {\r\n          channelCount: audioTrack.channelCount,\r\n        },\r\n      };\r\n      if (computePTSDTS) {\r\n        timescale = audioTrack.inputTimeScale;\r\n        if (!_initPTS || timescale !== _initPTS.timescale) {\r\n          // remember first PTS of this demuxing context. for audio, PTS = DTS\r\n          initPTS = initDTS =\r\n            audioSamples[0].pts - Math.round(timescale * timeOffset);\r\n        } else {\r\n          computePTSDTS = false;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (videoTrack.sps && videoTrack.pps && videoSamples.length) {\r\n      // let's use input time scale as MP4 video timescale\r\n      // we use input time scale straight away to avoid rounding issues on frame duration / cts computation\r\n      videoTrack.timescale = videoTrack.inputTimeScale;\r\n      tracks.video = {\r\n        id: 'main',\r\n        container: 'video/mp4',\r\n        codec: videoTrack.codec,\r\n        initSegment: MP4.initSegment([videoTrack]),\r\n        metadata: {\r\n          width: videoTrack.width,\r\n          height: videoTrack.height,\r\n        },\r\n      };\r\n      if (computePTSDTS) {\r\n        timescale = videoTrack.inputTimeScale;\r\n        if (!_initPTS || timescale !== _initPTS.timescale) {\r\n          const startPTS = this.getVideoStartPts(videoSamples);\r\n          const startOffset = Math.round(timescale * timeOffset);\r\n          initDTS = Math.min(\r\n            initDTS as number,\r\n            normalizePts(videoSamples[0].dts, startPTS) - startOffset,\r\n          );\r\n          initPTS = Math.min(initPTS as number, startPTS - startOffset);\r\n        } else {\r\n          computePTSDTS = false;\r\n        }\r\n      }\r\n      this.videoTrackConfig = {\r\n        width: videoTrack.width,\r\n        height: videoTrack.height,\r\n        pixelRatio: videoTrack.pixelRatio,\r\n      };\r\n    }\r\n\r\n    if (Object.keys(tracks).length) {\r\n      this.ISGenerated = true;\r\n      if (computePTSDTS) {\r\n        this._initPTS = {\r\n          baseTime: initPTS as number,\r\n          timescale: timescale as number,\r\n        };\r\n        this._initDTS = {\r\n          baseTime: initDTS as number,\r\n          timescale: timescale as number,\r\n        };\r\n      } else {\r\n        initPTS = timescale = undefined;\r\n      }\r\n\r\n      return {\r\n        tracks,\r\n        initPTS,\r\n        timescale,\r\n      };\r\n    }\r\n  }\r\n\r\n  remuxVideo(\r\n    track: DemuxedVideoTrack,\r\n    timeOffset: number,\r\n    contiguous: boolean,\r\n    audioTrackLength: number,\r\n  ): RemuxedTrack | undefined {\r\n    const timeScale: number = track.inputTimeScale;\r\n    const inputSamples: Array<VideoSample> = track.samples;\r\n    const outputSamples: Array<Mp4Sample> = [];\r\n    const nbSamples = inputSamples.length;\r\n    const initPTS = this._initPTS as RationalTimestamp;\r\n    let nextAvcDts = this.nextAvcDts;\r\n    let offset = 8;\r\n    let mp4SampleDuration = this.videoSampleDuration;\r\n    let firstDTS;\r\n    let lastDTS;\r\n    let minPTS: number = Number.POSITIVE_INFINITY;\r\n    let maxPTS: number = Number.NEGATIVE_INFINITY;\r\n    let sortSamples = false;\r\n\r\n    // if parsed fragment is contiguous with last one, let's use last DTS value as reference\r\n    if (!contiguous || nextAvcDts === null) {\r\n      const pts = timeOffset * timeScale;\r\n      const cts =\r\n        inputSamples[0].pts -\r\n        normalizePts(inputSamples[0].dts, inputSamples[0].pts);\r\n      if (\r\n        chromeVersion &&\r\n        nextAvcDts !== null &&\r\n        Math.abs(pts - cts - nextAvcDts) < 15000\r\n      ) {\r\n        // treat as contigous to adjust samples that would otherwise produce video buffer gaps in Chrome\r\n        contiguous = true;\r\n      } else {\r\n        // if not contiguous, let's use target timeOffset\r\n        nextAvcDts = pts - cts;\r\n      }\r\n    }\r\n\r\n    // PTS is coded on 33bits, and can loop from -2^32 to 2^32\r\n    // PTSNormalize will make PTS/DTS value monotonic, we use last known DTS value as reference value\r\n    const initTime = (initPTS.baseTime * timeScale) / initPTS.timescale;\r\n    for (let i = 0; i < nbSamples; i++) {\r\n      const sample = inputSamples[i];\r\n      sample.pts = normalizePts(sample.pts - initTime, nextAvcDts);\r\n      sample.dts = normalizePts(sample.dts - initTime, nextAvcDts);\r\n      if (sample.dts < inputSamples[i > 0 ? i - 1 : i].dts) {\r\n        sortSamples = true;\r\n      }\r\n    }\r\n\r\n    // sort video samples by DTS then PTS then demux id order\r\n    if (sortSamples) {\r\n      inputSamples.sort(function (a, b) {\r\n        const deltadts = a.dts - b.dts;\r\n        const deltapts = a.pts - b.pts;\r\n        return deltadts || deltapts;\r\n      });\r\n    }\r\n\r\n    // Get first/last DTS\r\n    firstDTS = inputSamples[0].dts;\r\n    lastDTS = inputSamples[inputSamples.length - 1].dts;\r\n\r\n    // Sample duration (as expected by trun MP4 boxes), should be the delta between sample DTS\r\n    // set this constant duration as being the avg delta between consecutive DTS.\r\n    const inputDuration = lastDTS - firstDTS;\r\n    const averageSampleDuration = inputDuration\r\n      ? Math.round(inputDuration / (nbSamples - 1))\r\n      : mp4SampleDuration || track.inputTimeScale / 30;\r\n\r\n    // if fragment are contiguous, detect hole/overlapping between fragments\r\n    if (contiguous) {\r\n      // check timestamp continuity across consecutive fragments (this is to remove inter-fragment gap/hole)\r\n      const delta = firstDTS - nextAvcDts;\r\n      const foundHole = delta > averageSampleDuration;\r\n      const foundOverlap = delta < -1;\r\n      if (foundHole || foundOverlap) {\r\n        if (foundHole) {\r\n          logger.warn(\r\n            `${(track.segmentCodec || '').toUpperCase()}: ${toMsFromMpegTsClock(\r\n              delta,\r\n              true,\r\n            )} ms (${delta}dts) hole between fragments detected at ${timeOffset.toFixed(\r\n              3,\r\n            )}`,\r\n          );\r\n        } else {\r\n          logger.warn(\r\n            `${(track.segmentCodec || '').toUpperCase()}: ${toMsFromMpegTsClock(\r\n              -delta,\r\n              true,\r\n            )} ms (${delta}dts) overlapping between fragments detected at ${timeOffset.toFixed(\r\n              3,\r\n            )}`,\r\n          );\r\n        }\r\n        if (\r\n          !foundOverlap ||\r\n          nextAvcDts >= inputSamples[0].pts ||\r\n          chromeVersion\r\n        ) {\r\n          firstDTS = nextAvcDts;\r\n          const firstPTS = inputSamples[0].pts - delta;\r\n          if (foundHole) {\r\n            inputSamples[0].dts = firstDTS;\r\n            inputSamples[0].pts = firstPTS;\r\n          } else {\r\n            for (let i = 0; i < inputSamples.length; i++) {\r\n              if (inputSamples[i].dts > firstPTS) {\r\n                break;\r\n              }\r\n              inputSamples[i].dts -= delta;\r\n              inputSamples[i].pts -= delta;\r\n            }\r\n          }\r\n          logger.log(\r\n            `Video: Initial PTS/DTS adjusted: ${toMsFromMpegTsClock(\r\n              firstPTS,\r\n              true,\r\n            )}/${toMsFromMpegTsClock(\r\n              firstDTS,\r\n              true,\r\n            )}, delta: ${toMsFromMpegTsClock(delta, true)} ms`,\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    firstDTS = Math.max(0, firstDTS);\r\n\r\n    let nbNalu = 0;\r\n    let naluLen = 0;\r\n    let dtsStep = firstDTS;\r\n    for (let i = 0; i < nbSamples; i++) {\r\n      // compute total/avc sample length and nb of NAL units\r\n      const sample = inputSamples[i];\r\n      const units = sample.units;\r\n      const nbUnits = units.length;\r\n      let sampleLen = 0;\r\n      for (let j = 0; j < nbUnits; j++) {\r\n        sampleLen += units[j].data.length;\r\n      }\r\n\r\n      naluLen += sampleLen;\r\n      nbNalu += nbUnits;\r\n      sample.length = sampleLen;\r\n\r\n      // ensure sample monotonic DTS\r\n      if (sample.dts < dtsStep) {\r\n        sample.dts = dtsStep;\r\n        dtsStep += (averageSampleDuration / 4) | 0 || 1;\r\n      } else {\r\n        dtsStep = sample.dts;\r\n      }\r\n\r\n      minPTS = Math.min(sample.pts, minPTS);\r\n      maxPTS = Math.max(sample.pts, maxPTS);\r\n    }\r\n    lastDTS = inputSamples[nbSamples - 1].dts;\r\n\r\n    /* concatenate the video data and construct the mdat in place\r\n      (need 8 more bytes to fill length and mpdat type) */\r\n    const mdatSize = naluLen + 4 * nbNalu + 8;\r\n    let mdat;\r\n    try {\r\n      mdat = new Uint8Array(mdatSize);\r\n    } catch (err) {\r\n      this.observer.emit(Events.ERROR, Events.ERROR, {\r\n        type: ErrorTypes.MUX_ERROR,\r\n        details: ErrorDetails.REMUX_ALLOC_ERROR,\r\n        fatal: false,\r\n        error: err,\r\n        bytes: mdatSize,\r\n        reason: `fail allocating video mdat ${mdatSize}`,\r\n      });\r\n      return;\r\n    }\r\n    const view = new DataView(mdat.buffer);\r\n    view.setUint32(0, mdatSize);\r\n    mdat.set(MP4.types.mdat, 4);\r\n\r\n    let stretchedLastFrame = false;\r\n    let minDtsDelta = Number.POSITIVE_INFINITY;\r\n    let minPtsDelta = Number.POSITIVE_INFINITY;\r\n    let maxDtsDelta = Number.NEGATIVE_INFINITY;\r\n    let maxPtsDelta = Number.NEGATIVE_INFINITY;\r\n    for (let i = 0; i < nbSamples; i++) {\r\n      const VideoSample = inputSamples[i];\r\n      const VideoSampleUnits = VideoSample.units;\r\n      let mp4SampleLength = 0;\r\n      // convert NALU bitstream to MP4 format (prepend NALU with size field)\r\n      for (let j = 0, nbUnits = VideoSampleUnits.length; j < nbUnits; j++) {\r\n        const unit = VideoSampleUnits[j];\r\n        const unitData = unit.data;\r\n        const unitDataLen = unit.data.byteLength;\r\n        view.setUint32(offset, unitDataLen);\r\n        offset += 4;\r\n        mdat.set(unitData, offset);\r\n        offset += unitDataLen;\r\n        mp4SampleLength += 4 + unitDataLen;\r\n      }\r\n\r\n      // expected sample duration is the Decoding Timestamp diff of consecutive samples\r\n      let ptsDelta;\r\n      if (i < nbSamples - 1) {\r\n        mp4SampleDuration = inputSamples[i + 1].dts - VideoSample.dts;\r\n        ptsDelta = inputSamples[i + 1].pts - VideoSample.pts;\r\n      } else {\r\n        const config = this.config;\r\n        const lastFrameDuration =\r\n          i > 0\r\n            ? VideoSample.dts - inputSamples[i - 1].dts\r\n            : averageSampleDuration;\r\n        ptsDelta =\r\n          i > 0\r\n            ? VideoSample.pts - inputSamples[i - 1].pts\r\n            : averageSampleDuration;\r\n        if (config.stretchShortVideoTrack && this.nextAudioPts !== null) {\r\n          // In some cases, a segment's audio track duration may exceed the video track duration.\r\n          // Since we've already remuxed audio, and we know how long the audio track is, we look to\r\n          // see if the delta to the next segment is longer than maxBufferHole.\r\n          // If so, playback would potentially get stuck, so we artificially inflate\r\n          // the duration of the last frame to minimize any potential gap between segments.\r\n          const gapTolerance = Math.floor(config.maxBufferHole * timeScale);\r\n          const deltaToFrameEnd =\r\n            (audioTrackLength\r\n              ? minPTS + audioTrackLength * timeScale\r\n              : this.nextAudioPts) - VideoSample.pts;\r\n          if (deltaToFrameEnd > gapTolerance) {\r\n            // We subtract lastFrameDuration from deltaToFrameEnd to try to prevent any video\r\n            // frame overlap. maxBufferHole should be >> lastFrameDuration anyway.\r\n            mp4SampleDuration = deltaToFrameEnd - lastFrameDuration;\r\n            if (mp4SampleDuration < 0) {\r\n              mp4SampleDuration = lastFrameDuration;\r\n            } else {\r\n              stretchedLastFrame = true;\r\n            }\r\n            logger.log(\r\n              `[mp4-remuxer]: It is approximately ${\r\n                deltaToFrameEnd / 90\r\n              } ms to the next segment; using duration ${\r\n                mp4SampleDuration / 90\r\n              } ms for the last video frame.`,\r\n            );\r\n          } else {\r\n            mp4SampleDuration = lastFrameDuration;\r\n          }\r\n        } else {\r\n          mp4SampleDuration = lastFrameDuration;\r\n        }\r\n      }\r\n      const compositionTimeOffset = Math.round(\r\n        VideoSample.pts - VideoSample.dts,\r\n      );\r\n      minDtsDelta = Math.min(minDtsDelta, mp4SampleDuration);\r\n      maxDtsDelta = Math.max(maxDtsDelta, mp4SampleDuration);\r\n      minPtsDelta = Math.min(minPtsDelta, ptsDelta);\r\n      maxPtsDelta = Math.max(maxPtsDelta, ptsDelta);\r\n\r\n      outputSamples.push(\r\n        new Mp4Sample(\r\n          VideoSample.key,\r\n          mp4SampleDuration,\r\n          mp4SampleLength,\r\n          compositionTimeOffset,\r\n        ),\r\n      );\r\n    }\r\n\r\n    if (outputSamples.length) {\r\n      if (chromeVersion) {\r\n        if (chromeVersion < 70) {\r\n          // Chrome workaround, mark first sample as being a Random Access Point (keyframe) to avoid sourcebuffer append issue\r\n          // https://code.google.com/p/chromium/issues/detail?id=229412\r\n          const flags = outputSamples[0].flags;\r\n          flags.dependsOn = 2;\r\n          flags.isNonSync = 0;\r\n        }\r\n      } else if (safariWebkitVersion) {\r\n        // Fix for \"CNN special report, with CC\" in test-streams (Safari browser only)\r\n        // Ignore DTS when frame durations are irregular. Safari MSE does not handle this leading to gaps.\r\n        if (\r\n          maxPtsDelta - minPtsDelta < maxDtsDelta - minDtsDelta &&\r\n          averageSampleDuration / maxDtsDelta < 0.025 &&\r\n          outputSamples[0].cts === 0\r\n        ) {\r\n          logger.warn(\r\n            'Found irregular gaps in sample duration. Using PTS instead of DTS to determine MP4 sample duration.',\r\n          );\r\n          let dts = firstDTS;\r\n          for (let i = 0, len = outputSamples.length; i < len; i++) {\r\n            const nextDts = dts + outputSamples[i].duration;\r\n            const pts = dts + outputSamples[i].cts;\r\n            if (i < len - 1) {\r\n              const nextPts = nextDts + outputSamples[i + 1].cts;\r\n              outputSamples[i].duration = nextPts - pts;\r\n            } else {\r\n              outputSamples[i].duration = i\r\n                ? outputSamples[i - 1].duration\r\n                : averageSampleDuration;\r\n            }\r\n            outputSamples[i].cts = 0;\r\n            dts = nextDts;\r\n          }\r\n        }\r\n      }\r\n    }\r\n    // next AVC/HEVC sample DTS should be equal to last sample DTS + last sample duration (in PES timescale)\r\n    mp4SampleDuration =\r\n      stretchedLastFrame || !mp4SampleDuration\r\n        ? averageSampleDuration\r\n        : mp4SampleDuration;\r\n    this.nextAvcDts = nextAvcDts = lastDTS + mp4SampleDuration;\r\n    this.videoSampleDuration = mp4SampleDuration;\r\n    this.isVideoContiguous = true;\r\n    const moof = MP4.moof(\r\n      track.sequenceNumber++,\r\n      firstDTS,\r\n      Object.assign({}, track, {\r\n        samples: outputSamples,\r\n      }),\r\n    );\r\n    const type: SourceBufferName = 'video';\r\n    const data = {\r\n      data1: moof,\r\n      data2: mdat,\r\n      startPTS: minPTS / timeScale,\r\n      endPTS: (maxPTS + mp4SampleDuration) / timeScale,\r\n      startDTS: firstDTS / timeScale,\r\n      endDTS: (nextAvcDts as number) / timeScale,\r\n      type,\r\n      hasAudio: false,\r\n      hasVideo: true,\r\n      nb: outputSamples.length,\r\n      dropped: track.dropped,\r\n    };\r\n    track.samples = [];\r\n    track.dropped = 0;\r\n    return data;\r\n  }\r\n\r\n  getSamplesPerFrame(track: DemuxedAudioTrack) {\r\n    switch (track.segmentCodec) {\r\n      case 'mp3':\r\n        return MPEG_AUDIO_SAMPLE_PER_FRAME;\r\n      case 'ac3':\r\n        return AC3_SAMPLES_PER_FRAME;\r\n      default:\r\n        return AAC_SAMPLES_PER_FRAME;\r\n    }\r\n  }\r\n\r\n  remuxAudio(\r\n    track: DemuxedAudioTrack,\r\n    timeOffset: number,\r\n    contiguous: boolean,\r\n    accurateTimeOffset: boolean,\r\n    videoTimeOffset?: number,\r\n  ): RemuxedTrack | undefined {\r\n    const inputTimeScale: number = track.inputTimeScale;\r\n    const mp4timeScale: number = track.samplerate\r\n      ? track.samplerate\r\n      : inputTimeScale;\r\n    const scaleFactor: number = inputTimeScale / mp4timeScale;\r\n    const mp4SampleDuration: number = this.getSamplesPerFrame(track);\r\n    const inputSampleDuration: number = mp4SampleDuration * scaleFactor;\r\n    const initPTS = this._initPTS as RationalTimestamp;\r\n    const rawMPEG: boolean =\r\n      track.segmentCodec === 'mp3' && this.typeSupported.mpeg;\r\n    const outputSamples: Array<Mp4Sample> = [];\r\n    const alignedWithVideo = videoTimeOffset !== undefined;\r\n\r\n    let inputSamples: Array<AudioSample> = track.samples;\r\n    let offset: number = rawMPEG ? 0 : 8;\r\n    let nextAudioPts: number = this.nextAudioPts || -1;\r\n\r\n    // window.audioSamples ? window.audioSamples.push(inputSamples.map(s => s.pts)) : (window.audioSamples = [inputSamples.map(s => s.pts)]);\r\n\r\n    // for audio samples, also consider consecutive fragments as being contiguous (even if a level switch occurs),\r\n    // for sake of clarity:\r\n    // consecutive fragments are frags with\r\n    //  - less than 100ms gaps between new time offset (if accurate) and next expected PTS OR\r\n    //  - less than 20 audio frames distance\r\n    // contiguous fragments are consecutive fragments from same quality level (same level, new SN = old SN + 1)\r\n    // this helps ensuring audio continuity\r\n    // and this also avoids audio glitches/cut when switching quality, or reporting wrong duration on first audio frame\r\n    const timeOffsetMpegTS = timeOffset * inputTimeScale;\r\n    const initTime = (initPTS.baseTime * inputTimeScale) / initPTS.timescale;\r\n    this.isAudioContiguous = contiguous =\r\n      contiguous ||\r\n      ((inputSamples.length &&\r\n        nextAudioPts > 0 &&\r\n        ((accurateTimeOffset &&\r\n          Math.abs(timeOffsetMpegTS - nextAudioPts) < 9000) ||\r\n          Math.abs(\r\n            normalizePts(inputSamples[0].pts - initTime, timeOffsetMpegTS) -\r\n              nextAudioPts,\r\n          ) <\r\n            20 * inputSampleDuration)) as boolean);\r\n\r\n    // compute normalized PTS\r\n    inputSamples.forEach(function (sample) {\r\n      sample.pts = normalizePts(sample.pts - initTime, timeOffsetMpegTS);\r\n    });\r\n\r\n    if (!contiguous || nextAudioPts < 0) {\r\n      // filter out sample with negative PTS that are not playable anyway\r\n      // if we don't remove these negative samples, they will shift all audio samples forward.\r\n      // leading to audio overlap between current / next fragment\r\n      inputSamples = inputSamples.filter((sample) => sample.pts >= 0);\r\n\r\n      // in case all samples have negative PTS, and have been filtered out, return now\r\n      if (!inputSamples.length) {\r\n        return;\r\n      }\r\n\r\n      if (videoTimeOffset === 0) {\r\n        // Set the start to 0 to match video so that start gaps larger than inputSampleDuration are filled with silence\r\n        nextAudioPts = 0;\r\n      } else if (accurateTimeOffset && !alignedWithVideo) {\r\n        // When not seeking, not live, and LevelDetails.PTSKnown, use fragment start as predicted next audio PTS\r\n        nextAudioPts = Math.max(0, timeOffsetMpegTS);\r\n      } else {\r\n        // if frags are not contiguous and if we cant trust time offset, let's use first sample PTS as next audio PTS\r\n        nextAudioPts = inputSamples[0].pts;\r\n      }\r\n    }\r\n\r\n    // If the audio track is missing samples, the frames seem to get \"left-shifted\" within the\r\n    // resulting mp4 segment, causing sync issues and leaving gaps at the end of the audio segment.\r\n    // In an effort to prevent this from happening, we inject frames here where there are gaps.\r\n    // When possible, we inject a silent frame; when that's not possible, we duplicate the last\r\n    // frame.\r\n\r\n    if (track.segmentCodec === 'aac') {\r\n      const maxAudioFramesDrift = this.config.maxAudioFramesDrift;\r\n      for (let i = 0, nextPts = nextAudioPts; i < inputSamples.length; i++) {\r\n        // First, let's see how far off this frame is from where we expect it to be\r\n        const sample = inputSamples[i];\r\n        const pts = sample.pts;\r\n        const delta = pts - nextPts;\r\n        const duration = Math.abs((1000 * delta) / inputTimeScale);\r\n\r\n        // When remuxing with video, if we're overlapping by more than a duration, drop this sample to stay in sync\r\n        if (\r\n          delta <= -maxAudioFramesDrift * inputSampleDuration &&\r\n          alignedWithVideo\r\n        ) {\r\n          if (i === 0) {\r\n            logger.warn(\r\n              `Audio frame @ ${(pts / inputTimeScale).toFixed(\r\n                3,\r\n              )}s overlaps nextAudioPts by ${Math.round(\r\n                (1000 * delta) / inputTimeScale,\r\n              )} ms.`,\r\n            );\r\n            this.nextAudioPts = nextAudioPts = nextPts = pts;\r\n          }\r\n        } // eslint-disable-line brace-style\r\n\r\n        // Insert missing frames if:\r\n        // 1: We're more than maxAudioFramesDrift frame away\r\n        // 2: Not more than MAX_SILENT_FRAME_DURATION away\r\n        // 3: currentTime (aka nextPtsNorm) is not 0\r\n        // 4: remuxing with video (videoTimeOffset !== undefined)\r\n        else if (\r\n          delta >= maxAudioFramesDrift * inputSampleDuration &&\r\n          duration < MAX_SILENT_FRAME_DURATION &&\r\n          alignedWithVideo\r\n        ) {\r\n          let missing = Math.round(delta / inputSampleDuration);\r\n          // Adjust nextPts so that silent samples are aligned with media pts. This will prevent media samples from\r\n          // later being shifted if nextPts is based on timeOffset and delta is not a multiple of inputSampleDuration.\r\n          nextPts = pts - missing * inputSampleDuration;\r\n          if (nextPts < 0) {\r\n            missing--;\r\n            nextPts += inputSampleDuration;\r\n          }\r\n          if (i === 0) {\r\n            this.nextAudioPts = nextAudioPts = nextPts;\r\n          }\r\n          logger.warn(\r\n            `[mp4-remuxer]: Injecting ${missing} audio frame @ ${(\r\n              nextPts / inputTimeScale\r\n            ).toFixed(3)}s due to ${Math.round(\r\n              (1000 * delta) / inputTimeScale,\r\n            )} ms gap.`,\r\n          );\r\n          for (let j = 0; j < missing; j++) {\r\n            const newStamp = Math.max(nextPts as number, 0);\r\n            let fillFrame = AAC.getSilentFrame(\r\n              track.manifestCodec || track.codec,\r\n              track.channelCount,\r\n            );\r\n            if (!fillFrame) {\r\n              logger.log(\r\n                '[mp4-remuxer]: Unable to get silent frame for given audio codec; duplicating last frame instead.',\r\n              );\r\n              fillFrame = sample.unit.subarray();\r\n            }\r\n            inputSamples.splice(i, 0, {\r\n              unit: fillFrame,\r\n              pts: newStamp,\r\n            });\r\n            nextPts += inputSampleDuration;\r\n            i++;\r\n          }\r\n        }\r\n        sample.pts = nextPts;\r\n        nextPts += inputSampleDuration;\r\n      }\r\n    }\r\n    let firstPTS: number | null = null;\r\n    let lastPTS: number | null = null;\r\n    let mdat: any;\r\n    let mdatSize: number = 0;\r\n    let sampleLength: number = inputSamples.length;\r\n    while (sampleLength--) {\r\n      mdatSize += inputSamples[sampleLength].unit.byteLength;\r\n    }\r\n    for (let j = 0, nbSamples = inputSamples.length; j < nbSamples; j++) {\r\n      const audioSample = inputSamples[j];\r\n      const unit = audioSample.unit;\r\n      let pts = audioSample.pts;\r\n      if (lastPTS !== null) {\r\n        // If we have more than one sample, set the duration of the sample to the \"real\" duration; the PTS diff with\r\n        // the previous sample\r\n        const prevSample = outputSamples[j - 1];\r\n        prevSample.duration = Math.round((pts - lastPTS) / scaleFactor);\r\n      } else {\r\n        if (contiguous && track.segmentCodec === 'aac') {\r\n          // set PTS/DTS to expected PTS/DTS\r\n          pts = nextAudioPts;\r\n        }\r\n        // remember first PTS of our audioSamples\r\n        firstPTS = pts;\r\n        if (mdatSize > 0) {\r\n          /* concatenate the audio data and construct the mdat in place\r\n            (need 8 more bytes to fill length and mdat type) */\r\n          mdatSize += offset;\r\n          try {\r\n            mdat = new Uint8Array(mdatSize);\r\n          } catch (err) {\r\n            this.observer.emit(Events.ERROR, Events.ERROR, {\r\n              type: ErrorTypes.MUX_ERROR,\r\n              details: ErrorDetails.REMUX_ALLOC_ERROR,\r\n              fatal: false,\r\n              error: err,\r\n              bytes: mdatSize,\r\n              reason: `fail allocating audio mdat ${mdatSize}`,\r\n            });\r\n            return;\r\n          }\r\n          if (!rawMPEG) {\r\n            const view = new DataView(mdat.buffer);\r\n            view.setUint32(0, mdatSize);\r\n            mdat.set(MP4.types.mdat, 4);\r\n          }\r\n        } else {\r\n          // no audio samples\r\n          return;\r\n        }\r\n      }\r\n      mdat.set(unit, offset);\r\n      const unitLen = unit.byteLength;\r\n      offset += unitLen;\r\n      // Default the sample's duration to the computed mp4SampleDuration, which will either be 1024 for AAC or 1152 for MPEG\r\n      // In the case that we have 1 sample, this will be the duration. If we have more than one sample, the duration\r\n      // becomes the PTS diff with the previous sample\r\n      outputSamples.push(new Mp4Sample(true, mp4SampleDuration, unitLen, 0));\r\n      lastPTS = pts;\r\n    }\r\n\r\n    // We could end up with no audio samples if all input samples were overlapping with the previously remuxed ones\r\n    const nbSamples = outputSamples.length;\r\n    if (!nbSamples) {\r\n      return;\r\n    }\r\n\r\n    // The next audio sample PTS should be equal to last sample PTS + duration\r\n    const lastSample = outputSamples[outputSamples.length - 1];\r\n    this.nextAudioPts = nextAudioPts =\r\n      lastPTS! + scaleFactor * lastSample.duration;\r\n\r\n    // Set the track samples from inputSamples to outputSamples before remuxing\r\n    const moof = rawMPEG\r\n      ? new Uint8Array(0)\r\n      : MP4.moof(\r\n          track.sequenceNumber++,\r\n          firstPTS! / scaleFactor,\r\n          Object.assign({}, track, { samples: outputSamples }),\r\n        );\r\n\r\n    // Clear the track samples. This also clears the samples array in the demuxer, since the reference is shared\r\n    track.samples = [];\r\n    const start = firstPTS! / inputTimeScale;\r\n    const end = nextAudioPts / inputTimeScale;\r\n    const type: SourceBufferName = 'audio';\r\n    const audioData = {\r\n      data1: moof,\r\n      data2: mdat,\r\n      startPTS: start,\r\n      endPTS: end,\r\n      startDTS: start,\r\n      endDTS: end,\r\n      type,\r\n      hasAudio: true,\r\n      hasVideo: false,\r\n      nb: nbSamples,\r\n    };\r\n\r\n    this.isAudioContiguous = true;\r\n    return audioData;\r\n  }\r\n\r\n  remuxEmptyAudio(\r\n    track: DemuxedAudioTrack,\r\n    timeOffset: number,\r\n    contiguous: boolean,\r\n    videoData: Fragment,\r\n  ): RemuxedTrack | undefined {\r\n    const inputTimeScale: number = track.inputTimeScale;\r\n    const mp4timeScale: number = track.samplerate\r\n      ? track.samplerate\r\n      : inputTimeScale;\r\n    const scaleFactor: number = inputTimeScale / mp4timeScale;\r\n    const nextAudioPts: number | null = this.nextAudioPts;\r\n    // sync with video's timestamp\r\n    const initDTS = this._initDTS as RationalTimestamp;\r\n    const init90kHz = (initDTS.baseTime * 90000) / initDTS.timescale;\r\n    const startDTS: number =\r\n      (nextAudioPts !== null\r\n        ? nextAudioPts\r\n        : videoData.startDTS * inputTimeScale) + init90kHz;\r\n    const endDTS: number = videoData.endDTS * inputTimeScale + init90kHz;\r\n    // one sample's duration value\r\n    const frameDuration: number = scaleFactor * AAC_SAMPLES_PER_FRAME;\r\n    // samples count of this segment's duration\r\n    const nbSamples: number = Math.ceil((endDTS - startDTS) / frameDuration);\r\n    // silent frame\r\n    const silentFrame: Uint8Array | undefined = AAC.getSilentFrame(\r\n      track.manifestCodec || track.codec,\r\n      track.channelCount,\r\n    );\r\n\r\n    logger.warn('[mp4-remuxer]: remux empty Audio');\r\n    // Can't remux if we can't generate a silent frame...\r\n    if (!silentFrame) {\r\n      logger.trace(\r\n        '[mp4-remuxer]: Unable to remuxEmptyAudio since we were unable to get a silent frame for given audio codec',\r\n      );\r\n      return;\r\n    }\r\n\r\n    const samples: Array<any> = [];\r\n    for (let i = 0; i < nbSamples; i++) {\r\n      const stamp = startDTS + i * frameDuration;\r\n      samples.push({ unit: silentFrame, pts: stamp, dts: stamp });\r\n    }\r\n    track.samples = samples;\r\n\r\n    return this.remuxAudio(track, timeOffset, contiguous, false);\r\n  }\r\n}\r\n\r\nexport function normalizePts(value: number, reference: number | null): number {\r\n  let offset;\r\n  if (reference === null) {\r\n    return value;\r\n  }\r\n\r\n  if (reference < value) {\r\n    // - 2^33\r\n    offset = -8589934592;\r\n  } else {\r\n    // + 2^33\r\n    offset = 8589934592;\r\n  }\r\n  /* PTS is 33bit (from 0 to 2^33 -1)\r\n    if diff between value and reference is bigger than half of the amplitude (2^32) then it means that\r\n    PTS looping occured. fill the gap */\r\n  while (Math.abs(value - reference) > 4294967296) {\r\n    value += offset;\r\n  }\r\n\r\n  return value;\r\n}\r\n\r\nfunction findKeyframeIndex(samples: Array<VideoSample>): number {\r\n  for (let i = 0; i < samples.length; i++) {\r\n    if (samples[i].key) {\r\n      return i;\r\n    }\r\n  }\r\n  return -1;\r\n}\r\n\r\nexport function flushTextTrackMetadataCueSamples(\r\n  track: DemuxedMetadataTrack,\r\n  timeOffset: number,\r\n  initPTS: RationalTimestamp,\r\n  initDTS: RationalTimestamp,\r\n): RemuxedMetadata | undefined {\r\n  const length = track.samples.length;\r\n  if (!length) {\r\n    return;\r\n  }\r\n  const inputTimeScale = track.inputTimeScale;\r\n  for (let index = 0; index < length; index++) {\r\n    const sample = track.samples[index];\r\n    // setting id3 pts, dts to relative time\r\n    // using this._initPTS and this._initDTS to calculate relative time\r\n    sample.pts =\r\n      normalizePts(\r\n        sample.pts - (initPTS.baseTime * inputTimeScale) / initPTS.timescale,\r\n        timeOffset * inputTimeScale,\r\n      ) / inputTimeScale;\r\n    sample.dts =\r\n      normalizePts(\r\n        sample.dts - (initDTS.baseTime * inputTimeScale) / initDTS.timescale,\r\n        timeOffset * inputTimeScale,\r\n      ) / inputTimeScale;\r\n  }\r\n  const samples = track.samples;\r\n  track.samples = [];\r\n  return {\r\n    samples,\r\n  };\r\n}\r\n\r\nexport function flushTextTrackUserdataCueSamples(\r\n  track: DemuxedUserdataTrack,\r\n  timeOffset: number,\r\n  initPTS: RationalTimestamp,\r\n): RemuxedUserdata | undefined {\r\n  const length = track.samples.length;\r\n  if (!length) {\r\n    return;\r\n  }\r\n\r\n  const inputTimeScale = track.inputTimeScale;\r\n  for (let index = 0; index < length; index++) {\r\n    const sample = track.samples[index];\r\n    // setting text pts, dts to relative time\r\n    // using this._initPTS and this._initDTS to calculate relative time\r\n    sample.pts =\r\n      normalizePts(\r\n        sample.pts - (initPTS.baseTime * inputTimeScale) / initPTS.timescale,\r\n        timeOffset * inputTimeScale,\r\n      ) / inputTimeScale;\r\n  }\r\n  track.samples.sort((a, b) => a.pts - b.pts);\r\n  const samples = track.samples;\r\n  track.samples = [];\r\n  return {\r\n    samples,\r\n  };\r\n}\r\n\r\ntype Mp4SampleFlags = {\r\n  isLeading: 0;\r\n  isDependedOn: 0;\r\n  hasRedundancy: 0;\r\n  degradPrio: 0;\r\n  dependsOn: 1 | 2;\r\n  isNonSync: 0 | 1;\r\n};\r\n\r\nclass Mp4Sample {\r\n  public size: number;\r\n  public duration: number;\r\n  public cts: number;\r\n  public flags: Mp4SampleFlags;\r\n\r\n  constructor(\r\n    isKeyframe: boolean,\r\n    duration: number,\r\n    size: number,\r\n    cts: number,\r\n  ) {\r\n    this.duration = duration;\r\n    this.size = size;\r\n    this.cts = cts;\r\n    this.flags = {\r\n      isLeading: 0,\r\n      isDependedOn: 0,\r\n      hasRedundancy: 0,\r\n      degradPrio: 0,\r\n      dependsOn: isKeyframe ? 2 : 1,\r\n      isNonSync: isKeyframe ? 0 : 1,\r\n    };\r\n  }\r\n}\r\n","import { getMediaSource } from './mediasource-helper';\r\n\r\n// from http://mp4ra.org/codecs.html\r\n// values indicate codec selection preference (lower is higher priority)\r\nconst sampleEntryCodesISO = {\r\n  audio: {\r\n    a3ds: 1,\r\n    'ac-3': 0.95,\r\n    'ac-4': 1,\r\n    alac: 0.9,\r\n    alaw: 1,\r\n    dra1: 1,\r\n    'dts+': 1,\r\n    'dts-': 1,\r\n    dtsc: 1,\r\n    dtse: 1,\r\n    dtsh: 1,\r\n    'ec-3': 0.9,\r\n    enca: 1,\r\n    fLaC: 0.9, // MP4-RA listed codec entry for FLAC\r\n    flac: 0.9, // legacy browser codec name for FLAC\r\n    FLAC: 0.9, // some manifests may list \"FLAC\" with Apple's tools\r\n    g719: 1,\r\n    g726: 1,\r\n    m4ae: 1,\r\n    mha1: 1,\r\n    mha2: 1,\r\n    mhm1: 1,\r\n    mhm2: 1,\r\n    mlpa: 1,\r\n    mp4a: 1,\r\n    'raw ': 1,\r\n    Opus: 1,\r\n    opus: 1, // browsers expect this to be lowercase despite MP4RA says 'Opus'\r\n    samr: 1,\r\n    sawb: 1,\r\n    sawp: 1,\r\n    sevc: 1,\r\n    sqcp: 1,\r\n    ssmv: 1,\r\n    twos: 1,\r\n    ulaw: 1,\r\n  },\r\n  video: {\r\n    avc1: 1,\r\n    avc2: 1,\r\n    avc3: 1,\r\n    avc4: 1,\r\n    avcp: 1,\r\n    av01: 0.8,\r\n    drac: 1,\r\n    dva1: 1,\r\n    dvav: 1,\r\n    dvh1: 0.7,\r\n    dvhe: 0.7,\r\n    encv: 1,\r\n    hev1: 0.75,\r\n    hvc1: 0.75,\r\n    mjp2: 1,\r\n    mp4v: 1,\r\n    mvc1: 1,\r\n    mvc2: 1,\r\n    mvc3: 1,\r\n    mvc4: 1,\r\n    resv: 1,\r\n    rv60: 1,\r\n    s263: 1,\r\n    svc1: 1,\r\n    svc2: 1,\r\n    'vc-1': 1,\r\n    vp08: 1,\r\n    vp09: 0.9,\r\n  },\r\n  text: {\r\n    stpp: 1,\r\n    wvtt: 1,\r\n  },\r\n} as const;\r\n\r\nexport type CodecType = 'audio' | 'video';\r\n\r\nexport function isCodecType(codec: string, type: CodecType): boolean {\r\n  const typeCodes = sampleEntryCodesISO[type];\r\n  return !!typeCodes && !!typeCodes[codec.slice(0, 4)];\r\n}\r\n\r\nexport function areCodecsMediaSourceSupported(\r\n  codecs: string,\r\n  type: CodecType,\r\n  preferManagedMediaSource = true,\r\n): boolean {\r\n  return !codecs\r\n    .split(',')\r\n    .some(\r\n      (codec) =>\r\n        !isCodecMediaSourceSupported(codec, type, preferManagedMediaSource),\r\n    );\r\n}\r\n\r\nfunction isCodecMediaSourceSupported(\r\n  codec: string,\r\n  type: CodecType,\r\n  preferManagedMediaSource = true,\r\n): boolean {\r\n  const MediaSource = getMediaSource(preferManagedMediaSource);\r\n  return MediaSource?.isTypeSupported(mimeTypeForCodec(codec, type)) ?? false;\r\n}\r\n\r\nexport function mimeTypeForCodec(codec: string, type: CodecType): string {\r\n  return `${type}/mp4;codecs=\"${codec}\"`;\r\n}\r\n\r\nexport function codecsSetSelectionPreferenceValue(codecSet: string): number {\r\n  return codecSet.split(',').reduce((num, fourCC) => {\r\n    const preferenceValue = sampleEntryCodesISO.video[fourCC];\r\n    if (preferenceValue) {\r\n      return (preferenceValue * 2 + num) / (num ? 3 : 2);\r\n    }\r\n    return (sampleEntryCodesISO.audio[fourCC] + num) / (num ? 2 : 1);\r\n  }, 0);\r\n}\r\n\r\ninterface CodecNameCache {\r\n  flac?: string;\r\n  opus?: string;\r\n}\r\n\r\nconst CODEC_COMPATIBLE_NAMES: CodecNameCache = {};\r\n\r\ntype LowerCaseCodecType = 'flac' | 'opus';\r\n\r\nfunction getCodecCompatibleNameLower(\r\n  lowerCaseCodec: LowerCaseCodecType,\r\n  preferManagedMediaSource = true,\r\n): string {\r\n  if (CODEC_COMPATIBLE_NAMES[lowerCaseCodec]) {\r\n    return CODEC_COMPATIBLE_NAMES[lowerCaseCodec]!;\r\n  }\r\n\r\n  // Idealy fLaC and Opus would be first (spec-compliant) but\r\n  // some browsers will report that fLaC is supported then fail.\r\n  // see: https://bugs.chromium.org/p/chromium/issues/detail?id=1422728\r\n  const codecsToCheck = {\r\n    flac: ['flac', 'fLaC', 'FLAC'],\r\n    opus: ['opus', 'Opus'],\r\n  }[lowerCaseCodec];\r\n\r\n  for (let i = 0; i < codecsToCheck.length; i++) {\r\n    if (\r\n      isCodecMediaSourceSupported(\r\n        codecsToCheck[i],\r\n        'audio',\r\n        preferManagedMediaSource,\r\n      )\r\n    ) {\r\n      CODEC_COMPATIBLE_NAMES[lowerCaseCodec] = codecsToCheck[i];\r\n      return codecsToCheck[i];\r\n    }\r\n  }\r\n\r\n  return lowerCaseCodec;\r\n}\r\n\r\nconst AUDIO_CODEC_REGEXP = /flac|opus/i;\r\nexport function getCodecCompatibleName(\r\n  codec: string,\r\n  preferManagedMediaSource = true,\r\n): string {\r\n  return codec.replace(AUDIO_CODEC_REGEXP, (m) =>\r\n    getCodecCompatibleNameLower(\r\n      m.toLowerCase() as LowerCaseCodecType,\r\n      preferManagedMediaSource,\r\n    ),\r\n  );\r\n}\r\n\r\nexport function pickMostCompleteCodecName(\r\n  parsedCodec: string,\r\n  levelCodec: string | undefined,\r\n): string | undefined {\r\n  // Parsing of mp4a codecs strings in mp4-tools from media is incomplete as of d8c6c7a\r\n  // so use level codec is parsed codec is unavailable or incomplete\r\n  if (parsedCodec && parsedCodec !== 'mp4a') {\r\n    return parsedCodec;\r\n  }\r\n  return levelCodec;\r\n}\r\n","/**\r\n * MediaSource helper\r\n */\r\n\r\nexport function getMediaSource(\r\n  preferManagedMediaSource = true,\r\n): typeof MediaSource | undefined {\r\n  if (typeof self === 'undefined') return undefined;\r\n  const mms =\r\n    (preferManagedMediaSource || !self.MediaSource) &&\r\n    ((self as any).ManagedMediaSource as undefined | typeof MediaSource);\r\n  return (\r\n    mms ||\r\n    self.MediaSource ||\r\n    ((self as any).WebKitMediaSource as typeof MediaSource)\r\n  );\r\n}\r\n","import {\r\n  flushTextTrackMetadataCueSamples,\r\n  flushTextTrackUserdataCueSamples,\r\n} from './mp4-remuxer';\r\nimport {\r\n  InitData,\r\n  InitDataTrack,\r\n  patchEncyptionData,\r\n} from '../utils/mp4-tools';\r\nimport {\r\n  getDuration,\r\n  getStartDTS,\r\n  offsetStartDTS,\r\n  parseInitSegment,\r\n} from '../utils/mp4-tools';\r\nimport { ElementaryStreamTypes } from '../loader/fragment';\r\nimport { logger } from '../utils/logger';\r\nimport { getCodecCompatibleName } from '../utils/codecs';\r\nimport type { TrackSet } from '../types/track';\r\nimport type {\r\n  InitSegmentData,\r\n  RemuxedTrack,\r\n  Remuxer,\r\n  RemuxerResult,\r\n} from '../types/remuxer';\r\nimport type {\r\n  DemuxedAudioTrack,\r\n  DemuxedMetadataTrack,\r\n  DemuxedUserdataTrack,\r\n  PassthroughTrack,\r\n} from '../types/demuxer';\r\nimport type { DecryptData } from '../loader/level-key';\r\nimport type { RationalTimestamp } from '../utils/timescale-conversion';\r\n\r\nclass PassThroughRemuxer implements Remuxer {\r\n  private emitInitSegment: boolean = false;\r\n  private audioCodec?: string;\r\n  private videoCodec?: string;\r\n  private initData?: InitData;\r\n  private initPTS: RationalTimestamp | null = null;\r\n  private initTracks?: TrackSet;\r\n  private lastEndTime: number | null = null;\r\n\r\n  public destroy() {}\r\n\r\n  public resetTimeStamp(defaultInitPTS: RationalTimestamp | null) {\r\n    this.initPTS = defaultInitPTS;\r\n    this.lastEndTime = null;\r\n  }\r\n\r\n  public resetNextTimestamp() {\r\n    this.lastEndTime = null;\r\n  }\r\n\r\n  public resetInitSegment(\r\n    initSegment: Uint8Array | undefined,\r\n    audioCodec: string | undefined,\r\n    videoCodec: string | undefined,\r\n    decryptdata: DecryptData | null,\r\n  ) {\r\n    this.audioCodec = audioCodec;\r\n    this.videoCodec = videoCodec;\r\n    this.generateInitSegment(patchEncyptionData(initSegment, decryptdata));\r\n    this.emitInitSegment = true;\r\n  }\r\n\r\n  private generateInitSegment(initSegment: Uint8Array | undefined): void {\r\n    let { audioCodec, videoCodec } = this;\r\n    if (!initSegment?.byteLength) {\r\n      this.initTracks = undefined;\r\n      this.initData = undefined;\r\n      return;\r\n    }\r\n    const initData = (this.initData = parseInitSegment(initSegment));\r\n\r\n    // Get codec from initSegment or fallback to default\r\n    if (initData.audio) {\r\n      audioCodec = getParsedTrackCodec(\r\n        initData.audio,\r\n        ElementaryStreamTypes.AUDIO,\r\n      );\r\n    }\r\n\r\n    if (initData.video) {\r\n      videoCodec = getParsedTrackCodec(\r\n        initData.video,\r\n        ElementaryStreamTypes.VIDEO,\r\n      );\r\n    }\r\n\r\n    const tracks: TrackSet = {};\r\n    if (initData.audio && initData.video) {\r\n      tracks.audiovideo = {\r\n        container: 'video/mp4',\r\n        codec: audioCodec + ',' + videoCodec,\r\n        initSegment,\r\n        id: 'main',\r\n      };\r\n    } else if (initData.audio) {\r\n      tracks.audio = {\r\n        container: 'audio/mp4',\r\n        codec: audioCodec,\r\n        initSegment,\r\n        id: 'audio',\r\n      };\r\n    } else if (initData.video) {\r\n      tracks.video = {\r\n        container: 'video/mp4',\r\n        codec: videoCodec,\r\n        initSegment,\r\n        id: 'main',\r\n      };\r\n    } else {\r\n      logger.warn(\r\n        '[passthrough-remuxer.ts]: initSegment does not contain moov or trak boxes.',\r\n      );\r\n    }\r\n    this.initTracks = tracks;\r\n  }\r\n\r\n  public remux(\r\n    audioTrack: DemuxedAudioTrack,\r\n    videoTrack: PassthroughTrack,\r\n    id3Track: DemuxedMetadataTrack,\r\n    textTrack: DemuxedUserdataTrack,\r\n    timeOffset: number,\r\n    accurateTimeOffset: boolean,\r\n  ): RemuxerResult {\r\n    let { initPTS, lastEndTime } = this;\r\n    const result: RemuxerResult = {\r\n      audio: undefined,\r\n      video: undefined,\r\n      text: textTrack,\r\n      id3: id3Track,\r\n      initSegment: undefined,\r\n    };\r\n\r\n    // If we haven't yet set a lastEndDTS, or it was reset, set it to the provided timeOffset. We want to use the\r\n    // lastEndDTS over timeOffset whenever possible; during progressive playback, the media source will not update\r\n    // the media duration (which is what timeOffset is provided as) before we need to process the next chunk.\r\n    if (!Number.isFinite(lastEndTime!)) {\r\n      lastEndTime = this.lastEndTime = timeOffset || 0;\r\n    }\r\n\r\n    // The binary segment data is added to the videoTrack in the mp4demuxer. We don't check to see if the data is only\r\n    // audio or video (or both); adding it to video was an arbitrary choice.\r\n    const data = videoTrack.samples;\r\n    if (!data?.length) {\r\n      return result;\r\n    }\r\n\r\n    const initSegment: InitSegmentData = {\r\n      initPTS: undefined,\r\n      timescale: 1,\r\n    };\r\n    let initData = this.initData;\r\n    if (!initData?.length) {\r\n      this.generateInitSegment(data);\r\n      initData = this.initData;\r\n    }\r\n    if (!initData?.length) {\r\n      // We can't remux if the initSegment could not be generated\r\n      logger.warn('[passthrough-remuxer.ts]: Failed to generate initSegment.');\r\n      return result;\r\n    }\r\n    if (this.emitInitSegment) {\r\n      initSegment.tracks = this.initTracks as TrackSet;\r\n      this.emitInitSegment = false;\r\n    }\r\n\r\n    const duration = getDuration(data, initData);\r\n    const startDTS = getStartDTS(initData, data);\r\n    const decodeTime = startDTS === null ? timeOffset : startDTS;\r\n    if (\r\n      isInvalidInitPts(initPTS, decodeTime, timeOffset, duration) ||\r\n      (initSegment.timescale !== initPTS.timescale && accurateTimeOffset)\r\n    ) {\r\n      initSegment.initPTS = decodeTime - timeOffset;\r\n      if (initPTS && initPTS.timescale === 1) {\r\n        logger.warn(\r\n          `Adjusting initPTS by ${initSegment.initPTS - initPTS.baseTime}`,\r\n        );\r\n      }\r\n      this.initPTS = initPTS = {\r\n        baseTime: initSegment.initPTS,\r\n        timescale: 1,\r\n      };\r\n    }\r\n\r\n    const startTime = audioTrack\r\n      ? decodeTime - initPTS.baseTime / initPTS.timescale\r\n      : (lastEndTime as number);\r\n    const endTime = startTime + duration;\r\n    offsetStartDTS(initData, data, initPTS.baseTime / initPTS.timescale);\r\n\r\n    if (duration > 0) {\r\n      this.lastEndTime = endTime;\r\n    } else {\r\n      logger.warn('Duration parsed from mp4 should be greater than zero');\r\n      this.resetNextTimestamp();\r\n    }\r\n\r\n    const hasAudio = !!initData.audio;\r\n    const hasVideo = !!initData.video;\r\n\r\n    let type: any = '';\r\n    if (hasAudio) {\r\n      type += 'audio';\r\n    }\r\n\r\n    if (hasVideo) {\r\n      type += 'video';\r\n    }\r\n\r\n    const track: RemuxedTrack = {\r\n      data1: data,\r\n      startPTS: startTime,\r\n      startDTS: startTime,\r\n      endPTS: endTime,\r\n      endDTS: endTime,\r\n      type,\r\n      hasAudio,\r\n      hasVideo,\r\n      nb: 1,\r\n      dropped: 0,\r\n    };\r\n\r\n    result.audio = track.type === 'audio' ? track : undefined;\r\n    result.video = track.type !== 'audio' ? track : undefined;\r\n    result.initSegment = initSegment;\r\n    result.id3 = flushTextTrackMetadataCueSamples(\r\n      id3Track,\r\n      timeOffset,\r\n      initPTS,\r\n      initPTS,\r\n    );\r\n\r\n    if (textTrack.samples.length) {\r\n      result.text = flushTextTrackUserdataCueSamples(\r\n        textTrack,\r\n        timeOffset,\r\n        initPTS,\r\n      );\r\n    }\r\n\r\n    return result;\r\n  }\r\n}\r\n\r\nfunction isInvalidInitPts(\r\n  initPTS: RationalTimestamp | null,\r\n  startDTS: number,\r\n  timeOffset: number,\r\n  duration: number,\r\n): initPTS is null {\r\n  if (initPTS === null) {\r\n    return true;\r\n  }\r\n  // InitPTS is invalid when distance from program would be more than segment duration or a minimum of one second\r\n  const minDuration = Math.max(duration, 1);\r\n  const startTime = startDTS - initPTS.baseTime / initPTS.timescale;\r\n  return Math.abs(startTime - timeOffset) > minDuration;\r\n}\r\n\r\nfunction getParsedTrackCodec(\r\n  track: InitDataTrack,\r\n  type: ElementaryStreamTypes.AUDIO | ElementaryStreamTypes.VIDEO,\r\n): string {\r\n  const parsedCodec = track?.codec;\r\n  if (parsedCodec && parsedCodec.length > 4) {\r\n    return parsedCodec;\r\n  }\r\n  if (type === ElementaryStreamTypes.AUDIO) {\r\n    if (\r\n      parsedCodec === 'ec-3' ||\r\n      parsedCodec === 'ac-3' ||\r\n      parsedCodec === 'alac'\r\n    ) {\r\n      return parsedCodec;\r\n    }\r\n    if (parsedCodec === 'fLaC' || parsedCodec === 'Opus') {\r\n      // Opting not to get `preferManagedMediaSource` from player config for isSupported() check for simplicity\r\n      const preferManagedMediaSource = false;\r\n      return getCodecCompatibleName(parsedCodec, preferManagedMediaSource);\r\n    }\r\n    const result = 'mp4a.40.5';\r\n    logger.info(\r\n      `Parsed audio codec \"${parsedCodec}\" or audio object type not handled. Using \"${result}\"`,\r\n    );\r\n    return result;\r\n  }\r\n  // Provide defaults based on codec type\r\n  // This allows for some playback of some fmp4 playlists without CODECS defined in manifest\r\n  logger.warn(`Unhandled video codec \"${parsedCodec}\"`);\r\n  if (parsedCodec === 'hvc1' || parsedCodec === 'hev1') {\r\n    return 'hvc1.1.6.L120.90';\r\n  }\r\n  if (parsedCodec === 'av01') {\r\n    return 'av01.0.04M.08';\r\n  }\r\n  return 'avc1.42e01e';\r\n}\r\nexport default PassThroughRemuxer;\r\n","import type { HlsEventEmitter } from '../events';\r\nimport { Events } from '../events';\r\nimport { ErrorTypes, ErrorDetails } from '../errors';\r\nimport Decrypter from '../crypt/decrypter';\r\nimport AACDemuxer from './audio/aacdemuxer';\r\nimport MP4Demuxer from '../demux/mp4demuxer';\r\nimport TSDemuxer, { TypeSupported } from '../demux/tsdemuxer';\r\nimport MP3Demuxer from './audio/mp3demuxer';\r\nimport { AC3Demuxer } from './audio/ac3-demuxer';\r\nimport MP4Remuxer from '../remux/mp4-remuxer';\r\nimport PassThroughRemuxer from '../remux/passthrough-remuxer';\r\nimport { logger } from '../utils/logger';\r\nimport type { Demuxer, DemuxerResult, KeyData } from '../types/demuxer';\r\nimport type { Remuxer } from '../types/remuxer';\r\nimport type { TransmuxerResult, ChunkMetadata } from '../types/transmuxer';\r\nimport type { HlsConfig } from '../config';\r\nimport type { DecryptData } from '../loader/level-key';\r\nimport type { PlaylistLevelType } from '../types/loader';\r\nimport type { RationalTimestamp } from '../utils/timescale-conversion';\r\n\r\nlet now;\r\n// performance.now() not available on WebWorker, at least on Safari Desktop\r\ntry {\r\n  now = self.performance.now.bind(self.performance);\r\n} catch (err) {\r\n  logger.debug('Unable to use Performance API on this environment');\r\n  now = typeof self !== 'undefined' && self.Date.now;\r\n}\r\n\r\ntype MuxConfig =\r\n  | { demux: typeof MP4Demuxer; remux: typeof PassThroughRemuxer }\r\n  | { demux: typeof TSDemuxer; remux: typeof MP4Remuxer }\r\n  | { demux: typeof AC3Demuxer; remux: typeof MP4Remuxer }\r\n  | { demux: typeof AACDemuxer; remux: typeof MP4Remuxer }\r\n  | { demux: typeof MP3Demuxer; remux: typeof MP4Remuxer };\r\n\r\nconst muxConfig: MuxConfig[] = [\r\n  { demux: MP4Demuxer, remux: PassThroughRemuxer },\r\n  { demux: TSDemuxer, remux: MP4Remuxer },\r\n  { demux: AACDemuxer, remux: MP4Remuxer },\r\n  { demux: MP3Demuxer, remux: MP4Remuxer },\r\n];\r\n\r\nif (__USE_M2TS_ADVANCED_CODECS__) {\r\n  muxConfig.splice(2, 0, { demux: AC3Demuxer, remux: MP4Remuxer });\r\n}\r\n\r\nexport default class Transmuxer {\r\n  public async: boolean = false;\r\n  private observer: HlsEventEmitter;\r\n  private typeSupported: TypeSupported;\r\n  private config: HlsConfig;\r\n  private vendor: string;\r\n  private id: PlaylistLevelType;\r\n  private demuxer?: Demuxer;\r\n  private remuxer?: Remuxer;\r\n  private decrypter?: Decrypter;\r\n  private probe!: Function;\r\n  private decryptionPromise: Promise<TransmuxerResult> | null = null;\r\n  private transmuxConfig!: TransmuxConfig;\r\n  private currentTransmuxState!: TransmuxState;\r\n\r\n  constructor(\r\n    observer: HlsEventEmitter,\r\n    typeSupported: TypeSupported,\r\n    config: HlsConfig,\r\n    vendor: string,\r\n    id: PlaylistLevelType,\r\n  ) {\r\n    this.observer = observer;\r\n    this.typeSupported = typeSupported;\r\n    this.config = config;\r\n    this.vendor = vendor;\r\n    this.id = id;\r\n  }\r\n\r\n  configure(transmuxConfig: TransmuxConfig) {\r\n    this.transmuxConfig = transmuxConfig;\r\n    if (this.decrypter) {\r\n      this.decrypter.reset();\r\n    }\r\n  }\r\n\r\n  push(\r\n    data: ArrayBuffer,\r\n    decryptdata: DecryptData | null,\r\n    chunkMeta: ChunkMetadata,\r\n    state?: TransmuxState,\r\n  ): TransmuxerResult | Promise<TransmuxerResult> {\r\n    const stats = chunkMeta.transmuxing;\r\n    stats.executeStart = now();\r\n\r\n    let uintData: Uint8Array = new Uint8Array(data);\r\n    const { currentTransmuxState, transmuxConfig } = this;\r\n    if (state) {\r\n      this.currentTransmuxState = state;\r\n    }\r\n\r\n    const {\r\n      contiguous,\r\n      discontinuity,\r\n      trackSwitch,\r\n      accurateTimeOffset,\r\n      timeOffset,\r\n      initSegmentChange,\r\n    } = state || currentTransmuxState;\r\n    const {\r\n      audioCodec,\r\n      videoCodec,\r\n      defaultInitPts,\r\n      duration,\r\n      initSegmentData,\r\n    } = transmuxConfig;\r\n\r\n    const keyData = getEncryptionType(uintData, decryptdata);\r\n    if (keyData && keyData.method === 'AES-128') {\r\n      const decrypter = this.getDecrypter();\r\n      // Software decryption is synchronous; webCrypto is not\r\n      if (decrypter.isSync()) {\r\n        // Software decryption is progressive. Progressive decryption may not return a result on each call. Any cached\r\n        // data is handled in the flush() call\r\n        let decryptedData = decrypter.softwareDecrypt(\r\n          uintData,\r\n          keyData.key.buffer,\r\n          keyData.iv.buffer,\r\n        );\r\n        // For Low-Latency HLS Parts, decrypt in place, since part parsing is expected on push progress\r\n        const loadingParts = chunkMeta.part > -1;\r\n        if (loadingParts) {\r\n          decryptedData = decrypter.flush();\r\n        }\r\n        if (!decryptedData) {\r\n          stats.executeEnd = now();\r\n          return emptyResult(chunkMeta);\r\n        }\r\n        uintData = new Uint8Array(decryptedData);\r\n      } else {\r\n        this.decryptionPromise = decrypter\r\n          .webCryptoDecrypt(uintData, keyData.key.buffer, keyData.iv.buffer)\r\n          .then((decryptedData): TransmuxerResult => {\r\n            // Calling push here is important; if flush() is called while this is still resolving, this ensures that\r\n            // the decrypted data has been transmuxed\r\n            const result = this.push(\r\n              decryptedData,\r\n              null,\r\n              chunkMeta,\r\n            ) as TransmuxerResult;\r\n            this.decryptionPromise = null;\r\n            return result;\r\n          });\r\n        return this.decryptionPromise!;\r\n      }\r\n    }\r\n\r\n    const resetMuxers = this.needsProbing(discontinuity, trackSwitch);\r\n    if (resetMuxers) {\r\n      const error = this.configureTransmuxer(uintData);\r\n      if (error) {\r\n        logger.warn(`[transmuxer] ${error.message}`);\r\n        this.observer.emit(Events.ERROR, Events.ERROR, {\r\n          type: ErrorTypes.MEDIA_ERROR,\r\n          details: ErrorDetails.FRAG_PARSING_ERROR,\r\n          fatal: false,\r\n          error,\r\n          reason: error.message,\r\n        });\r\n        stats.executeEnd = now();\r\n        return emptyResult(chunkMeta);\r\n      }\r\n    }\r\n\r\n    if (discontinuity || trackSwitch || initSegmentChange || resetMuxers) {\r\n      this.resetInitSegment(\r\n        initSegmentData,\r\n        audioCodec,\r\n        videoCodec,\r\n        duration,\r\n        decryptdata,\r\n      );\r\n    }\r\n\r\n    if (discontinuity || initSegmentChange || resetMuxers) {\r\n      this.resetInitialTimestamp(defaultInitPts);\r\n    }\r\n\r\n    if (!contiguous) {\r\n      this.resetContiguity();\r\n    }\r\n\r\n    const result = this.transmux(\r\n      uintData,\r\n      keyData,\r\n      timeOffset,\r\n      accurateTimeOffset,\r\n      chunkMeta,\r\n    );\r\n    const currentState = this.currentTransmuxState;\r\n\r\n    currentState.contiguous = true;\r\n    currentState.discontinuity = false;\r\n    currentState.trackSwitch = false;\r\n\r\n    stats.executeEnd = now();\r\n    return result;\r\n  }\r\n\r\n  // Due to data caching, flush calls can produce more than one TransmuxerResult (hence the Array type)\r\n  flush(\r\n    chunkMeta: ChunkMetadata,\r\n  ): TransmuxerResult[] | Promise<TransmuxerResult[]> {\r\n    const stats = chunkMeta.transmuxing;\r\n    stats.executeStart = now();\r\n\r\n    const { decrypter, currentTransmuxState, decryptionPromise } = this;\r\n\r\n    if (decryptionPromise) {\r\n      // Upon resolution, the decryption promise calls push() and returns its TransmuxerResult up the stack. Therefore\r\n      // only flushing is required for async decryption\r\n      return decryptionPromise.then(() => {\r\n        return this.flush(chunkMeta);\r\n      });\r\n    }\r\n\r\n    const transmuxResults: TransmuxerResult[] = [];\r\n    const { timeOffset } = currentTransmuxState;\r\n    if (decrypter) {\r\n      // The decrypter may have data cached, which needs to be demuxed. In this case we'll have two TransmuxResults\r\n      // This happens in the case that we receive only 1 push call for a segment (either for non-progressive downloads,\r\n      // or for progressive downloads with small segments)\r\n      const decryptedData = decrypter.flush();\r\n      if (decryptedData) {\r\n        // Push always returns a TransmuxerResult if decryptdata is null\r\n        transmuxResults.push(\r\n          this.push(decryptedData, null, chunkMeta) as TransmuxerResult,\r\n        );\r\n      }\r\n    }\r\n\r\n    const { demuxer, remuxer } = this;\r\n    if (!demuxer || !remuxer) {\r\n      // If probing failed, then Hls.js has been given content its not able to handle\r\n      stats.executeEnd = now();\r\n      return [emptyResult(chunkMeta)];\r\n    }\r\n\r\n    const demuxResultOrPromise = demuxer.flush(timeOffset);\r\n    if (isPromise(demuxResultOrPromise)) {\r\n      // Decrypt final SAMPLE-AES samples\r\n      return demuxResultOrPromise.then((demuxResult) => {\r\n        this.flushRemux(transmuxResults, demuxResult, chunkMeta);\r\n        return transmuxResults;\r\n      });\r\n    }\r\n\r\n    this.flushRemux(transmuxResults, demuxResultOrPromise, chunkMeta);\r\n    return transmuxResults;\r\n  }\r\n\r\n  private flushRemux(\r\n    transmuxResults: TransmuxerResult[],\r\n    demuxResult: DemuxerResult,\r\n    chunkMeta: ChunkMetadata,\r\n  ) {\r\n    const { audioTrack, videoTrack, id3Track, textTrack } = demuxResult;\r\n    const { accurateTimeOffset, timeOffset } = this.currentTransmuxState;\r\n    logger.log(\r\n      `[transmuxer.ts]: Flushed fragment ${chunkMeta.sn}${\r\n        chunkMeta.part > -1 ? ' p: ' + chunkMeta.part : ''\r\n      } of level ${chunkMeta.level}`,\r\n    );\r\n    const remuxResult = this.remuxer!.remux(\r\n      audioTrack,\r\n      videoTrack,\r\n      id3Track,\r\n      textTrack,\r\n      timeOffset,\r\n      accurateTimeOffset,\r\n      true,\r\n      this.id,\r\n    );\r\n    transmuxResults.push({\r\n      remuxResult,\r\n      chunkMeta,\r\n    });\r\n\r\n    chunkMeta.transmuxing.executeEnd = now();\r\n  }\r\n\r\n  resetInitialTimestamp(defaultInitPts: RationalTimestamp | null) {\r\n    const { demuxer, remuxer } = this;\r\n    if (!demuxer || !remuxer) {\r\n      return;\r\n    }\r\n    demuxer.resetTimeStamp(defaultInitPts);\r\n    remuxer.resetTimeStamp(defaultInitPts);\r\n  }\r\n\r\n  resetContiguity() {\r\n    const { demuxer, remuxer } = this;\r\n    if (!demuxer || !remuxer) {\r\n      return;\r\n    }\r\n    demuxer.resetContiguity();\r\n    remuxer.resetNextTimestamp();\r\n  }\r\n\r\n  resetInitSegment(\r\n    initSegmentData: Uint8Array | undefined,\r\n    audioCodec: string | undefined,\r\n    videoCodec: string | undefined,\r\n    trackDuration: number,\r\n    decryptdata: DecryptData | null,\r\n  ) {\r\n    const { demuxer, remuxer } = this;\r\n    if (!demuxer || !remuxer) {\r\n      return;\r\n    }\r\n    demuxer.resetInitSegment(\r\n      initSegmentData,\r\n      audioCodec,\r\n      videoCodec,\r\n      trackDuration,\r\n    );\r\n    remuxer.resetInitSegment(\r\n      initSegmentData,\r\n      audioCodec,\r\n      videoCodec,\r\n      decryptdata,\r\n    );\r\n  }\r\n\r\n  destroy(): void {\r\n    if (this.demuxer) {\r\n      this.demuxer.destroy();\r\n      this.demuxer = undefined;\r\n    }\r\n    if (this.remuxer) {\r\n      this.remuxer.destroy();\r\n      this.remuxer = undefined;\r\n    }\r\n  }\r\n\r\n  private transmux(\r\n    data: Uint8Array,\r\n    keyData: KeyData | null,\r\n    timeOffset: number,\r\n    accurateTimeOffset: boolean,\r\n    chunkMeta: ChunkMetadata,\r\n  ): TransmuxerResult | Promise<TransmuxerResult> {\r\n    let result: TransmuxerResult | Promise<TransmuxerResult>;\r\n    if (keyData && keyData.method === 'SAMPLE-AES') {\r\n      result = this.transmuxSampleAes(\r\n        data,\r\n        keyData,\r\n        timeOffset,\r\n        accurateTimeOffset,\r\n        chunkMeta,\r\n      );\r\n    } else {\r\n      result = this.transmuxUnencrypted(\r\n        data,\r\n        timeOffset,\r\n        accurateTimeOffset,\r\n        chunkMeta,\r\n      );\r\n    }\r\n    return result;\r\n  }\r\n\r\n  private transmuxUnencrypted(\r\n    data: Uint8Array,\r\n    timeOffset: number,\r\n    accurateTimeOffset: boolean,\r\n    chunkMeta: ChunkMetadata,\r\n  ): TransmuxerResult {\r\n    const { audioTrack, videoTrack, id3Track, textTrack } = (\r\n      this.demuxer as Demuxer\r\n    ).demux(data, timeOffset, false, !this.config.progressive);\r\n    const remuxResult = this.remuxer!.remux(\r\n      audioTrack,\r\n      videoTrack,\r\n      id3Track,\r\n      textTrack,\r\n      timeOffset,\r\n      accurateTimeOffset,\r\n      false,\r\n      this.id,\r\n    );\r\n    return {\r\n      remuxResult,\r\n      chunkMeta,\r\n    };\r\n  }\r\n\r\n  private transmuxSampleAes(\r\n    data: Uint8Array,\r\n    decryptData: KeyData,\r\n    timeOffset: number,\r\n    accurateTimeOffset: boolean,\r\n    chunkMeta: ChunkMetadata,\r\n  ): Promise<TransmuxerResult> {\r\n    return (this.demuxer as Demuxer)\r\n      .demuxSampleAes(data, decryptData, timeOffset)\r\n      .then((demuxResult) => {\r\n        const remuxResult = this.remuxer!.remux(\r\n          demuxResult.audioTrack,\r\n          demuxResult.videoTrack,\r\n          demuxResult.id3Track,\r\n          demuxResult.textTrack,\r\n          timeOffset,\r\n          accurateTimeOffset,\r\n          false,\r\n          this.id,\r\n        );\r\n        return {\r\n          remuxResult,\r\n          chunkMeta,\r\n        };\r\n      });\r\n  }\r\n\r\n  private configureTransmuxer(data: Uint8Array): void | Error {\r\n    const { config, observer, typeSupported, vendor } = this;\r\n    // probe for content type\r\n    let mux;\r\n    for (let i = 0, len = muxConfig.length; i < len; i++) {\r\n      if (muxConfig[i].demux?.probe(data)) {\r\n        mux = muxConfig[i];\r\n        break;\r\n      }\r\n    }\r\n    if (!mux) {\r\n      return new Error('Failed to find demuxer by probing fragment data');\r\n    }\r\n    // so let's check that current remuxer and demuxer are still valid\r\n    const demuxer = this.demuxer;\r\n    const remuxer = this.remuxer;\r\n    const Remuxer: MuxConfig['remux'] = mux.remux;\r\n    const Demuxer: MuxConfig['demux'] = mux.demux;\r\n    if (!remuxer || !(remuxer instanceof Remuxer)) {\r\n      this.remuxer = new Remuxer(observer, config, typeSupported, vendor);\r\n    }\r\n    if (!demuxer || !(demuxer instanceof Demuxer)) {\r\n      this.demuxer = new Demuxer(observer, config, typeSupported);\r\n      this.probe = Demuxer.probe;\r\n    }\r\n  }\r\n\r\n  private needsProbing(discontinuity: boolean, trackSwitch: boolean): boolean {\r\n    // in case of continuity change, or track switch\r\n    // we might switch from content type (AAC container to TS container, or TS to fmp4 for example)\r\n    return !this.demuxer || !this.remuxer || discontinuity || trackSwitch;\r\n  }\r\n\r\n  private getDecrypter(): Decrypter {\r\n    let decrypter = this.decrypter;\r\n    if (!decrypter) {\r\n      decrypter = this.decrypter = new Decrypter(this.config);\r\n    }\r\n    return decrypter;\r\n  }\r\n}\r\n\r\nfunction getEncryptionType(\r\n  data: Uint8Array,\r\n  decryptData: DecryptData | null,\r\n): KeyData | null {\r\n  let encryptionType: KeyData | null = null;\r\n  if (\r\n    data.byteLength > 0 &&\r\n    decryptData != null &&\r\n    decryptData.key != null &&\r\n    decryptData.iv !== null &&\r\n    decryptData.method != null\r\n  ) {\r\n    encryptionType = decryptData as KeyData;\r\n  }\r\n  return encryptionType;\r\n}\r\n\r\nconst emptyResult = (chunkMeta): TransmuxerResult => ({\r\n  remuxResult: {},\r\n  chunkMeta,\r\n});\r\n\r\nexport function isPromise<T>(p: Promise<T> | any): p is Promise<T> {\r\n  return 'then' in p && p.then instanceof Function;\r\n}\r\n\r\nexport class TransmuxConfig {\r\n  public audioCodec?: string;\r\n  public videoCodec?: string;\r\n  public initSegmentData?: Uint8Array;\r\n  public duration: number;\r\n  public defaultInitPts: RationalTimestamp | null;\r\n\r\n  constructor(\r\n    audioCodec: string | undefined,\r\n    videoCodec: string | undefined,\r\n    initSegmentData: Uint8Array | undefined,\r\n    duration: number,\r\n    defaultInitPts?: RationalTimestamp,\r\n  ) {\r\n    this.audioCodec = audioCodec;\r\n    this.videoCodec = videoCodec;\r\n    this.initSegmentData = initSegmentData;\r\n    this.duration = duration;\r\n    this.defaultInitPts = defaultInitPts || null;\r\n  }\r\n}\r\n\r\nexport class TransmuxState {\r\n  public discontinuity: boolean;\r\n  public contiguous: boolean;\r\n  public accurateTimeOffset: boolean;\r\n  public trackSwitch: boolean;\r\n  public timeOffset: number;\r\n  public initSegmentChange: boolean;\r\n\r\n  constructor(\r\n    discontinuity: boolean,\r\n    contiguous: boolean,\r\n    accurateTimeOffset: boolean,\r\n    trackSwitch: boolean,\r\n    timeOffset: number,\r\n    initSegmentChange: boolean,\r\n  ) {\r\n    this.discontinuity = discontinuity;\r\n    this.contiguous = contiguous;\r\n    this.accurateTimeOffset = accurateTimeOffset;\r\n    this.trackSwitch = trackSwitch;\r\n    this.timeOffset = timeOffset;\r\n    this.initSegmentChange = initSegmentChange;\r\n  }\r\n}\r\n","'use strict';\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif ('undefined' !== typeof module) {\n  module.exports = EventEmitter;\n}\n","import Transmuxer, { isPromise } from '../demux/transmuxer';\r\nimport { Events } from '../events';\r\nimport { ILogFunction, enableLogs, logger } from '../utils/logger';\r\nimport { EventEmitter } from 'eventemitter3';\r\nimport { ErrorDetails, ErrorTypes } from '../errors';\r\nimport type { RemuxedTrack, RemuxerResult } from '../types/remuxer';\r\nimport type { TransmuxerResult, ChunkMetadata } from '../types/transmuxer';\r\n\r\nif (typeof __IN_WORKER__ !== 'undefined' && __IN_WORKER__) {\r\n  startWorker(self);\r\n}\r\n\r\nfunction startWorker(self) {\r\n  const observer = new EventEmitter();\r\n  const forwardMessage = (ev, data) => {\r\n    self.postMessage({ event: ev, data: data });\r\n  };\r\n\r\n  // forward events to main thread\r\n  observer.on(Events.FRAG_DECRYPTED, forwardMessage);\r\n  observer.on(Events.ERROR, forwardMessage);\r\n\r\n  // forward logger events to main thread\r\n  const forwardWorkerLogs = () => {\r\n    for (const logFn in logger) {\r\n      const func: ILogFunction = (message?) => {\r\n        forwardMessage('workerLog', {\r\n          logType: logFn,\r\n          message,\r\n        });\r\n      };\r\n\r\n      logger[logFn] = func;\r\n    }\r\n  };\r\n\r\n  self.addEventListener('message', (ev) => {\r\n    const data = ev.data;\r\n    switch (data.cmd) {\r\n      case 'init': {\r\n        const config = JSON.parse(data.config);\r\n        self.transmuxer = new Transmuxer(\r\n          observer,\r\n          data.typeSupported,\r\n          config,\r\n          data.vendor,\r\n          data.id,\r\n        );\r\n        enableLogs(config.debug, data.id);\r\n        forwardWorkerLogs();\r\n        forwardMessage('init', null);\r\n        break;\r\n      }\r\n      case 'configure': {\r\n        self.transmuxer.configure(data.config);\r\n        break;\r\n      }\r\n      case 'demux': {\r\n        const transmuxResult: TransmuxerResult | Promise<TransmuxerResult> =\r\n          self.transmuxer.push(\r\n            data.data,\r\n            data.decryptdata,\r\n            data.chunkMeta,\r\n            data.state,\r\n          );\r\n        if (isPromise(transmuxResult)) {\r\n          self.transmuxer.async = true;\r\n          transmuxResult\r\n            .then((data) => {\r\n              emitTransmuxComplete(self, data);\r\n            })\r\n            .catch((error) => {\r\n              forwardMessage(Events.ERROR, {\r\n                type: ErrorTypes.MEDIA_ERROR,\r\n                details: ErrorDetails.FRAG_PARSING_ERROR,\r\n                chunkMeta: data.chunkMeta,\r\n                fatal: false,\r\n                error,\r\n                err: error,\r\n                reason: `transmuxer-worker push error`,\r\n              });\r\n            });\r\n        } else {\r\n          self.transmuxer.async = false;\r\n          emitTransmuxComplete(self, transmuxResult);\r\n        }\r\n        break;\r\n      }\r\n      case 'flush': {\r\n        const id = data.chunkMeta;\r\n        let transmuxResult = self.transmuxer.flush(id);\r\n        const asyncFlush = isPromise(transmuxResult);\r\n        if (asyncFlush || self.transmuxer.async) {\r\n          if (!isPromise(transmuxResult)) {\r\n            transmuxResult = Promise.resolve(transmuxResult);\r\n          }\r\n          transmuxResult\r\n            .then((results: Array<TransmuxerResult>) => {\r\n              handleFlushResult(self, results as Array<TransmuxerResult>, id);\r\n            })\r\n            .catch((error) => {\r\n              forwardMessage(Events.ERROR, {\r\n                type: ErrorTypes.MEDIA_ERROR,\r\n                details: ErrorDetails.FRAG_PARSING_ERROR,\r\n                chunkMeta: data.chunkMeta,\r\n                fatal: false,\r\n                error,\r\n                err: error,\r\n                reason: `transmuxer-worker flush error`,\r\n              });\r\n            });\r\n        } else {\r\n          handleFlushResult(\r\n            self,\r\n            transmuxResult as Array<TransmuxerResult>,\r\n            id,\r\n          );\r\n        }\r\n        break;\r\n      }\r\n      default:\r\n        break;\r\n    }\r\n  });\r\n}\r\n\r\nfunction emitTransmuxComplete(\r\n  self: any,\r\n  transmuxResult: TransmuxerResult,\r\n): boolean {\r\n  if (isEmptyResult(transmuxResult.remuxResult)) {\r\n    return false;\r\n  }\r\n  const transferable: Array<ArrayBuffer> = [];\r\n  const { audio, video } = transmuxResult.remuxResult;\r\n  if (audio) {\r\n    addToTransferable(transferable, audio);\r\n  }\r\n  if (video) {\r\n    addToTransferable(transferable, video);\r\n  }\r\n  self.postMessage(\r\n    { event: 'transmuxComplete', data: transmuxResult },\r\n    transferable,\r\n  );\r\n  return true;\r\n}\r\n\r\n// Converts data to a transferable object https://developers.google.com/web/updates/2011/12/Transferable-Objects-Lightning-Fast)\r\n// in order to minimize message passing overhead\r\nfunction addToTransferable(\r\n  transferable: Array<ArrayBuffer>,\r\n  track: RemuxedTrack,\r\n) {\r\n  if (track.data1) {\r\n    transferable.push(track.data1.buffer);\r\n  }\r\n  if (track.data2) {\r\n    transferable.push(track.data2.buffer);\r\n  }\r\n}\r\n\r\nfunction handleFlushResult(\r\n  self: any,\r\n  results: Array<TransmuxerResult>,\r\n  chunkMeta: ChunkMetadata,\r\n) {\r\n  const parsed = results.reduce(\r\n    (parsed, result) => emitTransmuxComplete(self, result) || parsed,\r\n    false,\r\n  );\r\n  if (!parsed) {\r\n    // Emit at least one \"transmuxComplete\" message even if media is not found to update stream-controller state to PARSING\r\n    self.postMessage({ event: 'transmuxComplete', data: results[0] });\r\n  }\r\n  self.postMessage({ event: 'flush', data: chunkMeta });\r\n}\r\n\r\nfunction isEmptyResult(remuxResult: RemuxerResult) {\r\n  return (\r\n    !remuxResult.audio &&\r\n    !remuxResult.video &&\r\n    !remuxResult.text &&\r\n    !remuxResult.id3 &&\r\n    !remuxResult.initSegment\r\n  );\r\n}\r\n"],"names":["Events","ErrorTypes","ErrorDetails","AESCrypto","subtle","iv","this","aesIV","prototype","decrypt","data","key","name","FastAESKey","expandKey","importKey","sliceUint8","array","start","end","Uint8Array","slice","Array","call","AESDecryptor","rcon","subMix","Uint32Array","invSubMix","sBox","invSBox","ksRows","keySize","keySchedule","invKeySchedule","initTable","_proto","uint8ArrayToUint32Array_","arrayBuffer","view","DataView","newArray","i","getUint32","subMix0","subMix1","subMix2","subMix3","invSubMix0","invSubMix1","invSubMix2","invSubMix3","d","x","xi","sx","x2","x4","x8","t","keyBuffer","sameKey","offset","length","Error","ksRow","invKsRow","prev","sbox","networkToHostOrderSwap","word","inputArrayBuffer","t0","t1","t2","t3","s0","s1","s2","s3","inputWords0","inputWords1","inputWords2","inputWords3","nRounds","invSBOX","initVector","initVector0","initVector1","initVector2","initVector3","inputInt32","Int32Array","outputInt32","swapWord","buffer","noop","fakeLogger","trace","debug","log","warn","info","error","exportedLogger","exportLoggerFunctions","debugConfig","_len","arguments","functions","_key","forEach","type","bind","func","self","console","consolePrintFn","enableLogs","id","undefined","e","logger","isFiniteNumber","Number","isFinite","value","URL_REGEX","FIRST_SEGMENT_REGEX","SLASH_DOT_REGEX","SLASH_DOT_DOT_REGEX","URLToolkit","buildAbsoluteURL","baseURL","relativeURL","opts","trim","alwaysNormalize","basePartsForNormalise","parseURL","path","normalizePath","buildURLFromParts","relativeParts","scheme","baseParts","netLoc","pathParts","exec","builtParts","params","query","fragment","baseURLPath","newPath","substring","lastIndexOf","url","parts","split","reverse","join","replace","decoder","ElementaryStreamTypes","isHeader","isFooter","getID3Data","front","readSize","subarray","size","canParse","getTimeStamp","frames","getID3Frames","frame","isTimeStampFrame","readTimeStamp","getFrameData","String","fromCharCode","id3Data","frameData","decodeFrame","push","decodePrivFrame","decodeURLFrame","decodeTextFrame","owner","utf8ArrayToStr","privateData","index","description","text","timeStampFrame","byteLength","pts33Bit","timestamp","Math","round","exitOnNull","getTextDecoder","decoded","decode","idx","indexOf","c","char2","char3","len","out","TextDecoder","Hex","str","h","toString","UINT32_MAX","pow","RemuxerTrackIdConfig","video","audio","id3","bin2str","apply","readUint16","val","readUint32","readSint32","writeUint32","findBox","results","endbox","subresults","parseSegmentIndex","sidx","references","version","timescale","startByte","referencesCount","referenceIndex","referenceInfo","referenceSize","subsegmentDuration","duration","earliestPresentationTime","parseInitSegment","initSegment","result","traks","trak","tkhd","trackId","mdhd","hdlr","hdlrType","soun","vide","stsdData","parseStsd","_objectSpread","trex","track","default","flags","stsd","sampleEntries","sampleEntriesEnd","fourCC","codec","encrypted","encBox","sinf","schm","frma","toHex","codecBox","esdsBox","toUpperCase","hvcCBox","profileByte","profileSpace","generalProfileIdc","profileCompat","tierFlag","levelIDC","constraintIndicator","constraintString","byte","dvcCBox","profile","level","addLeadingZero","vpcCBox","bitDepth","av1CBox","highBitDepth","twelveBit","monochrome","chromaSubsamplingX","chromaSubsamplingY","chromaSamplePosition","num","patchEncyptionData","decryptdata","keyId","isCommonEncryption","encBoxes","isAudio","enc","tenc","parseSinf","tencKeyId","some","b","set","computeRawDurationFromSamples","trun","sampleCount","appendUint8Array","data1","data2","temp","parseSamples","timeOffset","seiSamples","videoData","samples","isHEVCFlavor","map","moof","moofOffset","byteOffset","traf","baseTime","tfdt","tfhd","tfhdFlags","defaultSampleDuration","defaultSampleSizePresent","defaultSampleSize","defaultSampleFlagsPresent","tfhdOffset","delimit","baseCodec","isHEVC","dataOffsetPresent","dataOffset","firstSampleFlagsPresent","sampleDurationPresent","sampleDuration","sampleSizePresent","sampleSize","sampleFlagsPresent","sampleCompositionOffsetsPresent","compositionOffset","trunOffset","sampleOffset","ix","naluTotalSize","naluSize","isSEIMessage","parseSEIMessageFromNALu","naluHeader","naluType","unescapedData","headerSize","pts","discardEPB","seiPtr","payloadType","payloadSize","endOfCaptions","leftOver","providerCode","userStructure","userDataType","firstByte","enabled","totalBytes","byteArray","bytes","uuidStrArray","userDataBytes","uuid","userData","EPBPositions","newLength","newData","sourceIndex","shift","Decrypter","config","_temp","_ref$removePKCS7Paddi","removePKCS7Padding","logEnabled","softwareDecrypter","fastAesKey","remainderData","currentIV","currentResult","useSoftware","enableSoftwareAES","browserCrypto","crypto","webkitSubtle","destroy","isSync","flush","reset","outputBytes","paddingBytes","getUint8","_this","Promise","resolve","reject","softwareDecrypt","decryptResult","webCryptoDecrypt","logOnce","currentChunk","getValidChunk","_this2","then","aesKey","catch","err","message","onWebCryptoError","splitPoint","msg","MetadataSchema","dummyTrack","inputTimeScale","pid","sequenceNumber","dropped","BaseAudioDemuxer","_audioTrack","_id3Track","frameIndex","cachedData","basePTS","initPTS","lastPTS","resetInitSegment","audioCodec","videoCodec","trackDuration","resetTimeStamp","deaultTimestamp","resetContiguity","appendFrame","demux","lastDataIndex","ID3","id3Track","_isFiniteNumber","initPTSFn","dts","POSITIVE_INFINITY","sample","partialData","audioTrack","videoTrack","textTrack","demuxSampleAes","keyData","_isFiniteNumber2","isHeaderPattern","getHeaderLength","getFullFrameLength","probe","headerLength","frameLength","newOffset","initTrackConfig","observer","samplerate","adtsObjectType","adtsExtensionSamplingIndex","adtsChannelConfig","userAgent","navigator","toLowerCase","manifestCodec","adtsSamplingRates","adtsSamplingIndex","test","channelCount","trigger","ERROR","MEDIA_ERROR","details","FRAG_PARSING_ERROR","fatal","reason","getAudioConfig","getFrameDuration","unit","stamp","header","parseFrameHeader","missing","max","chromeVersion","BitratesMap","SamplingRateMap","SamplesCoefficients","BytesInSlot","parseHeader","samplesPerFrame","sampleRate","mpegVersion","mpegLayer","bitRateIndex","sampleRateIndex","paddingBit","channelMode","bitRate","sampleCoefficient","bytesInSlot","floor","match","parseInt","AACDemuxer","_BaseAudioDemuxer","_inheritsLoose","container","segmentCodec","MpegAudio","ADTS","canGetFrameLength","emsgSchemePattern","MP4Demuxer","txtTrack","captionTrack","initData","_initData$video","_initData$audio","videoSamples","progressive","segmentedData","segmentedRange","valid","remainder","moofs","last","segmentValidRange","extractID3Track","emsgs","emsgInfo","schemeIdUri","timeScale","presentationTimeDelta","presentationTime","eventDuration","leftPresentationTime","rightPresentationTime","isSafeInteger","MAX_SAFE_INTEGER","payload","parseEmsg","getAudioBSID","bsid","numBits","mask","bits","min","AC3Demuxer","samplingRateCode","frameSizeCode","skipCount","lfeon","bsmod","BaseVideoParser","VideoSample","createVideoSample","units","getLastNalUnit","_VideoSample","lastUnit","pushAccessUnit","nbSamples","lastSample","parseNALu","overflow","state","naluState","lastState","lastUnitStart","lastUnitType","getNALuType","ExpGolomb","bytesAvailable","bitsAvailable","loadWord","position","workingBytes","availableBytes","skipBits","count","skipBytes","readBits","valu","skipLZ","leadingZeroCount","skipUEG","skipEG","readUEG","clz","readEG","readBoolean","readUByte","readUShort","readUInt","AvcVideoParser","_BaseVideoParser","parsePES","pes","spsfound","audFound","_VideoSample2","iskey","sliceType","readSliceType","_track$pixelRatio","_track$pixelRatio2","sps","readSPS","width","height","pixelRatio","codecarray","codecstring","pps","eg","skipScalingList","reader","lastScale","nextScale","j","numRefFramesInPicOrderCntCycle","scalingListCount","frameCropLeftOffset","frameCropRightOffset","frameCropTopOffset","frameCropBottomOffset","profileIdc","chromaFormatIdc","picOrderCntType","picWidthInMbsMinus1","picHeightInMapUnitsMinus1","frameMbsOnlyFlag","ceil","HevcVideoParser","args","concat","initVPS","vps","readVPS","matchSPS","prop","codecString","readPPS","ebsp2rbsp","arr","dst","dstIdx","numTemporalLayers","temporalIdNested","max_sub_layers_minus1","general_profile_space","general_tier_flag","general_profile_idc","general_profile_compatibility_flags_1","general_profile_compatibility_flags_2","general_profile_compatibility_flags_3","general_profile_compatibility_flags_4","general_constraint_indicator_flags_1","general_constraint_indicator_flags_2","general_constraint_indicator_flags_3","general_constraint_indicator_flags_4","general_constraint_indicator_flags_5","general_constraint_indicator_flags_6","general_level_idc","sub_layer_profile_present_flags","sub_layer_level_present_flags","chroma_format_idc","pic_width_in_luma_samples","pic_height_in_luma_samples","conformance_window_flag","pic_left_offset","pic_right_offset","pic_top_offset","pic_bottom_offset","bit_depth_luma_minus8","bit_depth_chroma_minus8","log2_max_pic_order_cnt_lsb_minus4","sizeId","matrixId","coefNum","num_short_term_ref_pic_sets","num_delta_pocs","inter_ref_pic_set_prediction_flag","next_num_delta_pocs","used_by_curr_pic_flag","use_delta_flag","num_negative_pics","num_positive_pics","num_long_term_ref_pics_sps","min_spatial_segmentation_idc","sar_width","sar_height","fps_fixed","fps_den","fps_num","default_display_window_flag","aspect_ratio_idc","nal_hrd_parameters_present_flag","vcl_hrd_parameters_present_flag","sub_pic_hrd_params_present_flag","low_delay_hrd_flag","cpb_cnt","chroma_scale_w","chroma_scale_h","profile_space_string","profile_compatibility_buf","profile_compatibility_rev","profile_compatibility_flags_string","tier_flag_string","general_profile_compatibility_flags","general_constraint_indicator_flags","bit_depth","frame_rate","fixed","fps","tiles_enabled_flag","entropy_coding_sync_enabled_flag","parallelismType","sps1","sps2","substr","SampleAesDecrypter","decrypter","decryptBuffer","encryptedData","decryptAacSample","sampleIndex","callback","curUnit","encryptedBuffer","decryptedBuffer","decryptedData","decryptAacSamples","getAvcEncryptedData","decodedData","encryptedDataLen","Int8Array","outputPos","inputPos","getAvcDecryptedUnit","uint8DecryptedData","decryptAvcSample","unitIndex","decryptAvcSamples","curUnits","PACKET_LENGTH","TSDemuxer","typeSupported","sampleAes","pmtParsed","_duration","_pmtId","_videoTrack","_txtTrack","aacOverFlow","videoParser","syncOffset","scanwindow","foundPat","packetStart","tsPackets","parsePID","createTrack","pesData","isSampleAes","videoPid","audioPid","id3Pid","audioData","unknownPID","pmtId","tsPacketErrors","stt","parseAACPES","parseMPEGPES","parseAC3PES","parseID3PES","parsePAT","parsedPIDs","parsePMT","segmentVideoCodec","segmentAudioCodec","emit","demuxResult","extractRemainingSamples","startOffset","frameMissingBytes","sampleLength","frameOverflowBytes","recoverable","levelRetry","frameDuration","parsed","AC3","id3Sample","_extends","tableEnd","esInfoLength","logEncryptedSamplesFoundInUnencryptedStream","mpeg","mp3","ac3","parsePos","remaining","descriptorLen","stream","frag","pesLen","pesHdrLen","pesPts","pesDts","splice","pesFlags","payloadStartOffset","dataLen","MP3Demuxer","AAC","getSilentFrame","MP4","init","types","avc1","avcC","hvc1","hvcC","btrt","dinf","dref","esds","ftyp","mdat","mdia","mfhd","minf","moov","mp4a","dac3","mvex","mvhd","pasp","sdtp","stbl","stco","stsc","stsz","stts","vmhd","smhd","hasOwnProperty","charCodeAt","videoHdlr","audioHdlr","HDLR_TYPES","STTS","STSC","STCO","STSZ","VMHD","SMHD","STSD","majorBrand","avc1Brand","minorVersion","FTYP","box","DINF","upperWordDuration","lowerWordDuration","sn","baseMediaDecodeTime","tracks","boxes","dependsOn","isDependedOn","hasRedundancy","avcc","hSpacing","vSpacing","configlen","audioStsd","sampleDependencyTable","upperWordBaseMediaDecodeTime","lowerWordBaseMediaDecodeTime","cts","arraylen","isLeading","paddingValue","isNonSync","degradPrio","movie","ps","NALuLengthSize","temporal_id_nested","num_temporal_layers","iMax","hvcc","PlaylistLevelType","toMsFromMpegTsClock","destScale","srcBase","toTimescaleFromBase","safariWebkitVersion","MP4Remuxer","vendor","ISGenerated","_initPTS","_initDTS","nextAvcDts","nextAudioPts","videoSampleDuration","isAudioContiguous","isVideoContiguous","videoTrackConfig","defaultTimeStamp","resetNextTimestamp","getVideoStartPts","rolloverDetected","startPTS","reduce","minPTS","delta","normalizePts","remux","accurateTimeOffset","playlistType","independent","audioTimeOffset","videoTimeOffset","hasAudio","hasVideo","enoughAudioSamples","enoughVideoSamples","_videoTrack$pixelRati","_config$pixelRatio","_videoTrack$pixelRati2","_config$pixelRatio2","generateIS","firstKeyFramePTS","firstKeyFrameIndex","findKeyframeIndex","forceKeyFrameOnDiscontinuity","audiovideoTimestampDelta","remuxAudio","audioTrackLength","endPTS","remuxVideo","firstKeyFrame","flushTextTrackMetadataCueSamples","flushTextTrackUserdataCueSamples","initDTS","audioSamples","computePTSDTS","Infinity","metadata","Object","keys","contiguous","firstDTS","lastDTS","inputSamples","outputSamples","mp4SampleDuration","maxPTS","NEGATIVE_INFINITY","sortSamples","abs","initTime","sort","a","deltadts","deltapts","inputDuration","averageSampleDuration","foundHole","foundOverlap","toFixed","firstPTS","nbNalu","naluLen","dtsStep","nbUnits","sampleLen","mdatSize","MUX_ERROR","REMUX_ALLOC_ERROR","setUint32","stretchedLastFrame","minDtsDelta","minPtsDelta","maxDtsDelta","maxPtsDelta","VideoSampleUnits","mp4SampleLength","unitData","unitDataLen","ptsDelta","lastFrameDuration","stretchShortVideoTrack","gapTolerance","maxBufferHole","deltaToFrameEnd","compositionTimeOffset","Mp4Sample","nextDts","nextPts","startDTS","endDTS","nb","getSamplesPerFrame","scaleFactor","inputSampleDuration","rawMPEG","alignedWithVideo","timeOffsetMpegTS","filter","maxAudioFramesDrift","newStamp","fillFrame","audioSample","unitLen","remuxEmptyAudio","init90kHz","silentFrame","reference","isKeyframe","isCodecMediaSourceSupported","preferManagedMediaSource","_MediaSource$isTypeSu","MediaSource","ManagedMediaSource","WebKitMediaSource","getMediaSource","isTypeSupported","mimeTypeForCodec","CODEC_COMPATIBLE_NAMES","AUDIO_CODEC_REGEXP","getCodecCompatibleName","m","lowerCaseCodec","codecsToCheck","flac","opus","getCodecCompatibleNameLower","now","PassThroughRemuxer","emitInitSegment","initTracks","lastEndTime","defaultInitPTS","generateInitSegment","getParsedTrackCodec","audiovideo","_initData","_initData2","rawDuration","videoDuration","audioDuration","trafs","trackDefault","truns","sidxDuration","sidxs","dur","ref","getDuration","fmp4","startTime","getStartDTS","decodeTime","minDuration","isInvalidInitPts","endTime","upper","lower","offsetStartDTS","parsedCodec","performance","Date","muxConfig","Transmuxer","async","demuxer","remuxer","decryptionPromise","transmuxConfig","currentTransmuxState","configure","chunkMeta","stats","transmuxing","executeStart","uintData","_ref","discontinuity","trackSwitch","initSegmentChange","defaultInitPts","initSegmentData","decryptData","encryptionType","method","getEncryptionType","getDecrypter","part","executeEnd","emptyResult","resetMuxers","needsProbing","configureTransmuxer","resetInitialTimestamp","transmux","currentState","transmuxResults","demuxResultOrPromise","isPromise","flushRemux","_this$currentTransmux","remuxResult","transmuxSampleAes","transmuxUnencrypted","_demux","_this3","mux","_muxConfig$i$demux","Remuxer","Demuxer","p","Function","has","prefix","EE","fn","context","once","addListener","emitter","event","TypeError","listener","evt","_events","_eventsCount","clearEvent","EventEmitter","create","__proto__","eventNames","events","names","getOwnPropertySymbols","listeners","handlers","l","ee","listenerCount","a1","a2","a3","a4","a5","removeListener","on","removeAllListeners","off","prefixed","module","exports","emitTransmuxComplete","transmuxResult","transferable","_transmuxResult$remux","addToTransferable","postMessage","handleFlushResult","forwardMessage","ev","FRAG_DECRYPTED","forwardWorkerLogs","_loop","logFn","logType","addEventListener","cmd","JSON","parse","transmuxer","startWorker"],"mappings":"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KAAM,GACNthB,KAAM,GACNC,KAAM,GACNH,KAAM,GACNnF,KAAM,GACNmE,KAAM,GACNxD,KAAM,GACNV,KAAM,GACN2mB,KAAM,GACNC,KAAM,IAIE7B,EAAIE,MACRF,EAAIE,MAAM4B,eAAe/zB,KAC3BiyB,EAAIE,MAAMnyB,GAAK,CACbA,EAAEg0B,WAAW,GACbh0B,EAAEg0B,WAAW,GACbh0B,EAAEg0B,WAAW,GACbh0B,EAAEg0B,WAAW,KAKnB,IAAMC,EAAY,IAAIv1B,WAAW,CAC/B,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,IACA,IACA,IACA,IACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,IACA,IACA,IACA,IACA,GACA,GACA,IACA,IACA,IACA,IACA,IACA,IAGIw1B,EAAY,IAAIx1B,WAAW,CAC/B,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,IACA,IACA,IACA,IACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,IACA,IACA,IACA,IACA,GACA,GACA,IACA,IACA,IACA,IACA,IACA,IAGFuzB,EAAIkC,WAAa,CACfjpB,MAAO+oB,EACP9oB,MAAO+oB,GAGT,IAAMxB,EAAO,IAAIh0B,WAAW,CAC1B,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,IACA,IACA,IACA,GACA,EACA,EACA,EACA,IAGI+0B,EAAO,IAAI/0B,WAAW,CAC1B,EACA,EACA,EACA,EACA,EACA,EACA,EACA,IAGFuzB,EAAImC,KAAOnC,EAAIoC,KAAOpC,EAAIqC,KAAOb,EAEjCxB,EAAIsC,KAAO,IAAI71B,WAAW,CACxB,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,IAEFuzB,EAAIuC,KAAO,IAAI91B,WAAW,CACxB,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,IAEFuzB,EAAIwC,KAAO,IAAI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EAAIrc,KAAW,IAANyB,GAET4a,EAAMA,EAAIsB,OAAO9nB,MAAMd,UAAUa,MAAME,KAAKb,IAG9C,IAAM03B,EAAOzD,EAAI8C,IACf9C,EAAIE,MAAME,KACV,IAAI3zB,WACF,CACE,EACAmmB,EAAI,GACJA,EAAI,GACJA,EAAI,GACJ,IACA,IAAOhX,EAAMgX,IAAIxjB,QAEhBqlB,OAAO7B,GACP6B,OAAO,CACN7Y,EAAMuX,IAAI/jB,SAEXqlB,OAAOtB,KAGRL,EAAQlX,EAAMkX,MACdC,EAASnX,EAAMmX,OACf2Q,EAAW9nB,EAAMoX,WAAW,GAC5B2Q,EAAW/nB,EAAMoX,WAAW,GAElC,OAAOgN,EAAI8C,IACT9C,EAAIE,MAAMC,KACV,IAAI1zB,WAAW,CACb,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACCqmB,GAAS,EAAK,IACP,IAARA,EACCC,GAAU,EAAK,IACP,IAATA,EACA,EACA,GACA,EACA,EACA,EACA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,IACA,GACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,GACA,IACA,IACA,IACA,GACA,IACA,IACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,GACA,KAEF0Q,EACAzD,EAAI8C,IACF9C,EAAIE,MAAMK,KACV,IAAI9zB,WAAW,CACb,EACA,GACA,IACA,IACA,EACA,GACA,IACA,IACA,EACA,GACA,IACA,OAGJuzB,EAAI8C,IACF9C,EAAIE,MAAMmB,KACV,IAAI50B,WAAW,CACbi3B,GAAY,GACXA,GAAY,GAAM,IAClBA,GAAY,EAAK,IACP,IAAXA,EACAC,GAAY,GACXA,GAAY,GAAM,IAClBA,GAAY,EAAK,IACP,IAAXA,OAIP3D,EAEMU,KAAP,SAAY9kB,GACV,IAAMgoB,EAAYhoB,EAAMkI,OAAO1U,OAC/B,OAAO,IAAI3C,WACT,CACE,EACA,EACA,EACA,EAEA,EACA,GAAOm3B,EACP,EACA,EACA,EAEA,EACA,GAAOA,EACP,GACA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EAEA,GAECnP,OAAO,CAACmP,IACRnP,OAAO7Y,EAAMkI,QACb2Q,OAAO,CAAC,EAAM,EAAM,MAE1BuL,EAEM6D,UAAP,SAAiBjoB,GACf,IAAM0N,EAAa1N,EAAM0N,WACzB,OAAO,IAAI7c,WAAW,CACpB,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACAmP,EAAMqO,aACN,EACA,GACA,EACA,EACA,EACA,EACCX,GAAc,EAAK,IACP,IAAbA,EACA,EACA,KAEH0W,EAEMiB,KAAP,SAAYrlB,GACV,OAAOokB,EAAI8C,IACT9C,EAAIE,MAAMe,KACVjB,EAAI6D,UAAUjoB,GACdokB,EAAI8C,IAAI9C,EAAIE,MAAMQ,KAAMV,EAAIU,KAAK9kB,MAEpCokB,EAEMlB,IAAP,SAAWljB,GACT,OAAOokB,EAAI8C,IAAI9C,EAAIE,MAAM,QAASF,EAAI6D,UAAUjoB,KACjDokB,EAEMjB,IAAP,SAAWnjB,GACT,OAAOokB,EAAI8C,IACT9C,EAAIE,MAAM,QACVF,EAAI6D,UAAUjoB,GACdokB,EAAI8C,IAAI9C,EAAIE,MAAMgB,KAAMtlB,EAAMkI,UAEjCkc,EAEMjkB,KAAP,SAAYH,GACV,MAAmB,UAAfA,EAAMvJ,KACmB,QAAvBuJ,EAAM6Q,cAA0C,QAAhB7Q,EAAMO,MACjC6jB,EAAI8C,IAAI9C,EAAIE,MAAMnkB,KAAMikB,EAAIyC,KAAMzC,EAAIlB,IAAIljB,IAExB,QAAvBA,EAAM6Q,aACDuT,EAAI8C,IAAI9C,EAAIE,MAAMnkB,KAAMikB,EAAIyC,KAAMzC,EAAIjB,IAAInjB,IAE5CokB,EAAI8C,IAAI9C,EAAIE,MAAMnkB,KAAMikB,EAAIyC,KAAMzC,EAAIiB,KAAKrlB,IAClB,QAAvBA,EAAM6Q,aACRuT,EAAI8C,IAAI9C,EAAIE,MAAMnkB,KAAMikB,EAAIyC,KAAMzC,EAAIG,KAAKvkB,IAE3CokB,EAAI8C,IAAI9C,EAAIE,MAAMnkB,KAAMikB,EAAIyC,KAAMzC,EAAIK,KAAKzkB,KAErDokB,EAEM/kB,KAAP,SAAYW,GACV,IAAMhJ,EAAKgJ,EAAMhJ,GACX8H,EAAWkB,EAAMlB,SAAWkB,EAAMzB,UAClC2Y,EAAQlX,EAAMkX,MACdC,EAASnX,EAAMmX,OACfiQ,EAAoBprB,KAAKsU,MAAMxR,GAAY5B,GAAa,IACxDmqB,EAAoBrrB,KAAKsU,MAAMxR,GAAY5B,GAAa,IAC9D,OAAOknB,EAAI8C,IACT9C,EAAIE,MAAMjlB,KACV,IAAIxO,WAAW,CACb,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACCmG,GAAM,GAAM,IACZA,GAAM,GAAM,IACZA,GAAM,EAAK,IACP,IAALA,EACA,EACA,EACA,EACA,EACAowB,GAAqB,GACpBA,GAAqB,GAAM,IAC3BA,GAAqB,EAAK,IACP,IAApBA,EACAC,GAAqB,GACpBA,GAAqB,GAAM,IAC3BA,GAAqB,EAAK,IACP,IAApBA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,EACA,EACA,EACCnQ,GAAS,EAAK,IACP,IAARA,EACA,EACA,EACCC,GAAU,EAAK,IACP,IAATA,EACA,EACA,MAGLiN,EAEM7f,KAAP,SAAYvE,EAAOunB,GACjB,IAAMW,EAAwB9D,EAAIsB,KAAK1lB,GACjChJ,EAAKgJ,EAAMhJ,GACXmxB,EAA+BnsB,KAAKsU,MACxCiX,GAAuBrqB,GAAa,IAEhCkrB,EAA+BpsB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oX,WAAW,GAElC,OAAOgN,EAAI8C,IACT9C,EAAIE,MAAMG,KACV,IAAI5zB,WAAW,CACb,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACCqmB,GAAS,EAAK,IACP,IAARA,EACCC,GAAU,EAAK,IACP,IAATA,EACA,EACA,GACA,EACA,EACA,EACA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,IACA,GACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,GACA,IACA,IACA,IACA,GACA,IACA,IACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,GACA,KAEF8R,EACA7E,EAAI8C,IACF9C,EAAIE,MAAMK,KACV,IAAI9zB,WAAW,CACb,EACA,GACA,IACA,IACA,EACA,GACA,IACA,IACA,EACA,GACA,IACA,OAGJuzB,EAAI8C,IACF9C,EAAIE,MAAMmB,KACV,IAAI50B,WAAW,CACbi3B,GAAY,GACXA,GAAY,GAAM,IAClBA,GAAY,EAAK,IACP,IAAXA,EACAC,GAAY,GACXA,GAAY,GAAM,IAClBA,GAAY,EAAK,IACP,IAAXA,OAIP3D,CAAA,CA1xCM,GAAHA,GACUE,WAAK,EADfF,GAEWkC,gBAAU,EAFrBlC,GAGWmC,UAAI,EAHfnC,GAIWoC,UAAI,EAJfpC,GAKWqC,UAAI,EALfrC,GAMWsC,UAAI,EANftC,GAOWuC,UAAI,EAPfvC,GAQWwC,UAAI,EARfxC,GASWyC,UAAI,EATfzC,GAUW6C,UAAI,EAVf7C,GAWW+C,UAAI,ECqJrB,IAAkB+B,GAAiB,QCnJ5B,SAASC,GACd3kB,EACAvI,GAEA,YAFc,IAAdA,IAAAA,GAAiB,GArBZ,SACLuI,EACA4kB,EACAC,EACAptB,QADe,IAAfotB,IAAAA,EAAkB,QACJ,IAAdptB,IAAAA,GAAiB,GAEjB,IAAMiD,EAASsF,EAAW4kB,EAAYC,EAC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","x_google_ignoreList":[8,39]}